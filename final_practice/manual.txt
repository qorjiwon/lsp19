

# 함수 사용법

1. 헤더
2. 함수 원형
3. 구체적 코드 예시
4. 출력 결과


# dup

dup(fd[1])을 사용하면 표준 출력(파일 디스크립터 1)이 파이프로 리디렉션됩니다.
dup(fd[1]) 함수 호출은 현재 열려 있는 파일 디스크립터 중에서 가장 낮은 값을 반환하면서 동시에 주어진 파일 디스크립터(fd[1]에 해당하는)를 복제합니다.
이는 새로운 파일 디스크립터가 원본 파일 디스크립터의 복사본이 되어 같은 파일을 가리키게 됩니다.

#include <unistd.h>

int dup(int oldfd);
oldfd: 복제할 파일 디스크립터

예시 코드:
#include <stdio.h>
#include <unistd.h>

int main() {
    int fd1, fd2;

    // 파일 디스크립터 1로부터 새로운 파일 디스크립터 생성
    fd1 = dup(1);

    // 파일 디스크립터 1을 닫음
    close(1);

    // 파일 디스크립터 1을 다시 열면서 새로운 파일 디스크립터 생성
    fd2 = dup(fd1);

    // 출력을 파일 디스크립터 1로 리디렉션하여 "Hello, world!" 출력
    dprintf(1, "Hello, world!\n");

    // 원래의 파일 디스크립터 1을 닫음
    close(fd1);

    // 출력을 파일 디스크립터 1로 리디렉션하여 "Goodbye, world!" 출력
    dprintf(1, "Goodbye, world!\n");

    return 0;
}

/end

# Basic Commands

# ln -s /home/project/ myproject

### 함수: ‘symlink_create’

### 함수 원형:

```cpp
int symlink_create(const char *target, const char *linkname)
```

### 구체적 코드 예시:

```cpp
int symlink_create(const char *target, const char *linkname) {
    return symlink(target, linkname);
}
```

### 출력 결과:

- 심볼릭 링크 “myproject” 가 현재 디렉토리에 생성됨

/end

# ln -s ~kim/.bashrc .bashrc:

### 함수: ‘user_bashrc_symlink’

### 함수 원형:

```cpp
int user_bashrc_symlic(const char *username)
```

### 구체적 코드 예시:

```cpp
int user_bashrc_symlink(const char *username) {
    char src_path[256];
    snprintf(src_path, sizeof(src_path), "~%s/.bashrc", username);
    return symlink(src_path, ".bashrc");
}
```

### 출력 결과: 현재 디렉토리에 “.bashrc”라는 이름의 심볼릭 링크가 “~kim/.bashrc”파일을 가리키도록 생성됨

/end

# mkfs

# fsck

# mount

### 

# du .

### 함수: calculate_directory_size

### 함수 원형:

```cpp
long calculate_directory_size(const char * directory)
```

### 구체적 코드 예시:

```cpp
long calculate_directory_size(const char *directory) {
    // 디렉토리 크기 계산 명령 실행
    // 예: du -s .
    FILE *fp = popen("du -s %s", directory);
    long size = 0;
    if (fp) {
        fscanf(fp, "%ld", &size);
        pclose(fp);
    }
    return size;
}
```

### 출력결과: 현재 디렉토리의 디스크 사용량이 반환됨

/end

# diff sort.c sort1.c > sort.diff

### 함수: compare_and_save.diff

### 함수 원형:

```cpp
int compare_and_save_diff
(const char *file1, const char *file2, const char* output_file);
```

### 구체적 코드 예시

```cpp
int compare_and_save_diff(const char *file1, const char *file2, const char *output_file) {
    // 파일 비교 및 차이 저장 명령 실행
    // 예: diff file1 file2 > output_file
    char command[256];
    snprintf(command, sizeof(command), "diff %s %s > %s", file1, file2, output_file);
    return system(command);
}
```

### 출력결과: “sort.c”와 “sort1.c”파일을 비교하여 차이를 “sort.diff”파일에 저장한다

/end

# find . -name ‘*.c’ -print

### 함수: find_files_with_extension

### 함수 원형:

```cpp
void find_files_with_extension
(const char *directory, const char *extension);
```

### 구체적 코드 예시:

```cpp
void find_files_with_extension(const char *directory, const char *extension) {
    // 특정 디렉토리에서 특정 확장자를 가진 파일 찾기 명령 실행
    // 예: find . -name '*.c' -print
    char command[256];
    snprintf(command, sizeof(command), "find %s -name '%s' -print", directory, extension);
    system(command);
}
```

### 출력 결과:

- 현재 디렉토리에서 확장자가 “.c”인 파일을 검색하고 파일 경로가 출력됨

/end

# GCC

### 주요옵션:

```cpp
-c: 컴파일만 수행
-I경로명: #include 파일을 위한 경로 추가
-l라이브러리: 라이브러리와 연결
-L 디렉토리: 라이브러리 디렉토리 경로 추가
-o 출력-파일: 출력 파일 이름 설정
-O[레벨]: 객체 코드 최적화(optimization level)
-w: 경고 메시지 표시 안 함
-static: 정적 링킹 (기본적으로 동적 링킹)
```

## 1. -c

### 예시 코드:

```cpp
gcc -c my_program.c
```

## 2. -I

### 예시 코드:

```cpp
gcc -I./include -o my_program my_program.c
```

## 3. -L

### 예시 코드:

```cpp
gcc -o my_program -L./lib -lmylibrary my_program.c
```

### 설명:

- L./lib: 이 옵션은 컴파일러에게 라이브러리 파일을 찾을 디렉토리(경로)를 알려줍니다. 여기서는 현재 디렉토리의 lib 디렉토리를 검색 경로로 지정합니다. -L 옵션 다음에 디렉토리 경로가 나옵니다.
- lmylibrary: 이 옵션은 컴파일러에게 사용할 라이브러리의 이름을 지정합니다. -l 옵션 다음에 라이브러리 이름이 나오며, 컴파일러는 libmylibrary.a (정적 라이브러리) 또는 [libmylibrary.so](http://libmylibrary.so/) (공유 라이브러리)를 찾아서 사용합니다. 여기서는 mylibrary라는 이름의 라이브러리를 사용한다고 지정합니다.

## 4. -O

### 예시 코드:

```cpp
gcc -O2 -o my_program my_program.c
```

## 

/end

# ar 명령어

## 주요옵션:

```cpp
-d: 멤버 삭제
-m: 멤버를 아카이브 끝으로 이동
-p: 내용 출력
-q: 빠른 추가 (아카이브에 파일 추가)
-r: 대체 (멤버 교체)
-t: 목차 표시
-x: 추출
```

### 변형 옵션

```cpp
-c: 아카이브 생성
-u: 업데이트 (기존 멤버 교체 또는 새로운 멤버 추가)
-v: 자세한 정보 출력 (상세 정보 모드)
-aposition-name: 새로운 파일을 position-name 뒤에 배치
-bposition-name: 새로운 파일을 position-name 앞에 배치
```

### 예시

```cpp
ar -help: 도움말 표시
ar rcv 아카이브 파일.o: 아카이브에 파일.o를 생성
ar rav next.o 아카이브 파일.o: 아카이브에 있는 파일.o를 대체
ar xv 아카이브 파일.o: 아카이브에서 파일.o 추출
ar tv 아카이브: 아카이브 내용 표시

연습:
gcc -c mystrcpy.c: mystrcpy.c를 컴파일하여 mystrcpy.o 생성
ar ruv libmine.a mystrcpy.o: libmine.a 아카이브에 mystrcpy.o 추가 또는 업데이트
gcc -o hello -L. hello.c -lmine: hello.c를 libmine.a와 링크하여 hello 실행 파일 생성
./hello: hello 실행
```

/end

# File I/O

## Standard I/O: Output Function

```c
printf("Output: %c %s %d %#X %ld %.4f %.2lf %p\n", 
c, s, i, i, l, f, d, p);
```

%c: 이 서식 지정자는 문자를 출력

%s: 이 서식 지정자는 문자열을 출력

%d: 이 서식 지정자는 10진수 정수를 출력

%#X: 이 서식 지정자는 16진수 정수를 출력하며, 0x 접두사가 함께 출력

%ld: 이 서식 지정자는 long 자료형의 정수를 출력

%.4f: 이 서식 지정자는 소수점 이하 4자리까지의 부동 소수점 숫자를 출력

%.2lf: 이 서식 지정자는 소수점 이하 2자리까지의 double 자료형 숫자를 출력

%p: 이 서식 지정자는 포인터를 출력

## Standard I/O: Input Function

```c
scanf("%c %s %d %ld %f %lf", &c, s, &i, &l, &f, &d);
```

"%c": 이 서식 지정자는 하나의 문자를 표준 입력에서 읽어와서 변수 c에 저장합니다. &c는 변수 c의 주소를 나타냅니다.

"%s": 이 서식 지정자는 문자열을 표준 입력에서 읽어와서 변수 s에 저장합니다. s는 문자열을 저장할 배열이어야 하며 주소 연산자 &를 사용하지 않습니다.

"%d": 이 서식 지정자는 정수를 표준 입력에서 읽어와서 변수 i에 저장합니다. &i는 변수 i의 주소를 나타냅니다.

"%ld": 이 서식 지정자는 long 자료형의 정수를 표준 입력에서 읽어와서 변수 l에 저장합니다. &l는 변수 l의 주소를 나타냅니다.

"%f": 이 서식 지정자는 부동 소수점 숫자를 표준 입력에서 읽어와서 변수 f에 저장합니다. &f는 변수 f의 주소를 나타냅니다.

"%lf": 이 서식 지정자는 double 자료형의 부동 소수점 숫자를 표준 입력에서 읽어와서 변수 d에 저장합니다. &d는 변수 d의 주소를 나타냅니다.

## Types

```c
typedef unsigned long size_t
```

### 구체적 코드 예시:

```cpp
#include <stdio.h>

// 'size_t'를 'unsigned long'으로 정의
typedef unsigned long size_t;

int main() {
    size_t count = 10;  // 'size_t'로 정의된 변수를 사용

    printf("The count is: %lu\n", count);  // 'size_t' 변수 출력

    return 0;
}
```

```cpp
typedef struct SumValue {
    int s;      // 시작 값
    int sum;    // 합계 결과
} SUMVALUE, *SUM;
```

/end

## read 함수:

## 헤더

```jsx
#include <unistd.h>
```

## 함수 원형

```c
ssize_t read(int fd, void *buf, size_t nbytes);
```

## 함수 설명

 read 함수는 주어진 파일 디스크립터(fd)에서 데이터를 읽어와 메모리 버퍼(buf)에 저장합니다. nbytes 매개변수에 지정한 바이트 수만큼 데이터를 읽어옵니다.

**인자:** 

1. **`int fd`**: 파일 디스크립터 (File Descriptor)
    - 읽기 작업을 수행할 파일이나 소켓을 가리키는 파일 디스크립터를 나타내는 정수입니다.
2. **`void *buf`**: 읽은 데이터를 저장할 버퍼의 포인터
    - 읽은 데이터가 저장될 메모리 버퍼의 시작 지점을 가리키는 포인터입니다. 이 버퍼는 충분히 크게 할당되어야 합니다.
3. **`size_t count`**: 읽을 바이트 수
    - 읽고자 하는 데이터의 바이트 수를 나타내는 양의 정수입니다. 함수는 최대 **`count`** 바이트 만큼 데이터를 읽을 것입니다.

**반환값:**

 **읽기가 성공:** 읽어온 바이트 수를 반환

 **파일의 끝 도달:** 파일의 끝에 도달하면 0을 반환

 **오류발생:** 오류가 발생하면 -1을 반환합니다.

### 코드 예시:

```c
#include <fcntl.h>
#include <unistd.h>

int main() {
    int fd;
    char buffer[100];

    // 파일 열기
    fd = open("example.txt", O_RDONLY);

    // 파일에서 데이터 읽기
    ssize_t bytesRead = read(fd, buffer, sizeof(buffer));

    // 읽은 데이터 출력
    write(STDOUT_FILENO, buffer, bytesRead);

    // 파일 닫기
    close(fd);

    return 0;
}
```

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/dfa28d76-5333-40b3-9780-fbbeab3c8ca0/c529e921-cbab-49cf-98b7-919f1c1cad85/Untitled.png)

"example.txt" 파일을 열어서 최대 100바이트까지의 데이터를 읽고, 읽은 데이터를 터미널에 출력

STDOUT_FILENO 대신 1 가능
/end

## close함수

```c
#include <unistd.h>
int close(int fd);
```

**설명:**

 close 함수는 파일 디스크립터를 사용한 파일 또는 장치를 닫을 때 사용됩니다. 파일 디스크립터를 더 이상 사용하지 않을 때 이 함수를 호출하여 자원을 해제합니다.

**인자:**

 파일 디스크립터 (File Descriptor)

- 닫을 파일이나 소켓을 가리키는 파일 디스크립터를 나타내는 정수입니다.

**반환값:**

성공시 0, 실패시 -1 반환

/end

## open 함수

### 헤더

```c
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
```

### 함수 원형

```cpp
int open(char *pathname, int oflag, ... /*, mode_t mode */);
```

### 함수 설명

open 함수는 파일이나 장치를 열 때 사용됩니다.

**인자:**

1. **`const char *path`**: 파일 경로
    - 열고자 하는 파일의 경로를 나타내는 문자열입니다.
2. **`int flags`**: 파일 열기 플래그 (Open Flags)
    - 파일을 열 때의 옵션을 나타내는 플래그로, 열기 모드, 읽기 또는 쓰기 권한 등을 설정합니다
3. **`mode_t mode`**: 파일 모드
    - 파일을 생성할 때 사용되며, 파일의 허가 권한을 나타내는 값입니다. 주로 **`S_IRUSR`**, **`S_IWUSR`**, **`S_IXUSR`**, **`S_IRGRP`**, **`S_IWGRP`**, **`S_IXGRP`**, **`S_IROTH`**, **`S_IWOTH`**, **`S_IXOTH`** 등으로 설정됩니다.

**`open`** 함수는 파일을 열고, 성공할 경우 파일 디스크립터를 반환합니다. 파일 디스크립터는 열린 파일을 식별하는 정수입니다. 만약 열기에 실패하면 **`-1`**을 반환하며, **`open`** 함수는 에러 코드를 설정합니다.

예를 들어, 다음은 파일을 읽기 전용으로 열고 해당 파일 디스크립터를 반환하는 예제입니다:

```c
#include <fcntl.h>int main() {
    const char *filename = "example.txt";
    int fd = open(filename, O_RDONLY);

    if (fd == -1) {
        perror("open");
        return 1;
    }

    // 파일 디스크립터(fd)를 사용하여 파일에서 데이터를 읽거나 다른 작업을 수행할 수 있습니다.

    return 0;
}
```

위의 코드에서 **`open`** 함수는 "example.txt" 파일을 읽기 전용으로 열고, 파일 디스크립터를 반환합니다.

Is this conversation helpful so far?

**반환값:**

 지정된 경로(pathname)에 대한 파일 디스크립터를 반환

**두 번째 매개변수 oflag:**

O_RDONLY: 읽기 전용으로 파일 열기.
O_WRONLY: 쓰기 전용으로 파일 열기.
O_RDWR: 읽기 및 쓰기 가능한 모드로 파일 열기.
O_APPEND: 파일을 끝에 추가하는 모드로 열기.
O_CREAT: 파일이 없는 경우 새로 생성.
O_EXCL: O_CREAT와 함께 사용하여 이미 존재하는 파일을 덮어쓰지 않음.
O_TRUNC: 파일이 존재한다면 내용을 모두 없앰
O_NONBLOCK: 블로킹을 방지하는 비차단 모드로 열기.
O_SYNC: 파일 쓰기를 동기화하여 데이터 손실을 방지.

**세 번째 매개 변수 권한:**

- **`S_IRUSR`** (00400): 소유자 읽기 권한 (Owner Read)
- **`S_IWUSR`** (00200): 소유자 쓰기 권한 (Owner Write)
- **`S_IXUSR`** (00100): 소유자 실행 권한 (Owner Execute)
- **`S_IRGRP`** (00040): 그룹 읽기 권한 (Group Read)
- **`S_IWGRP`** (00020): 그룹 쓰기 권한 (Group Write)
- **`S_IXGRP`** (00010): 그룹 실행 권한 (Group Execute)
- **`S_IROTH`** (00004): 기타 사용자 읽기 권한 (Others Read)
- **`S_IWOTH`** (00002): 기타 사용자 쓰기 권한 (Others Write)
- **`S_IXOTH`** (00001): 기타 사용자 실행 권한 (Others Execute)

파일 모드는 이러한 권한 비트를 조합하여 표현할 수 있습니다.

 예),소유자에게 읽기 및 쓰기/ 그룹 및 기타 사용자에 읽기 권한

- **`S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH`** (00400 | 00200 | 00040 | 00004) = 00644

### open, close, write, read 코드 예시

```jsx

#include <fcntl.h>
#include <unistd.h>

#define	MAX_BUF	1024

main(int argc, char *argv[])
{
	int 	fd1, fd2, count;
	char	buf[MAX_BUF];

	fd1 = open(argv[1], O_RDONLY);
	fd2 = open(argv[2], O_WRONLY | O_CREAT | O_TRUNC, 0644);

	while ((count = read(fd1, buf, MAX_BUF)) > 0)
		write(fd2, buf, count);

	close(fd1);
	close(fd2);
}
```

**O_WRONLY | O_CREAT | O_TRUNC, 0644 :**

이는 다음과 같이 해석할 수 있다.
쓰기 전용으로 파일을 열되 없으면 그 파일을 만들고 만약 파일이 존재한다면 모두 지우고 작성하라. 그리고 소유자에게 읽기, 쓰기/ 그룹 및 기타 사용자에 읽기 권한을 주어라

**read(fd1, buf, MAX_BUF):**

buf에 MAX_BUF만큼 fd1을 읽어들여라

 성공시 읽어들인 바이트 수, 실패시 -1 반환, EOF는 0반환하기 때문에 읽기에 실패하거나 EOF를 만나기 전까지 반복한다.

**write(fd2, buf, count);**

fd2에 buf에 담긴 내용을 count만큼 적어라

출력 결과

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/dfa28d76-5333-40b3-9780-fbbeab3c8ca0/c37496da-12e2-46de-b52a-bc5ac2693fba/Untitled.png)

/end

# lseek 함수:

## 헤더

```c
#include <sys/types.h>
#include <unistd.h>
```

## 함수 원형

```jsx
int lseek(int fd, off_t offset, int whence);
```

## 함수 설명:

 lseek 함수는 주어진 파일 디스크립터(fd)에서 읽기 또는 쓰기 위치를 offset 바이트만큼 whence에 따라 재설정.

offset: 새로운 위치를 지정하는데 사용되며, whence는 위치를 어디서부터 계산할지를 지정하는데 사용.

**인자:**

1. **`int fd`: 파일 디스크립터 (File Descriptor)**
    - 파일 포인터를 이동시킬 파일을 가리키는 파일 디스크립터를 나타내는 정수입니다.
2. **`off_t offset`: 이동할 오프셋 (Offset)**
    - 파일 포인터가 이동할 오프셋을 나타내는 정수입니다. 이것은 파일의 시작점으로부터의 오프셋입니다. 양수, 음수 또는 0이 될 수 있습니다.
3. **`int whence`: 기준 위치 (Whence)**
    - 파일 포인터를 어떤 위치를 기준으로 이동시킬 것인지를 지정하는 값입니다. 주요 옵션으로는 다음이 있습니다:
        - **`SEEK_SET`**: 파일의 시작점을 기준으로 **`offset`**만큼 이동합니다.
        - **`SEEK_CUR`**: 현재 파일 포인터 위치를 기준으로 **`offset`**만큼 이동합니다.
        - **`SEEK_END`**: 파일의 끝을 기준으로 **`offset`**만큼 이동합니다.

**반환값:** 

성공: 파일 포인터를 이동시키고, 이동된 파일 포인터의 새 위치를 반환합니다. 이 함수를 사용하여 파일에서 원하는 위치로 이동하고 데이터를 읽거나 쓸 수 있습니다.

오류: -1을 반환합니다.

whence 매개변수:

SEEK_SET (0): offset을 파일의 시작 위치에서부터 설정합니다.
SEEK_CUR (1): offset을 현재 위치에서부터 설정합니다.
SEEK_END (2): offset을 파일의 끝 위치에서부터 설정합니다.

(fd, 0, SEEK_SET) ⇒ 파일의 처음부터

(fd, 0, SEEK_END) ⇒ 파일의 끝

### 함수 예제

```jsx
#include <stdio.h>
#include <stdlib.h>
#include <fcntl.h>
#include <unistd.h>

int main() {
    int fd;
    off_t offset;
    char buffer[100];

    // 파일을 읽기 전용으로 엽니다.
    fd = open("example.txt", O_RDONLY);

	 // 파일 위치 지시자를 50바이트로 이동시킵니다.
    offset = lseek(fd, 50, SEEK_SET);

	// 파일로부터 데이터를 읽어옵니다.
    ssize_t bytesRead = read(fd, buffer, sizeof(buffer));

	// 읽어온 데이터를 표준 출력에 출력합니다.
    write(STDOUT_FILENO, buffer, bytesRead);

    // 파일을 닫습니다.
    close(fd);

    return 0;
}
```

### 실행결과:

example.txt

```jsx
This is an example file used for testing the lseek function in C programming.
It contains several lines of text.
The program will read starting from the 51st byte of this file.
This is line 4.
This is line 5.
End of file.
```

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/dfa28d76-5333-40b3-9780-fbbeab3c8ca0/0d17134c-3992-438c-8dd9-25b6d2d77712/Untitled.png)

/end

## creat 함수:

## 헤더

```c
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
```

## 함수 원형

```jsx
int creat(char *pathname, mode_t mode);
```

**인자:**

1. **`const char *path`**: 파일 경로
    - 생성할 파일의 경로를 나타내는 문자열입니다.
2. **`mode_t mode`**: 파일 모드
    - 파일을 생성할 때 사용되며, 파일의 허가 권한을 나타내는 값입니다. 주로 **`S_IRUSR`**, **`S_IWUSR`**, **`S_IXUSR`**, **`S_IRGRP`**, **`S_IWGRP`**, **`S_IXGRP`**, **`S_IROTH`**, **`S_IWOTH`**, **`S_IXOTH`** 등으로 설정됩니다.

**`creat`** 함수는 파일을 생성하고, 해당 파일을 읽고 쓸 수 있는 파일 디스크립터를 반환합니다. 파일이 이미 존재하는 경우 해당 파일을 엽니다. **`creat`** 함수의 사용 예는 다음과 같습니다:

**설명:**

creat 함수는 지정된 경로(pathname)에 새로운 파일을 생성하고 해당 파일을 쓰기 전용으로 엽니다. 일반적으로 파일을 생성하는 동시에 열어서 사용합니다.

**반환값:**

 파일 생성 및 열기가 성공하면, 함수는 생성된 파일의 파일 디스크립터를 반환합니다. 오류가 발생하면 -1을 반환합니다. 

creat 함수는 open(pathname, O_WRONLY | O_CREAT | O_TRUNC, mode) 함수와 동등한 역할을 합니다.

이러한 함수들은 파일 또는 디바이스를 조작하거나 파일의 위치를 조절하는데 사용되며, 파일 작업 및 데이터 조작에 필수적입니다.

### 코드예제

```jsx
#include <fcntl.h>
#include <unistd.h>

int main() {
    int fd;
    mode_t mode = S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH; // 0644 권한 설정

    fd = creat("example.txt", mode);
    close(fd); // 파일 디스크립터를 사용한 후에는 꼭 닫아주어야 합니다.
    

    return 0;
}
```

/end

# fcnlt

## 헤더

```jsx
#include <sys/types.h>
#include <unistd.h>
#include <fcntl.h>
```

## 함수 원형

```jsx

int fcntl(int fd, int cmd, ... /* int arg */);
```

**설명:**

 fcntl 함수는 주어진 파일 디스크립터(fd)에 대한 다양한 조작을 수행합니다. cmd에 따라 다양한 작업을 수행하며, 파일 디스크립터의 속성 및 동작을 변경할 수 있습니다.

**인자:**

1. **`fd`**: 파일 디스크립터(File Descriptor)입니다. **`fcntl`** 함수가 조작할 파일을 나타내는 정수 값입니다.
2. **`cmd`**: 수행하고자 하는 명령을 나타내는 정수 값입니다. **`cmd`** 값에 따라 **`fcntl`** 함수는 다양한 동작을 수행합니다. 명령에 따라 추가적인 인자들이 필요할 수 있습니다.
    - **`F_DUPFD`**: 파일 디스크립터를 복제합니다.
    - **`F_GETFL`**: 파일 상태 플래그를 가져옵니다.
    - **`F_SETFL`**: 파일 상태 플래그를 설정합니다.
    - **`F_GETFD`**: 파일 플래그(종료 시 파일을 자동으로 닫을지 여부 등)를 가져옵니다.
    - **`F_SETFD`**: 파일 플래그를 설정합니다.
    - **`F_GETLK`**: 락(잠금) 정보를 가져옵니다.
    - **`F_SETLK`**: 락(잠금)을 설정합니다.
    - **`F_SETLKW`**: 락(잠금)을 설정하고, 다른 프로세스가 락을 설정하고 있을 경우 대기합니다.
3. **`arg`**: 명령에 필요한 추가적인 인자입니다.  **`cmd`** 값이 어떤 동작을 수행하는지에 따라 **`arg`** 값이 달라집니다.

**반환값:**

 cmd에 따라 반환값이 달라집니다. 성공한 경우 반환값은 cmd에 따라 다르며, 오류가 발생하면 -1을 반환합니다.

### 함수 예제

```jsx
#include <stdio.h>
#include <stdlib.h>
#include <fcntl.h>
#include <unistd.h>

int main() {
    int fd;
    int flags;

    // 파일을 엽니다.
    fd = open("example.txt", O_RDONLY);

    // 현재 파일 상태 플래그를 가져옵니다.
    flags = fcntl(fd, F_GETFL, 0);

    // 파일 상태 플래그에 O_NONBLOCK 비트를 추가하여 비차단 모드로 설정합니다.
    flags |= O_NONBLOCK;

    // 새로운 파일 상태 플래그를 설정합니다.
    fcntl(fd, F_SETFL, flags);
    
    // 파일을 읽습니다.
    char buffer[1024];
    ssize_t bytesRead = read(fd, buffer, sizeof(buffer));

    printf("Read %zd bytes: %.*s\n", bytesRead, (int)bytesRead, buffer);

    // 파일을 닫습니다.
    close(fd);

    return 0;
}
```

/end

## fopen 함수:

```c
#include <stdio.h>
FILE *fopen(char *pathname, char *type);
```

**설명:** 

fopen 함수는 파일 스트림을 열 때 사용됩니다. 지정된 경로(pathname)의 파일을 열고, 해당 파일과 상호 작용하기 위한 파일 스트림을 생성하여 반환합니다.

**반환값**:

 파일 스트림을 성공적으로 열었을 경우, 함수는 해당 파일 스트림을 가리키는 파일 포인터(FILE *)를 반환합니다. 오류가 발생한 경우 NULL을 반환합니다.

**인자:**

1. **filename**: 열고자 하는 파일의 경로를 나타내는 문자열입니다. 예를 들어, "example.txt"나 "/path/to/file.txt"와 같은 형태의 파일 경로가 될 수 있습니다.
2. **mode**: 파일을 어떤 형태로 열지를 지정하는 문자열입니다. 이 문자열은 파일에 대한 권한과 동작을 정의합니다. 일반적으로 사용되는 **`mode`** 문자열들은 다음과 같습니다:
    - **`"r"`**: 읽기 모드. 파일을 읽기 위해 엽니다. 파일이 존재하지 않으면 NULL을 반환합니다.
    - **`"w"`**: 쓰기 모드. 파일을 쓰기 위해 엽니다. 파일이 이미 존재한다면 내용을 지우고 새로운 파일로 열립니다. 파일이 존재하지 않으면 새로운 파일을 생성합니다.
    - **`"a"`**: 추가 모드. 파일을 쓰기 위해 엽니다. 파일이 이미 존재한다면 파일 끝에 새로운 데이터를 추가합니다. 파일이 존재하지 않으면 새로운 파일을 생성합니다.
    - **`"r+"`**: 읽기/쓰기 모드. 파일을 읽고 쓰기 위해 엽니다. 파일이 존재하지 않으면 NULL을 반환합니다.
    - **`"w+"`**: 읽기/쓰기 모드. 파일을 읽고 쓰기 위해 엽니다. 파일이 이미 존재한다면 내용을 지우고 새로운 파일로 열립니다. 파일이 존재하지 않으면 새로운 파일을 생성합니다.
    - **`"a+"`**: 추가/읽기 모드. 파일을 읽고 쓰기 위해 엽니다. 파일이 이미 존재한다면 파일 끝에 새로운 데이터를 추가합니다. 파일이 존재하지 않으면 새로운 파일을 생성합니다.

### 함수예제

```jsx
#include <stdio.h>

int main() {
    FILE *file; // 파일 포인터 선언

    // 파일을 쓰기 모드("w")로 열기
    file = fopen("example.txt", "w");

    // 파일에 텍스트 쓰기
    fprintf(file, "Hello, World!\n");

    // 파일 닫기
    fclose(file);

    // 터미널에 출력하기 위해 파일을 읽기 모드("r")로 열기
    file = fopen("example.txt", "r");

    // 파일에서 내용 읽어오기
    char buffer[100];
i    while (fgets(buffer, sizeof(buffer), file) != NULL) {
        printf("%s", buffer);
    }

    // 파일 닫기
    fclose(file);

    return 0;
}
```

/end

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/dfa28d76-5333-40b3-9780-fbbeab3c8ca0/ddd04f26-e799-481b-a3aa-65f61bd88e6f/Untitled.png)

## fclose 함수:

```c
#include <stdio.h>
int fclose(FILE *fp);
```

**설명:**

 fclose 함수는 파일 스트림을 닫을 때 사용됩니다. 파일 스트림을 닫으면 해당 스트림과 관련된 리소스가 해제되고 파일을 안전하게 닫을 수 있습니다.

**반환값:**

 파일 스트림을 성공적으로 닫았을 경우, 함수는 0을 반환합니다. 오류가 발생한 경우 EOF(-1)을 반환합니다.

**코드 예시:** fopen 참조
/end

# Read and Write a Stream

문자 단위 입력 함수 (Input functions):

## getc 함수: - file 포인터에서 하나씩 리턴을 한다.

```c
int getc(FILE *stream);
```

**함수 설명:** 

getc 함수는 파일 스트림에서 다음 문자를 읽어온 후, 파일 포인터를 한 칸 앞으로 이동시킵니다. 

**반환값:**  읽은 문자의 ASCII 값(정수)를 반환합니다. 파일의 끝(EOF, End of File)에 도달하면 **`EOF`** 상수(-1)를 반환합니다.

**인자:**

- **`stream`**: 파일 스트림 포인터를 가리키는 매개변수입니다. 이 스트림은 파일에서 문자를 읽어올 대상을 가리키는 역할을 합니다.

**코드예시:**

```c
#include <stdio.h>

int main() {
    FILE *file = fopen("example.txt", "r");
    if (file == NULL) {
        perror("File opening failed");
        return 1;
    }

    int c;
    while ((c = getc(file)) != EOF) {
        putchar(c);
    }

    fclose(file);
    return 0;
}
```

/end

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/dfa28d76-5333-40b3-9780-fbbeab3c8ca0/f9a2bf3b-dd4f-4ca6-85bf-73ba9c50027d/Untitled.png)

## fgetc 함수:

```c
int fgetc(FILE *stream);
```

**함수설명:  `fgetc()`** 함수는 파일 스트림 또는 표준 입력 스트림(stdin)으로부터 다음 문자를 읽어온 후, 파일 포인터를 한 칸 앞으로 이동시킵니다. **`fgetc()`** 함수는 주로 파일 또는 표준 입력에서 문자를 읽을 때 사용됩니다.

**인자: `stream`**: 파일 스트림 포인터를 가리키는 매개변수입니다. 이 스트림은 파일 뿐만 아니라 표준 입력(stdin) 또는 표준 출력(stdout) 스트림을 가리키는 역할을 할 수 있습니다.

**반환값:** 읽은 문자의 ASCII 값(정수)를 반환하며, 파일 끝(EOF, End of File)에 도달하면 **`EOF`** 상수(-1)를 반환합니다.

```c
#include <stdio.h>

int main() {
    FILE *file = fopen("example.txt", "r");
    if (file == NULL) {
        perror("File opening failed");
        return 1;
    }

    int c;
    while ((c = fgetc(file)) != EOF) {
        putchar(c);
    }

    fclose(file);
    return 0;
}
```

/end

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/dfa28d76-5333-40b3-9780-fbbeab3c8ca0/bb5882ad-cc01-4f7d-bea3-806f9f0ae308/Untitled.png)

### getc vs fgetc?

getc는 매크로로 구현되어있다는 점만 제외하면 둘은 같다.

다만 매크로로 구현되어있다는 점에서 인자로 수식이 오면 안된다. 예를 들어 다음과 같은 예시는 안된다.

```c
char c = getc(*p++)
```

문자 단위 출력 함수 (Output functions):

## putc 함수:

```c
int putc(int character, FILE *stream);
```

**함수설명: `putc()`** 함수는 주어진 파일 스트림에 **`character`**로 전달된 문자를 쓰고, 파일 포인터를 한 칸 앞으로 이동시킵니다. 

**반환값: `putc()`** 함수가 성공하면 쓴 문자의 ASCII 값(정수)를 반환하며, 실패하면 **`EOF`** 상수(-1)을 반환합니다.

**인자:**

- **`character`**: 출력하고자 하는 문자의 ASCII 값(정수)입니다.
- **`stream`**: 파일 스트림 포인터를 가리키는 매개변수입니다. 이 스트림은 파일에 문자를 쓸 대상을 가리키는 역할을 합니다.

**코드예시:**

```c
#include <stdio.h>

int main() {
    FILE *file = fopen("output.txt", "w");
    if (file == NULL) {
        perror("File opening failed");
        return 1;
    }

    int character = 'A'; // ASCII 코드로 'A'
    if (putc(character, file) == EOF) {
        perror("putc failed");
        return 1;
    }

    fclose(file);
    return 0;
}
```

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/dfa28d76-5333-40b3-9780-fbbeab3c8ca0/b118813a-25d5-436f-b84a-e5b3988d27c0/Untitled.png)

줄바꿈이 없기 때문에 유저네임 앞에 뜬다.
/end

## fputc 함수:

```c
int fputc(int character, FILE *stream);
```

**함수설명:**

**`fputc()`** 함수는 주어진 파일 스트림에 **`character`**로 전달된 문자를 쓰고, 파일 포인터를 한 칸 앞으로 이동시킵니다.

**인자:**

- **`character`**: 출력하고자 하는 문자의 ASCII 값(정수)입니다.
- **`stream`**: 파일 스트림 포인터를 가리키는 매개변수입니다. 이 스트림은 파일에 문자를 쓸 대상을 가리키는 역할을 합니다.

**반환값:**

 **`fputc()`** 함수가 성공하면 쓴 문자의 ASCII 값(정수)를 반환하며, 실패하면 **`EOF`** 상수(-1)을 반환합니다.

1. Line-At-A-Time I/O

:  파일에서 한 번에 한 행(라인)을 읽거나 쓰는 C 프로그래밍 작업을 의미

한 행(라인)을 읽는 함수 (Input functions):

**putc vs fputc**

putc는 매크로로 구현 (전처리기에서 처리), fputc는 실제 서브루틴 (실제 코드 블럭) 

```c
#include <stdio.h>

int main() {
    FILE *file;
    char ch = 'A';

    // 파일을 쓰기 모드("w")로 열기
    file = fopen("example.txt", "w");

    // 파일 열기에 실패한 경우 에러 메시지 출력
    if (file == NULL) {
        perror("Error opening the file");
        return 1;
    }

    // 문자를 파일에 쓰기
    if (fputc(ch, file) == EOF) {
        perror("Error writing to the file");
    } else {
        printf("Character written to the file: %c\n", ch);
    }

    // 파일 스트림 닫기
    fclose(file);

    return 0;
}
```

/end

# Line-AT-A-Time

## fgets 함수:

```c
char *fgets(char *str, int num, FILE *stream);
```

**함수설명:**
**`fgets()`** 함수는 파일 스트림 또는 표준 입력 스트림에서 문자열을 읽어오며, 개행 문자(**`'\n'`**)를 만나거나 **`num-1`** 글자를 읽을 때까지 읽어옵니다. 읽은 문자열은 **`str`** 인자가 가리키는 문자 배열에 저장되며, 문자열 끝에 null 종결 문자(**`'\0'`**)가 자동으로 추가됩니다.

**인자:**

- **`str`**: 문자열을 저장할 문자 배열의 포인터입니다. 읽어온 문자열은 이 배열에 저장됩니다.
- **`num`**: 읽어올 문자열의 최대 길이를 나타내는 정수입니다.
- **`stream`**: 파일 스트림 포인터를 가리키는 매개변수입니다. 이 스트림은 파일 또는 표준 입력 스트림(stdin)에서 문자열을 읽어올 대상을 가리키는 역할을 합니다.

**반환값:**

1. **성공한 경우**:
    - **`fgets()`** 함수가 문자열을 성공적으로 읽었을 때, 반환값은 **`str`** 인자가 가리키는 문자 배열의 포인터입니다. 즉, **`str`**을 반환합니다.
    - 이 경우, **`str`** 배열에 읽어온 문자열이 저장되며, 문자열 끝에 null 종결 문자(**`'\0'`**)가 추가됩니다.
2. **파일의 끝(EOF)에 도달한 경우 or 오류 발생**:
    - 파일에서 더 이상 읽을 데이터가 없어서 EOF에 도달한 경우, **`fgets()`** 함수는 **`NULL`** 포인터를 반환합니다.

**코드예시:**

```c
#include <stdio.h>

int main() {
    FILE *file = fopen("example.txt", "r");
    if (file == NULL) {
        perror("File opening failed");
        return 1;
    }

    char buffer[100]; // 최대 99글자까지 읽을 수 있음

    while (fgets(buffer, sizeof(buffer), file) != NULL) {
        printf("Read: %s", buffer);
    }

    fclose(file);
    return 0;
}
```

/end

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/dfa28d76-5333-40b3-9780-fbbeab3c8ca0/6bd1a6b5-180e-4e5d-9fd3-b99f3ee947ee/Untitled.png)

## fputs

```c
int fputs(const char *str, FILE *stream);
```

**함수설명:**

**`fputs()`** 함수는 **`str`**로 전달된 문자열을 **`stream`**에 출력합니다. 문자열은 null 종결 문자(**`'\0'`**)로 끝나야 하며, 이 종결 문자는 출력에 포함되지 않습니다. 주로 **`fputs()`** 함수는 문자열을 파일에 저장하거나 화면에 출력할 때 사용됩니다.

**인자설명:**

- **`str`**: 출력하고자 하는 문자열의 주소(포인터)입니다.
- **`stream`**: 파일 스트림 포인터를 가리키는 매개변수입니다. 이 스트림은 파일 또는 표준 출력 스트림(stdout)에 문자열을 출력할 대상을 가리키는 역할을 합니다.

**반환값:**

 출력이 성공하면 **`0`**을 반환하고, 오류가 발생하면 **`EOF`** 상수(-1)를 반환합니다.

**코드예시:**

```c
#include <stdio.h>

int main() {
    FILE *file = fopen("output.txt", "w");
    if (file == NULL) {
        perror("File opening failed");
        return 1;
    }

    const char *text = "This is a sample text.\n";
    
    if (fputs(text, file) == EOF) {
        perror("fputs failed");
        return 1;
    }

    fclose(file);
    return 0;
}
```

/end

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/dfa28d76-5333-40b3-9780-fbbeab3c8ca0/a709452e-bdbb-4453-b1ed-c47973e7caa6/Untitled.png)

# Direct I/O

이진 데이터를 읽는 함수 (Input functions):

## fread 함수:

```c
size_t fread(void *ptr, size_t size, size_t count, FILE *stream);
```

**함수설명:**

**`fread()`** 함수는 **`stream`**으로부터 **`size`**와 **`count`**에 정의된 길이만큼 데이터를 읽어서 **`ptr`**이 가리키는 버퍼에 저장합니다. 읽은 데이터의 총 크기는 **`size * count`** 바이트입니다.

**`fread()`** 함수는 이진 파일에서 데이터를 읽을 때 사용되며, 예를 들어 바이너리 파일, 이미지 파일, 오디오 파일 등의 파일에서 데이터를 읽어오는 작업에 유용합니다. 함수 호출 후에 읽은 데이터는 버퍼에 저장되며, 이를 원하는 방식으로 처리하거나 분석할 수 있습니다.

**인자:**

- **`ptr`**: 읽은 데이터를 저장할 버퍼의 포인터입니다.
- **`size`**: 각 요소의 크기(바이트 단위)를 나타내는 정수입니다.
- **`count`**: 읽을 요소의 수를 나타내는 정수입니다.
- **`stream`**: 파일 스트림 포인터를 가리키는 매개변수입니다. 이 스트림은 데이터를 읽어올 대상을 가리키는 역할을 합니다.

**반환값:**

 함수가 호출되면 읽은 바이트 수를 반환하며, 반환값은 보통 **`size * count`**와 같아야 합니다. 만약 파일의 끝(EOF, End of File)에 도달하면 반환값은 실제로 읽은 바이트 수와 적은 값을 반환하게 됩니다.

**코드예시:**

바이너리 코드를 작성하는거라 예시쓰기가 어려움, 실습중 split과 merge참고

일반적으로 텍스트 작업은 fgets로 바이너리파일은 fread로

```c
#include <stdio.h>
#include <stdlib.h>

int main() {
    FILE *file;
    char buffer[100]; // 읽어온 데이터를 저장할 버퍼
    size_t bytesRead; // fread 함수가 반환하는 읽은 데이터의 개수

    // 바이너리 파일을 바이너리 읽기 모드로 엽니다.
    file = fopen("binaryfile.bin", "rb");

    // 파일 열기에 실패한 경우 에러 메시지를 출력하고 프로그램을 종료합니다.
    if (file == NULL) {
        perror("Error opening file");
        return 1;
    }

    // 파일로부터 데이터를 읽어 버퍼에 저장합니다.
    // fread 함수는 읽은 데이터의 개수를 반환합니다.
    bytesRead = fread(buffer, sizeof(char), sizeof(buffer), file);

    // 파일을 닫습니다.
    fclose(file);

    // 읽은 데이터를 출력합니다.
    printf("Read %zu bytes from the binary file:\n", bytesRead);
    for (size_t i = 0; i < bytesRead; ++i) {
        printf("%02X ", buffer[i]); // 각 바이트를 16진수로 출력합니다.
    }
    printf("\n");

    return 0;
}
```

이진 데이터를 쓰는 함수 (Output functions):
/end

## fwrite 함수:

```c
size_t fwrite(const void *ptr, size_t size, size_t nobj, FILE *fp);
```

**설명:** 

fwrite 함수는 이진 데이터를 주어진 파일 스트림(FILE *fp)에 쓰기 위해 사용됩니다. ptr이 가리키는 메모리에서 size * nobj 바이트 크기만큼 데이터를 파일에 저장합니다.
**반환값:**

 성공한 경우, 쓴 객체(object)의 수를 반환하며, 오류 발생 시에는 0을 반환합니다.

```c
struct rec tmp;
struct rec item[10];

// 파일 스트림에서 이진 데이터를 읽습니다.
fread(&tmp, sizeof(struct rec), 1, fp);

// 배열에서 이진 데이터를 파일 스트림에 씁니다.
fwrite(item, sizeof(struct rec), 10, fp);
```

/end

# Formatteed I/O

"Formatted I/O"는 파일에서 데이터를 읽거나 데이터를 파일에 쓰는 C 프로그래밍 작업을 형식화된 방식으로 수행하는 것을 의미합니다. 이러한 작업을 수행하는 함수와 그들의 설명을 한국어로 제공하겠습니다.

https://haruhiism.tistory.com/30

형식화된 입력 함수 (Input functions):

## fscanf 함수:

```c
int fscanf(FILE *stream, const char *format, ...);
```

**설명:** fscanf 함수는 지정된 파일 스트림(FILE *fp)에서 형식화된 데이터를 읽어옵니다. format 문자열에 따라 파일에서 데이터를 읽고 형식에 맞게 변수에 할당합니다.

**인자:**

- **`stream`**: 파일 스트림 포인터를 가리키는 매개변수입니다. 이 스트림은 데이터를 읽어올 대상을 가리키는 역할을 합니다.
- **`format`**: 서식 문자열로, 읽고자 하는 데이터의 형식을 지정합니다.
- **`...`**: 서식 문자열에서 지정한 형식에 따라 읽은 데이터를 저장할 변수들입니다.

**반환값:** 성공한 경우, 할당된 항목(item)의 수를 반환하며, 파일의 끝(End of File, EOF) 또는 오류 발생 시에는 EOF를 반환합니다.

```c
#include <stdio.h>

int main() {
    FILE *file = fopen("data.txt", "r");
    if (file == NULL) {
        perror("File opening failed");
        return 1;
    }

    int num1, num2;

    if (fscanf(file, "%d %d", &num1, &num2) == 2) {
        printf("Read numbers: %d, %d\n", num1, num2);
    } else {
        perror("fscanf failed");
    }

    fclose(file);
    return 0;
}
```

/end

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/dfa28d76-5333-40b3-9780-fbbeab3c8ca0/28b0883b-0b63-4ec1-b967-f02f6e9548c7/Untitled.png)

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/dfa28d76-5333-40b3-9780-fbbeab3c8ca0/66259bfa-64f8-4f46-8cad-a8e7b41e0bd2/Untitled.png)

## sscanf 함수:

```c
int sscanf(const char *buf, const char *format, ...);
```

**설명:**

 sscanf 함수는 문자열(buf)에서 형식화된 데이터를 읽어옵니다. format 문자열에 따라 문자열에서 데이터를 읽고 형식에 맞게 변수에 할당합니다. **`scanf()`** 함수와 유사하지만, 입력 대상이 표준 입력(stdin)이 아니라 문자열입니다.
**반환값:**

 성공한 경우, 할당된 항목(item)의 수를 반환하며, 오류 발생 시에는 EOF를 반환합니다.

**인자:**

- **`str`**: 데이터를 추출할 문자열입니다.
- **`format`**: 서식 문자열로, 읽고자 하는 데이터의 형식을 지정합니다.
- **`...`**: 서식 문자열에서 지정한 형식에 따라 추출한 데이터를 저장할 변수들입니다.

**코드예제:**

```c
#include <stdio.h>

int main() {
    const char *data = "42 75"; // 추출할 문자열
    int num1, num2;

    if (sscanf(data, "%d %d", &num1, &num2) == 2) {
        printf("Extracted numbers: %d, %d\n", num1, num2);
    } else {
        perror("sscanf failed");
    }

    return 0;
}
/end
```

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/dfa28d76-5333-40b3-9780-fbbeab3c8ca0/585c4a4a-2d89-45e5-b515-1af18d64cad1/Untitled.png)

## fprintf 함수:

```c
int fprintf(FILE *fp, const char *format, ...);
```

**설명:** fprintf 함수는 지정된 파일 스트림(FILE *fp)에 형식화된 데이터를 쓰기 위해 사용됩니다. format 문자열에 따라 데이터를 파일에 쓰며 형식에 맞게 출력합니다.

출력하는 결과값을 파일에 쓴다
**반환값:** 성공한 경우, 쓰인 문자의 수를 반환하며, 오류 발생 시에는 음수 값(EOF)를 반환합니다.

인**자:**

- **`stream`**: 출력 대상 파일 스트림을 가리키는 매개변수입니다. 이 스트림은 데이터를 출력할 파일을 가리키는 역할을 합니다.
- **`format`**: 서식 문자열로, 출력할 데이터의 형식을 지정합니다.
- **`...`**: 서식 문자열에서 지정한 형식에 따라 출력할 데이터를 포함하는 변수들입니다.
- 

```c
#include <stdio.h>

int main() {
    FILE *file = fopen("output.txt", "w"); // "w"는 쓰기 모드로 파일 열기

    if (file == NULL) {
        perror("File opening failed");
        return 1;
    }

    int num1 = 42, num2 = 75;

    fprintf(file, "Numbers: %d and %d\n", num1, num2);

    fclose(file);
    return 0;
}
/end
```

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/dfa28d76-5333-40b3-9780-fbbeab3c8ca0/30d12f89-93bd-4fc4-8cc4-9d952ff49ba4/Untitled.png)

## sprintf 함수:

```c
int sprintf(char *buf, const char *format, ...);
```

**설명:** sprintf 함수는 문자열(buf)에 형식화된 데이터를 쓰기 위해 사용됩니다. format 문자열에 따라 데이터를 문자열에 쓰며 형식에 맞게 출력합니다.
**반환값:** 성공한 경우, 쓰인 문자의 수를 반환하며, 오류 발생 시에는 음수 값(EOF)를 반환합니다.

```c
#include <stdio.h>

int main() {
    char buffer[100];
    int num = 42;
    float pi = 3.14159;

    // 문자열 포맷팅을 사용하여 문자열 생성
    sprintf(buffer, "정수: %d, 실수: %.2f\n", num, pi);

    // 결과 문자열 출력
    printf("%s", buffer);

    return 0;
}
```

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/dfa28d76-5333-40b3-9780-fbbeab3c8ca0/af15718c-6747-47e8-b2f7-6e4517e2242d/Untitled.png)

## fseek 함수:

```c
int fseek(FILE *stream, long offset, int origin);
```

**설명:**

 fseek 함수는 지정된 파일 스트림(FILE *fp) 내에서 현재 위치를 offset만큼 이동시킵니다. whence 매개변수는 기준점을 지정하며 SEEK_SET, SEEK_CUR, SEEK_END 중 하나를 사용할 수 있습니다.
**반환값:**

 성공한 경우, 0을 반환하며, 오류 발생 시에는 0이 아닌 값을 반환합니다.

**인자:**

- **`stream`**: 파일 포인터를 나타내는 포인터입니다. **`fopen`** 함수로 파일을 열 때 반환되는 파일 포인터를 사용합니다.
- **`offset`**: 이동할 바이트 수를 나타내는 long 형 변수입니다.
- **`origin`**: 이동의 기준 위치를 나타내는 정수입니다. 가능한 값은 다음과 같습니다:
    - **`SEEK_SET`**: 파일의 시작부터 **`offset`** 바이트 떨어진 위치로 이동합니다.
    - **`SEEK_CUR`**: 현재 파일 포인터 위치에서 **`offset`** 바이트 떨어진 위치로 이동합니다.
    - **`SEEK_END`**: 파일의 끝부터 **`offset`** 바이트 떨어진 위치로 이동합니다.
    
    ```c
    #include <stdio.h>
    
    int main() {
        FILE *file = fopen("example.txt", "r");
        if (file != NULL) {
            // 파일 포인터를 파일의 시작으로 이동
            fseek(file, 0, SEEK_SET);
    
    		   
    				int c = fgetc(file);
    				putchar(c);
    				c = fgetc(file);
    				
    				// 첫 시작에서 2칸 움직임 	
    				fseek(file, 2, SEEK_SET);
    				c = fgetc(file);
    				putchar(c);
    				printf("\n");
    		        // 파일을 닫음
            fclose(file);
        } else {
            printf("파일을 열 수 없습니다.");
        }
    
        return 0;
    }
    /end
    ```
    
    ![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/dfa28d76-5333-40b3-9780-fbbeab3c8ca0/9675ac79-d160-4842-a8eb-de477aaf3d20/Untitled.png)
    

## ftell 함수:

```c
long ftell(FILE *fp);
```

**설명:**

 ftell 함수는 지정된 파일 스트림(FILE *fp) 내의 현재 파일 위치를 반환합니다. 현재 위치는 파일의 시작점으로부터의 오프셋을 나타냅니다.
**반환값:**

 성공한 경우, 현재 파일 위치를 반환하며, 오류 발생 시에는 -1L을 반환합니다.

```c
long
filesize(FILE *fp)
{
	long	size;

	fseek(fp, 0L, SEEK_END);
	size = ftell(fp);
	return(size);
}

```

이 함수는 파일의 시작부터 현재까지의 오프셋을 바이트 단위로 반환한다.

따라서 SEEK_END로 마지막으로 이동하여 오프셋을 반환하면,  파일의 첫 시작을 오프셋 0으로하기 때문에 파일의 크기를 알 수 있는 것이다.

/end

## rewind 함수:

```c
void rewind(FILE *fp);
```

**설명:**

 rewind 함수는 지정된 파일 스트림(FILE *fp) 내의 현재 위치를 파일의 시작점으로 다시 설정합니다. 이 함수를 호출하면 파일 스트림을 처음으로 되감을 수 있습니다.
**반환값:**

 반환값이 없으며, 오류 발생 시에도 반환값이 없습니다.

**`rewind`** 함수는 **`fseek(fp, 0, SEEK_SET)`**과 동일한 동작을 수행하지만, 더 나아가 파일을 읽기 또는 쓰기 전에 호출될 때 파일의 상태를 초기화하는 역할도 합니다. 만약 파일을 다시 사용하기 전에 파일의 내용을 다시 읽어야 하며 파일의 상태를 초기화하고자 한다면 **`rewind(file);`**을 사용하는 것이 좋습니다. 그러나 파일의 상태를 초기화할 필요가 없다면 **`fseek(fp, 0, SEEK_SET)`**을 사용하여 파일 포인터를 이동시키면 됩니다.

**코드 예제 생략**

/end

# 기타 파일 I/O 함수 (Miscellaneous Functions):

## ungetc 함수:

```c
int ungetc(int character, FILE *stream);
```

**설명:**

 ungetc 함수는 파일 스트림(FILE *fp)으로 문자(ch)를 되돌려보내는 역할을 합니다. 이 함수를 사용하면 이전에 읽은 문자를 버퍼로 다시 보낼 수 있습니다.

**인자:**

- **`character`**: 되돌릴 문자의 ASCII 코드 값을 나타내는 정수입니다.
- **`stream`**: 문자를 되돌릴 파일 포인터를 나타내는 포인터입니다.

**반환:**

**`ungetc`** 함수는 입력 스트림에 문자를 되돌리고 성공하면 **`character`** 값을 반환하고, 실패하면 **`EOF`**를 반환합니다.

 성공한 경우, ch를 반환하며, 오류 발생 시에는 EOF를 반환합니다.

```c
#include <stdio.h>

int main() {
    int ch;
    FILE *file = fopen("example.txt", "r");
    if (file != NULL) {
        // 문자 'A'를 입력 스트림으로 되돌림
        ungetc('A', file);

        // ungetc로 되돌린 문자를 읽음
        ch = fgetc(file);
        // 출력
        printf("문자: %c\n", ch);

		// 다시 fgetc하면 file에서 읽어옴
        ch = fgetc(file);
        printf("문자: %c\n", ch);

        fclose(file);
    } else {
        printf("파일을 열 수 없습니다.");
    }

    return 0;
}
```

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/dfa28d76-5333-40b3-9780-fbbeab3c8ca0/11907675-45d9-4826-a454-fda2e71f4d17/Untitled.png)

/end

## ferror 함수:

```c
int ferror(FILE *fp);
```

설명: ferror 함수는 파일 스트림(FILE *fp)에서 오류가 발생했는지를 확인합니다. 파일 스트림에서 오류가 발생한 경우, 이 함수는 0이 아닌 값을 반환합니다.
반환값: 파일 스트림에서 오류가 발생한 경우, 0이 아닌 값을 반환하며, 오류가 없는 경우 0을 반환합니다.

```c
#include <stdio.h>

int main() {
    FILE *file;
    char buffer[100];

    // 파일을 열고 쓰기 시도
    file = fopen("example.txt", "w");

    if (file == NULL) {
        perror("Error opening the file");
        return 1;
    }

    // 파일에 문자열 쓰기
    if (fprintf(file, "Hello, World!\n") < 0) {
        perror("Error writing to the file");
        fclose(file);
        return 1;
    }

    // 파일 스트림에서 에러 상태 확인
    if (ferror(file)) {
        perror("Error occurred during write operation");
    } else {
        printf("Write operation was successful.\n");
    }

    // 파일 스트림 닫기
    fclose(file);

    return 0;
}
```

/end

## feof 함수:

```c
int feof(FILE *fp);
```

설명: feof 함수는 파일 스트림(FILE *fp)이 파일의 끝(End of File, EOF)에 도달했는지를 확인합니다. 파일 스트림이 EOF에 도달한 경우, 이 함수는 0이 아닌 값을 반환합니다.
반환값: 파일 스트림이 EOF에 도달한 경우, 0이 아닌 값을 반환하며, 아직 EOF에 도달하지 않은 경우 0을 반환합니다.

```c
#include <stdio.h>

int main() {
    FILE *file;
    char ch;

    // 파일을 읽기 모드("r")로 열기
    file = fopen("example.txt", "r");

    // 파일 열기에 실패한 경우 에러 메시지 출력
    if (file == NULL) {
        perror("Error opening the file");
        return 1;
    }

    // 파일 끝에 도달할 때까지 문자 읽어오기
    while (!feof(file)) {
        // 파일에서 문자 하나 읽어오기
        ch = fgetc(file);

        // 파일 끝이 아닌 경우 문자 출력
        if (!feof(file)) {
            printf("%c", ch);
        }
    }

    // 파일 스트림 닫기
    fclose(file);

    return 0;
}
```

/end

## fflush 함수:

```c
int fflush(FILE *fp);
```

설명: fflush 함수는 파일 스트림(FILE *fp)의 버퍼를 비우는 역할을 합니다. 즉, 버퍼의 내용을 디스크로 쓰거나 화면에 출력합니다.
반환값: 성공한 경우, 0을 반환하며, 오류 발생 시에는 EOF를 반환합니다.

```c
#include <stdio.h>

int main() {
    FILE *file;
    char text[] = "Hello, World!\n";

    // 파일을 쓰기 모드("w")로 열기
    file = fopen("example.txt", "w");

    // 파일 열기에 실패한 경우 에러 메시지 출력
    if (file == NULL) {
        perror("Error opening the file");
        return 1;
    }

    // 버퍼에 데이터를 쓰기
    fprintf(file, "%s", text);
    printf("Data is written to the buffer, but not yet flushed to the file.\n");

    // fflush를 사용하여 버퍼의 데이터를 파일에 쓰기
    fflush(file);
    printf("Data is flushed to the file using fflush.\n");

    // 파일 스트림 닫기
    fclose(file);

    return 0;
}
```

/end

## 파일 I/O에서의 오류 처리 (Error Handling in File I/O):

1. **파일 읽기를 위한 fopen 함수 (주로 발생)**
2. 파일 쓰기를 위한 fopen 함수 (흔하지 않음)
3. **읽기 함수 (드물게 발생, EOF 확인 필요)**
4. 쓰기 함수 (흔하지 않음)
5. 파일 스트림 닫기 (fclose, 흔하지 않음)

# 

```c
#include <stdio.h>

int main(int argc, char *argv[]) {
	FILE *source = fopen(argv[1], "rb");  // "rb"는 바이너리 모드로 파일 열기
	FILE *destination = fopen(argv[2], "wb");
	
	char buffer[512];
	size_t bytes_read;
	
	while ((bytes_read = fread(buffer, 1, sizeof(buffer), source)) > 0){
	    fwrite(buffer, 1, bytes_read, destination);
	}
}
```

프로그램은 명령줄에서 원본 파일 경로와 대상 파일 경로를 받습니다.
fopen 함수를 사용하여 원본 파일을 바이너리 읽기 모드로 열고 대상 파일을 바이너리 쓰기 모드로 엽니다.
원본 파일에서 이진 데이터를 읽어 대상 파일에 쓰고, 파일을 닫고 프로그램을 종료합니다.

# File-dir

## On-Disk Structure

- **Master Boot Record**
    
    boot loader가 들어 있습니다.
    
- **Partition 1 (active)**
    
    활성 파티션. 부팅이 가능한 partition
    
    | boot block | 부팅 관련 정보 저장 |
    | --- | --- |
    | super block | file system에 관한 전체적인 정보를 저장 |
    | bitmaps |  |
    | i-nodes | 파일에 대한 정보 저장 |
    | root dir |  |
    | files&directories | 실제 파일 내용, 그 directory 내에 어떤 file들이 있는지 |
- **Partition 2**
- **Partition 3**

## In-Memory Structure

Process Table → File Table → v-node Table

Cache 3가지 (CPU와 메모리 사이 캐시가 아니고 메모리 일부를 캐시로 사용)

| In-memory Partition Table | file system의 meta data를 다루는 disk block(super block)에 대한 Cache |
| --- | --- |
| Directory Cache | data가 directory인 경우 |
| Buffer Cache | data가 file인 경우 |

## Get file status (i-node 정보들)

# stat

### 함수 설명

buf에 파일 또는 링크의 정보를 저장합니다. 정보를 성공적으로 불러왔는지 여부를 0 if OK, -1 on error으로 반환합니다.

```c
int stat(char *pathname, struct stat *buf);    //file or link
```

### **코드 예시**

```c
#include <stdio.h>
#include <sys/types.h>
#include <sys/stat.h>

main(int argc, char *argv[])
{
	struct stat	statbuf;
	char		*mode;
	int			i;

	for (i = 1 ; i < argc ; i++)  {
		printf("%s: ", argv[i]);
		if (stat(argv[i], &statbuf) < 0)  {
			perror("stat");
			continue;
		}
		if (S_ISREG(statbuf.st_mode))
			mode = "regular";
		else if (S_ISDIR(statbuf.st_mode))
			mode = "directory";
		else if (S_ISCHR(statbuf.st_mode))
			mode = "character special";
		else if (S_ISBLK(statbuf.st_mode))
			mode = "block special";
		else if (S_ISFIFO(statbuf.st_mode))
			mode = "FIFO";
		else if (S_ISLNK(statbuf.st_mode))
			mode = "symbolic link";
		else if (S_ISSOCK(statbuf.st_mode))
			mode = "socket";
		printf("%s\n", mode);
		printf("\tst_mode = %d\n", statbuf.st_mode);
		printf("\tst_ino = %d\n", statbuf.st_ino);
		printf("\tst_dev = %d\n", statbuf.st_dev);
		printf("\tst_rdev = %d\n", statbuf.st_rdev);
		printf("\tst_nlink = %d\n", statbuf.st_nlink);
		printf("\tst_uid = %d\n", statbuf.st_uid);
		printf("\tst_gid = %d\n", statbuf.st_gid);
		printf("\tst_size = %d\n", statbuf.st_size);
		printf("\tst_atime = %d\n", statbuf.st_atime);
		printf("\tst_mtime = %d\n", statbuf.st_mtime);
		printf("\tst_ctime = %d\n", statbuf.st_ctime);
		printf("\tst_blksize = %d\n", statbuf.st_blksize);
		printf("\tst_blocks = %d\n", statbuf.st_blocks);
	}
}

```

---

/end

## fstat

### 함수 설명

buf에 file에 한 정보를 저장합니다. 정보를 성공적으로 불러왔는지 여부를 0 if OK, -1 on error으로 반환합니다.

```c
int fstat(int fd, struct stat *buf);           //file stat
```

### 코시

```c
#include <stdio.h>
#include <sys/types.h>
#include <sys/stat.h>

main(int argc, char *argv[])
{
	struct stat	statbuf;
	char		*mode;
	int			i;

	for (i = 1 ; i < argc ; i++)  {
		printf("%s: ", argv[i]);
		if (fstat(argv[i], &statbuf) < 0)  {
			perror("fstat");
			continue;
		}
		if (S_ISREG(statbuf.st_mode))
			mode = "regular";
		else if (S_ISDIR(statbuf.st_mode))
			mode = "directory";
		else if (S_ISCHR(statbuf.st_mode))
			mode = "character special";
		else if (S_ISBLK(statbuf.st_mode))
			mode = "block special";
		else if (S_ISFIFO(statbuf.st_mode))
			mode = "FIFO";
		else if (S_ISLNK(statbuf.st_mode))
			mode = "symbolic link";
		else if (S_ISSOCK(statbuf.st_mode))
			mode = "socket";
		printf("%s\n", mode);
		printf("\tst_mode = %d\n", statbuf.st_mode);
		printf("\tst_ino = %d\n", statbuf.st_ino);
		printf("\tst_dev = %d\n", statbuf.st_dev);
		printf("\tst_rdev = %d\n", statbuf.st_rdev);
		printf("\tst_nlink = %d\n", statbuf.st_nlink);
		printf("\tst_uid = %d\n", statbuf.st_uid);
		printf("\tst_gid = %d\n", statbuf.st_gid);
		printf("\tst_size = %d\n", statbuf.st_size);
		printf("\tst_atime = %d\n", statbuf.st_atime);
		printf("\tst_mtime = %d\n", statbuf.st_mtime);
		printf("\tst_ctime = %d\n", statbuf.st_ctime);
		printf("\tst_blksize = %d\n", statbuf.st_blksize);
		printf("\tst_blocks = %d\n", statbuf.st_blocks);
	}
}
```

---

/endl

## lstat

### 함수 설명

buf에 file에 한 정보를 저장합니다. 정보를 성공적으로 불러왔는지 여부를 0 if OK, -1 on error으로 반환합니다.

```c
int lstat(char *pathname, struct stat *buf);   //link stat
```

### 코드 예시

```c
#include <stdio.h>
#include <sys/types.h>
#include <sys/stat.h>

main(int argc, char *argv[])
{
	struct stat	statbuf;
	char		*mode;
	int			i;

	for (i = 1 ; i < argc ; i++)  {
		printf("%s: ", argv[i]);
		if (lstat(argv[i], &statbuf) < 0)  {
			perror("lstat");
			continue;
		}
		if (S_ISREG(statbuf.st_mode))
			mode = "regular";
		else if (S_ISDIR(statbuf.st_mode))
			mode = "directory";
		else if (S_ISCHR(statbuf.st_mode))
			mode = "character special";
		else if (S_ISBLK(statbuf.st_mode))
			mode = "block special";
		else if (S_ISFIFO(statbuf.st_mode))
			mode = "FIFO";
		else if (S_ISLNK(statbuf.st_mode))
			mode = "symbolic link";
		else if (S_ISSOCK(statbuf.st_mode))
			mode = "socket";
		printf("%s\n", mode);
		printf("\tst_mode = %d\n", statbuf.st_mode);
		printf("\tst_ino = %d\n", statbuf.st_ino);
		printf("\tst_dev = %d\n", statbuf.st_dev);
		printf("\tst_rdev = %d\n", statbuf.st_rdev);
		printf("\tst_nlink = %d\n", statbuf.st_nlink);
		printf("\tst_uid = %d\n", statbuf.st_uid);
		printf("\tst_gid = %d\n", statbuf.st_gid);
		printf("\tst_size = %d\n", statbuf.st_size);
		printf("\tst_atime = %d\n", statbuf.st_atime);
		printf("\tst_mtime = %d\n", statbuf.st_mtime);
		printf("\tst_ctime = %d\n", statbuf.st_ctime);
		printf("\tst_blksize = %d\n", statbuf.st_blksize);
		printf("\tst_blocks = %d\n", statbuf.st_blocks);
	}
}
```

---

/end

## umask

### 함수 설명

```c
mode_t umask(mode_t cmask);
```

previous file mode creation mask값(정수) 반환. 파일이나 디렉터리 생성 시 초기 접근 권한을 설정할 때 사용

### 코드 예시

```c
#include <stdio.h>
#include <sys/types.h>
#include <sys/stat.h>

main()
{
	umask(0);
	if (creat("bar", S_IRUSR | S_IWUSR | S_IRGRP | S_IWGRP | 
				S_IROTH | S_IWOTH) < 0)  {
		perror("creat");
		exit(1);
	}

	umask(S_IRGRP | S_IWGRP | S_IROTH | S_IWOTH);
	if (creat("foo", S_IRUSR | S_IWUSR | S_IRGRP | S_IWGRP | 
				S_IROTH | S_IWOTH) < 0)  {
		perror("creat");
		exit(1);
	}
}
```

## The parameter, cmask

- S_ISUID, S_ISGID (유저 아이디, 그룹 아이디)
- S_IRUSR, S_IWUSR, S_IXUSR (Read/Write/Execution)
- S_IRGRP, S_IWGRP, S_IXGRP
- S_IROTH, S_IWOTH, S_IXOTH

---

/end

## chmod

### 함수 설명

파일 경로를 통해 해당 파일의 접근 권한을 수정합니다. 접근 권한이 성공적으로 수정되었는지 0 if OK, -1 on error 값을 반환합니다.

```c
int chmod(char *pathname, mode_t mode);
```

### 예시 코드

```c
#include <stdio.h>
#include <sys/types.h>
#include <sys/stat.h>

main()
{
	struct stat	statbuf;

	if (stat("bar", &statbuf) < 0)  {
		perror("stat");
		exit(1);
	}

	if (chmod("bar", (statbuf.st_mode & ~S_IWGRP) | S_ISUID) < 0)  {
		perror("chmod");
		exit(1);
	}

	if (chmod("foo", S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH) < 0)  {
		perror("chmod");
		exit(1);
	}
}
```

---

/end

## fchmod

### 함수 설명

파일 디스크립터를 통해 해당 파일의 접근 권한을 수정합니다. 접근 권한이 성공적으로 수정되었는지 0 if OK, -1 on error 값을 반환합니다.

```c
int fchmod(int fd, mode_t mode);
```

### 예시 코드

```c
##include <stdio.h>
#include <stdlib.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>

int main() {
    // 파일 디스크립터를 저장할 변수
    int fd;

    // "bar" 파일 열기 (O_RDWR로 열어야 fchmod을 사용할 수 있음)
    if ((fd = open("bar", O_RDWR)) < 0) {
        perror("open");
        exit(1);
    }

    // "bar" 파일 권한 변경
    if (fchmod(fd, (S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH)) < 0) {
        perror("fchmod");
        exit(1);
    }

    // "foo" 파일 열기 (O_RDWR로 열어야 fchmod을 사용할 수 있음)
    if ((fd = open("foo", O_RDWR)) < 0) {
        perror("open");
        exit(1);
    }

    // "foo" 파일 권한 변경
    if (fchmod(fd, (S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH)) < 0) {
        perror("fchmod");
        exit(1);
    }

    return 0;
}
```

---

/end

## chown

### 함수 설명

file 및 link의 ownership 변경하는 함수이다. 변경 성공 여부를 0 if OK, -1 on error로 반환한다.

```c
int chown(char *pathname, uid_t owner, gid_t group);
```

### 인자

uid_t owner : owner가 될 유저의 id

gid_t group: group이 될 그룹의 id

### 예시 코드

```c
#include <stdio.h>
#include <unistd.h>

int main() {
    char *filename = "example.txt";  // 변경하려는 파일 이름
    uid_t new_owner = 1000;          // 새로운 소유자 UID
    gid_t new_group = 2000;          // 새로운 그룹 GID

    if (chown(filename, new_owner, new_group) < 0) {
        perror("chown");
        return 1;  // 실패 시 종료
    }

    printf("File ownership changed successfully.\n");

    return 0;
}
```

---

/end

## fchown

### 함수 설명

file의 ownership을 변경하는 함수이다. 변경 성공 여부를 0 if OK, -1 on error로 반환한다.

```c
int fchown(int fd, uid_t owner, gid_t group);
```

### 인자

uid_t owner : owner가 될 유저의 id

gid_t group: group이 될 그룹의 id

### 예시 코드

```c
#include <stdio.h>
#include <unistd.h>

int main() {
    char *filename = "example.txt";  // 변경하려는 파일 이름
    uid_t new_owner = 1000;          // 새로운 소유자 UID
    gid_t new_group = 2000;          // 새로운 그룹 GID

    if (chown(fd, new_owner, new_group) < 0) {
        perror("chown");
        return 1;  // 실패 시 종료
    }

    printf("File ownership changed successfully.\n");

    return 0;
}
```

---

/end

## lchown

### 함수 설명

link의 ownership을 변경하는 함수이다. 변경 성공 여부를 0 if OK, -1 on error로 반환한다.

```c
int lchown(char *pathname, uid_t owner, gid_t group);
```

### 인자

uid_t owner : owner가 될 유저의 id

gid_t group: group이 될 그룹의 id

### 예시 코드

```c
#include <stdio.h>
#include <unistd.h>

int main() {
    char *filename = "example.txt";  // 변경하려는 파일 이름
    uid_t new_owner = 1000;          // 새로운 소유자 UID
    gid_t new_group = 2000;          // 새로운 그룹 GID

    if (chown(fd, new_owner, new_group) < 0) {
        perror("chown");
        return 1;  // 실패 시 종료
    }

    printf("File ownership changed successfully.\n");

    return 0;
}
```

---

/end

## link

### 함수 설명

Hard link를 생성하는 함수이다. 생성 성공 여부를 0 if OK, -1 on error로 반환한다. 

```c
int link(char *existingpath, char *newapth);
```

### Hard link

각각의 i-node가 같은 block을 가리키는 형태이다.

### 예시 코드

```c
#include <stdio.h>
#include <unistd.h>

main(int argc, char *argv[])
{
	if (argc != 3)  {
		fprintf(stderr, "Usage: %s source destinaion\n", argv[0]);
		exit(1);
	}

	if (link(argv[1], argv[2]) < 0)  {
		perror("link");
		exit(1);
	}
}
```

---

/end

## symlink

### 함수 설명

symbolic link를 생성하는 함수이다. 생성 성공 여부를 0 if OK, -1 on error로 반환한다. 

```c
int symlink(char *actualpath, char *sympath)
```

### Symbolic link

i-node가 i-node를 가리키는 형태

### 예시 코드

```c
#include <stdio.h>
#include <unistd.h>

main(int argc, char *argv[])
{
	if (argc != 3)  {
		fprintf(stderr, "Usage: %s source destinaion\n", argv[0]);
		exit(1);
	}

	if (symlink(argv[1], argv[2]) < 0)  {
		perror("link");
		exit(1);
	}
}
```

---

/end

## remove

### 함수 설명

file 및 directory를 제거할 때 사용하는 함수이다. 제거 성공 여부를 0 if OK, -1 on error로 반환한다.

```c
int remove(char *pathname);
```

### 예시 코드

```c
#include <stdio.h>
#include <stdlib.h>

int main(int argc, char *argv[]) {
                if (argc != 2)  {
                fprintf(stderr, "Usage: %s source destinaion\n", argv[0]);
                exit(1);
                }
    char *filename = argv[1];  // 삭제하려는 파일 이름

    if (remove(filename) != 0) {
        perror("remove");
        return 1;  // 삭제 실패 시 종료
    }

    printf("File '%s' removed successfully.\n", filename);

    return 0;
}
```

---

/end

## rename

### 함수 설명

이름 변경 성공 여부를  0 if OK, -1 on error로 반환한다.

```c
int rename(char *oldname, char *newname)
```

### 예시 코드

```c
#include <stdio.h>

main(int argc, char *argv[])
{
	if (argc != 3)  {
		fprintf(stderr, "Usage: %s old new\n", argv[0]);
		exit(1);
	}

	if (rename(argv[1], argv[2]) < 0)  {
		perror("rename");
		exit(1);
	}
}
```

---

/end

# mkdir

directory를 생성합니다. 생성 성공 여부를 0 if OK, -1 on error로 반환합니다.

```c
int mkdir(char /pathname, mode_t mode);
```

### 예시 코드

```c
#include <stdio.h>
#include <sys/types.h>
#include <sys/stat.h>

main(int argc, char *argv[])
{
	if (argc != 2)  {
		fprintf(stderr, "Usage: %s dirname\n", argv[0]);
		exit(1);
	}

	if (mkdir(argv[1], 0755) < 0)  {
		perror("mkdir");
		exit(1);
	}
}
```

/end

---

# rmdir

directory를 삭제합니다. 삭제 생성 성공 여부를 0 if OK, -1 on error로 반환합니다.

```c
int rmdir(char *pathname);
```

### 예시 코드

```c
#include <stdio.h>
#include <unistd.h>

main(int argc, char *argv[])
{
	if (argc != 2)  {
		fprintf(stderr, "Usage: %s dirname\n", argv[0]);
		exit(1);
	}

	if (rmdir(argv[1]) < 0)  {
		perror("rmdir");
		exit(1);
	}
}
```

/end

---

# opendir

directory를 open하고  디렉토리 스트림(**`DIR`** 구조체)을 반환합니다. 만약 open에 실패하면 NULL을 반환합니다.

```c
DIR *opendir(char *pathname); // pointer if OK, NULL on error
```

### 예시 코드

```c
#include <stdio.h>
#include <sys/types.h>
#include <dirent.h>

main()
{
	DIR				*dp;
	struct dirent	*dep;

	if ((dp = opendir(".")) == NULL)  {
		perror("opendir");
		exit(0);
	}

	while (dep = readdir(dp))  {
		printf("%s\n", dep->d_name);
	}
	
	closedir(dp);
}
```

/end

---

# readdir

디렉토리 내의 항목을 읽어 struct dirent구조체를 반환합니다. directory 끝에 도달하면  NULL Pointer return를 반환합니다.

```c
struct dirent *readdir(DIR *dp)
```

### 예시 코드

```c
#include <stdio.h>
#include <sys/types.h>
#include <dirent.h>

main()
{
	DIR				*dp;
	struct dirent	*dep;

	if ((dp = opendir(".")) == NULL)  {
		perror("opendir");
		exit(0);
	}

	while (dep = readdir(dp))  {
		printf("%s\n", dep->d_name);
	}
	
	closedir(dp);
}
```

/end

---

# chdir

Change working directory. 현재 작업 디렉토리를 open을 통해서 열려진 file descriptor가 가르키는 directory로 변환. 변경 성공 여부를 0 if OK, -1 on error로 반환한다.

```c
int chdir(char *pathname);
```

### 예시 코드

```c
#include <stdio.h>
#include <unistd.h>

main(int argc, char *argv[])
{
	if (argc != 2)  {
		fprintf(stderr, "Usage: %s dirname\n", argv[0]);
		exit(1);
	}

	if (chdir(argv[1]) < 0)  {
		perror("chdir");
		exit(1);
	}
}
```

/end

---

# fchdir

Change working directory. 현재 작업 디렉토리를 open을 통해서 열려진 file descriptor가 가르키는 directory로 변환. 변경 성공 여부를 0 if OK, -1 on error로 반환한다.

```c
int fchdir(int fd);
```

### 예시 코드

```c
#include <stdio.h>
#include <unistd.h>

main(int argc, char *argv[])
{
	if (argc != 2)  {
		fprintf(stderr, "Usage: %s dirname\n", argv[0]);
		exit(1);
	}

	if (fchdir(argv[1]) < 0)  {
		perror("chdir");
		exit(1);
	}
}
```

/end

---

# getcwd

Get current working directory. 현재 작업중인 directory의 경로를 반환한다. 성공 여부가 0(NULL)과 1로 반환됩니다.

```c
char *getcwd(char *buf, size_t size);
```

인자 명

- **`char *buf`**:현재 디렉토리 경로가 저장될 버퍼의 포인터입니다.
- **`size_t size`**: 버퍼의 크기를 나타내는 값입니다.

### 예시 코드

```c
#include <stdio.h>
#include <unistd.h>

#define	MAX_BUF	256

main(int argc, char *argv[])
{
	char	buf[MAX_BUF];

	if (getcwd(buf, MAX_BUF) == NULL)  {
		perror("getcwd");
		exit(1);
	}

	printf("%s\n", buf);
}
```

/end

---

# sync

버퍼 캐시에 있는 data들을 disk에 쓰는 함수입니다.

```c
void sync(void);
```

### 예시 코드

```c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>

int main() {
    printf("실행 전 파일 시스템 버퍼 캐시 동기화\n");
    sync(); // 파일 시스템 버퍼 캐시를 디스크로 동기화

    printf("동기화 후: 이 내용이 디스크에 반영되었습니다.\n");

    return 0;
}
```

/end

---

# fsync

버퍼 캐시에 있는 data들을 disk에 쓰는 함수입니다. 성공 여부를 0 if OK, -1 on error로 반환합니다.

```c
int fsync(int fd);
```

### 예시 코드

```c
#include <unistd.h>
#include <fcntl.h>

int main() {
    int fd = open("example.txt", O_WRONLY | O_CREAT, 0644);
    if (fd == -1) {
        return 1;
    }

    // 파일 내용을 디스크로 동기화
    fsync(fd);
    close(fd);

    return 0;
}
```

/end

# Process

## getpid 함수:

## 헤더:

```cpp
#include <sys/types.h>
#include <unistd.h>
```

## 함수 원형

```cpp
pid_t getpid(void);
```

## 설명:

getpid 함수는 현재 실행 중인 프로세스의 PID를 얻습니다. PID는 프로세스를 고유하게 식별하기 위해 사용되며, 시스템에서 프로세스 관리와 제어에 중요한 역할을 합니다.

## 반환값:

pid_t는 프로세스 ID를 나타내는 데이터 타입입니다. getpid 함수는 현재 프로세스의 PID를 반환하며, 반환값은 pid_t 타입입니다.

## 예시 코드:

```cpp
#include <stdio.h>
#include <unistd.h>

int main() {
    pid_t pid = getpid();  // 현재 프로세스의 PID를 얻음

    printf("My process ID is: %d\n", (int)pid);  // PID 출력

    return 0;
}
```

/end

# getppid 함수

### 헤더:

```cpp
#include <sys/types.h>
#include <unistd.h>
```

### 함수 원형

```cpp
pid_t getppid(void);
```

### 설명:

getppid 함수는 현재 프로세스의 부모 프로세스를 식별하기 위해 사용됩니다. 부모 프로세스는 현재 프로세스를 생성한 프로세스로, 일반적으로 부모 프로세스는 자식 프로세스의 실행을 관찰하고 제어하는 데 사용됩니다.

### 반환값:

pid_t는 프로세스 ID를 나타내는 데이터 타입입니다. getppid 함수는 현재 프로세스의 부모 프로세스 ID를 반환하며, 반환값은 pid_t 타입입니다.

### 구체적인 예시 코드

```cpp
#include <stdio.h>
#include <unistd.h>

int main() {
    pid_t parentPID = getppid();  // 현재 프로세스의 부모 프로세스 ID를 얻음

    printf("My parent's process ID is: %d\n", (int)parentPID);  // 부모 프로세스 ID 출력

    return 0;
}
```

/end

# getuid 함수:

### 헤더:

```cpp
#include <sys/types.h>
#include <unistd.h>
```

### 함수 원형

```cpp
uid_t getuid(void)
```

### 설명:

- ‘getuid’ 함수는 현재 실행 중인 프로세스의 사용자 ID를 반환합니다. 사용자 ID는 운영체제에서 사용자를 고유하게 식별하는데 사용된다.

### 반환:

- uid_t는 사용자ID를 나타내는 데이터 타입입니다, 현재 프로세스의 사용자ID반환

### 구체적인 코드 예시

```cpp
#include <stdio.h>
#include <unistd.h>

int main() {
    uid_t userID = getuid();  // 현재 프로세스의 사용자 ID를 얻음

    printf("My user ID is: %d\n", (int)userID);  // 사용자 ID 출력

    return 0;
}
```

/end

# geteuid 함수:

### 헤더:

```cpp
#include <sys/types.h>
#include <unistd.h>
```

### 함수 원형

```cpp
uid_t geteuid(void)
```

### 설명:

- geteuid함수는 현재 실행중인 프로세스의 유효한 사용자 ID를 반환합니다. 유효한 사용자 ID는 프로세스가 특정 작업 또는 자원에 액세스하는데 사용되는 사용자ID입니다.

### 반환값:

- 사용자 ID

### 구체적인 코드 예시

```jsx
#include <stdio.h>
#include <stdlib.h>
#include <fcntl.h>
#include <unistd.h>

int main() {
    int fd;
    int flags;

    // 파일을 엽니다.
    fd = open("example.txt", O_RDONLY);

    // 현재 파일 상태 플래그를 가져옵니다.
    flags = fcntl(fd, F_GETFL, 0);

    // 파일 상태 플래그에 O_NONBLOCK 비트를 추가하여 비차단 모드로 설정합니다.
    flags |= O_NONBLOCK;

    // 새로운 파일 상태 플래그를 설정합니다.
    fcntl(fd, F_SETFL, flags);
    
    // 파일을 읽습니다.
    char buffer[1024];
    ssize_t bytesRead = read(fd, buffer, sizeof(buffer));

    printf("Read %zd bytes: %.*s\n", bytesRead, (int)bytesRead, buffer);

    // 파일을 닫습니다.
    close(fd);

    return 0;
}
```

/end

# getegid 함수:

### 헤더:

```cpp
#include <sys/types.h>
#include <unistd.h>
```

### 함수 원형

```cpp
uid_t getegid(void)
```

### 설명

이 함수는 현재 실행 중인 사용자의 실제 사용자 ID(real user ID)를 반환합니다. 실제 사용자 ID는 로그인한 사용자의 ID입니다.

### 구체적 코드 예시

```cpp
#include <stdio.h>
#include <unistd.h>

int main() {
    gid_t groupID = getegid();  // 현재 프로세스의 그룹 ID를 얻음

    printf("My group ID is: %d\n", (int)groupID);  // 그룹 ID 출력

    return 0;
}
```

/end

# geteuid 함수:

### 헤더:

```cpp
#include <sys/types.h>
#include <unistd.h>
```

### 함수 원형

```cpp
uid_t getgid(void)
```

### 설명

이 함수는 현재 실행 중인 그룹의 유효 그룹ID(effective group ID)을 반환합니다.

### 구체적 코드 예시

```cpp
#include <stdio.h>
#include <unistd.h>

int main() {
    uid_t realUserID = geteuid();  // 현재 프로세스의 실제 사용자 ID를 얻음

    printf("My real user ID is: %d\n", (int)realUserID);  // 실제 사용자 ID 출력

    return 0;
}
```

/end

# fork  함수

### 헤더:

```cpp
#include <unistd.h>
```

### 함수 원형:

```cpp
pid_t fork(void);
```

### 설명:

fork 함수는 새로운 프로세스를 생성하는 시스템 호출입니다. 부모 프로세스가 fork를 호출하면 자식 프로세스가 생성됩니다. 이 자식 프로세스는 부모 프로세스의 복사본으로 시작하며, 별도의 메모리 공간을 가지며 부모 프로세스와 독립적으로 실행됩니다. fork 함수는 현재 실행 중인 프로세스를 복제하여 새로운 프로세스를 생성합니다.

### 반환값:

pid_t는 프로세스 ID를 나타내는 데이터 타입입니다. fork 함수는 부모 프로세스에서는 자식 프로세스의 PID를 반환하며, 자식 프로세스에서는 0을 반환합니다. 만약 fork 함수가 실패하면 -1을 반환합니다.

### 구체적 코드 예시:

```c
#include <stdio.h>
#include <unistd.h>

int main() {
pid_t childPID;
if ((childPID = fork())< 0) {
    // fork 실패
    perror("Fork failed");
    return 1;
} else if (childPID == 0) {
    // 이 부분은 자식 프로세스에서 실행됨
    printf("Child process: PID = %d\\n", (int)getpid());
} else {
    // 이 부분은 부모 프로세스에서 실행됨
    printf("Parent process: PID = %d, Child PID = %d\\n", (int)getpid(), (int)childPID);
}
return 0;
}
```

```c
#include <stdio.h>
#include <sys/types.h>
#include <unistd.h>

int		Var = 6;
char	Buf[] = "a write to stdout\n";

main()
{
	int		var;
	pid_t	pid;

	var = 88;
	write(STDOUT_FILENO, Buf, sizeof(Buf)-1);
// 1로 define되어 있다. 즉 printf를 쓰는코드인 것이다
	printf("Before fork\n");

	if ((pid = fork()) < 0)  {
//에러가 발생하면
// 누가 무한히 fork하면 다른 사람들이  사용하지 못한다. 
// internal   dos attack 
// 내리눅스를 써야한다.
		perror("fork");
		exit(1);
	}
	else if (pid == 0)  {
		/* child */
		Var++;
		var++;
	}
	else  {
		/* parent */
		sleep(2);
	}

	printf("pid = %d, Var = %d, var = %d\n", getpid(), Var, var);
}
```

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/dfa28d76-5333-40b3-9780-fbbeab3c8ca0/cc8872a0-8478-4b49-a88a-f6a0334800e5/Untitled.png)

/end

# exit 함수

### 헤더

```c
#include <stdlib.h>
```

### 함수 원형

```c
void exit(int status);
```

### 설명

exit 함수는 현재 실행 중인 프로세스를 종료하는 함수입니다. 이 함수를 호출하면 프로세스는 종료되고, 프로세스의 리소스가 해제됩니다. exit 함수를 호출하면 프로세스는 정상 종료하거나 특정 오류 상태에 따라 종료됩니다. 종료 코드(status)는 호출자에게 반환됩니다.

**어떤 오류나 문제 없이 종료될 때는 exit(0)**을 사용하고, **어떤 오류 또는 예외 상황에서 종료해야 할 때는 exit(1)** 또는 다른 비정상적인 종료 코드를 사용

### 반환값

- 반환값이 없다

### 구체적 코드 예시

```c
#include <stdio.h>
#include <stdlib.h>

int main() {
    printf("This is before the exit call.\n");
    
    // 프로세스 종료
    exit(0);  // 정상적인 종료
    
    // 아래의 코드는 실행되지 않음
    printf("This is after the exit call.\n");

    return 0;
}
```

# _exit 함수

### 헤더

```c
#include <unistd.h>
```

### 함수 원형:

```c
void _exit(int status);
```

### 설명:

_exit 함수는 현재 실행 중인 프로세스를 즉시 종료하는 함수입니다. 이 함수를 호출하면 프로세스가 종료되고, 모든 리소스가 즉시 해제됩니다. _exit 함수는 exit 함수와 비슷하지만, exit 함수는 표준 I/O 버퍼를 비워서 종료 작업을 마치고 파일 핸들러를 닫는 등의 추가 작업을 수행하는 반면, _exit 함수는 즉시 종료

### 구체적 코드 예시

```c
#include <stdio.h>
#include <unistd.h>

int main() {
    printf("This is before the _exit call.\n");
    
    // 프로세스를 즉시 종료
    _exit(0);  // 정상적인 종료
    
    // 아래의 코드는 실행되지 않음
    printf("This is after the _exit call.\n");

    return 0;
}
```

/end

# atexit() 함수

### 헤더:

```c
#include <stdlib.h>
```

### 함수 원형:

```c
int atexit(void (*function)(void));
```

### 설명:

atexit 함수는 프로그램이 종료될 때 특정 함수를 등록하는 함수입니다. 등록된 함수는 프로그램이 exit 함수 또는 _exit 함수를 호출하여 정상 종료되거나 비정상 종료될 때 호출됩니다. 이를 통해 프로그램 종료 전에 정리 작업을 수행하거나 자원을 해제하는 데 사용됩니다.

### 반환값:

atexit 함수는 성공할 경우 0을 반환하며, 실패할 경우 비-0 값을 반환합니다.

### 구체적 코드 예시:

```c
#include <stdio.h>
#include <stdlib.h>

// 종료될 때 호출될 함수
void cleanup() {
	printf("Cleanup function called\n");
}

int main() {
// atexit 함수를 사용하여 cleanup 함수 등록
	if (atexit(cleanup) == 0) {
		printf("Cleanup function registered\n");
	} else {
		fprintf(stderr, "Failed to register cleanup function\n");
		return 1;
	}
	printf("Program is running\\n");
	
	// 프로그램 종료
	exit(0);
	
	// 아래의 코드는 실행되지 않음
	printf("This code is not executed\\n");
	
	return 0;
}
```

이 코드에서 atexit 함수를 사용하여 cleanup 함수를 등록하고, 프로그램이 exit 함수를 호출하여 종료될 때 cleanup 함수가 호출되어 "Cleanup function called" 메시지를 출력합니다. 등록된 함수는 정상 종료 또는 비정상 종료 시 항상 호출됩니다.

```c
#include <stdio.h>
#include <stdlib.h>

void
myexit1()
{
	printf("first exit handler\n");
}

void
myexit2()
{
	printf("second exit handler\n");
}

main()
{
	if (atexit(myexit2) != 0)  {
		perror("atexit");
		exit(1);
	}

	if (atexit(myexit1) != 0)  {
		perror("atexit");
		exit(1);
	}

	if (atexit(myexit1) != 0)  {
		perror("atexit");
		exit(1);
	}

	printf("main is done\n");
}

```

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/dfa28d76-5333-40b3-9780-fbbeab3c8ca0/53aff11a-143d-44f2-8710-f2601ad03a19/Untitled.png)

⇒ STACK으로 저장

/end

# wait 함수

## 헤더:

```c
#include <sys/types.h>
#include <sys/wait.h>
```

### 함수 원형

```c
pid_t wait(int *statloc);
```

### 설명:

wait 함수는 부모 프로세스가 자식 프로세스의 종료를 기다릴 때 사용되는 함수입니다. 부모 프로세스가 wait 함수를 호출하면, 자식 프로세스가 종료할 때까지 기다리며 자식 프로세스의 종료 상태를 확인합니다. 자식 프로세스가 종료하면 해당 자식 프로세스의 프로세스 ID가 반환되며, 자식 프로세스의 종료 상태는 statloc 포인터를 통해 부모 프로세스에 전달됩니다.

### 반환값:

wait 함수는 자식 프로세스의 프로세스 ID를 반환합니다. 만약 호출에 실패하면 -1을 반환하며, 자식 프로세스가 더 이상 없을 때는 0을 반환합니다.

### 구체적인 예시:

```c
#include <stdio.h>
#include <stdlib.h>
#include <sys/types.h>
#include <sys/wait.h>
#include <unistd.h>

int main() {
pid_t childPID;
int status;
childPID = fork();

if (childPID < 0) {
    perror("Fork failed");
    return 1;
} else if (childPID == 0) {
    // 자식 프로세스에서 실행되는 코드
    printf("Child process is running\\n");
    sleep(2);
    exit(42);  // 자식 프로세스 종료
} else {
    // 부모 프로세스에서 실행되는 코드
    printf("Parent process is waiting for child (PID: %d) to finish...\\n", (int)childPID);
    wait(&status);  // 자식 프로세스가 종료할 때까지 기다림

    if (WIFEXITED(status)) {
        printf("Child process (PID: %d) exited with status: %d\\n", (int)childPID, WEXITSTATUS(status));
    }
}

return 0;
}
```

이 코드에서 부모 프로세스는 wait 함수를 사용하여 자식 프로세스의 종료를 기다립니다. 자식 프로세스는 일정 시간 동안 실행한 후 exit(42)를 사용하여 종료합니다. 부모 프로세스는 wait 함수를 통해 자식 프로세스의 종료 상태를 확인하고 출력합니다.

WIFEXITED(status): 이 매크로는 status 변수에 저장된 자식 프로세스의 종료 상태를 확인합니다. 만약 자식 프로세스가 정상적으로 종료했으면 이 매크로는 참(true)을 반환하고, 그렇지 않으면 거짓(false)을 반환합니다.

/end

# waitpid() 함수

### 헤더:

```c
#include <sys/types.h>
#include <sys/wait.h>
```

### 함수 원형:

```c
pid_t waitpid(pid_t pid, int *stat_loc, int options);
```

### 설명:

waitpid 함수는 부모 프로세스가 특정 자식 프로세스의 종료를 기다리거나 자식 프로세스 그룹 전체의 종료를 기다릴 때 사용됩니다. 이 함수는 부모 프로세스가 특정 자식 프로세스 또는 그룹의 종료 상태를 확인하고 해당 자식 프로세스를 대기시킵니다. waitpid는 보다 세밀한 제어를 허용하며, 특정 자식 프로세스를 대기시키거나 더 많은 옵션을 제공합니다.

### 반환값:

waitpid 함수는 다음과 같은 세 가지 경우에 대한 반환 값을 가집니다:
자식 프로세스의 PID가 반환되며, 자식 프로세스의 종료 상태는 stat_loc를 통해 전달됩니다.
만약 pid에 -1을 전달하면, 어떠한 자식 프로세스도 아닌 첫 번째 종료된 자식 프로세스의 PID가 반환됩니다.
만약 pid에 0을 전달하면, 현재 프로세스 그룹의 어떠한 자식 프로세스도 종료되지 않을 때까지 대기합니다. 그런 다음 종료된 자식 프로세스의 PID가 반환됩니다.
에러가 발생하면 -1이 반환되며, errno 변수에 오류 정보가 설정됩니다.

### 구체적인 예시:

```c

#include <stdio.h>
#include <stdlib.h>
#include <sys/types.h>
#include <sys/wait.h>
#include <unistd.h>

int main() {
pid_t childPID;
int status;
childPID = fork();

if (childPID < 0) {
    perror("Fork failed");
    return 1;
} else if (childPID == 0) {
    // 자식 프로세스에서 실행되는 코드
    printf("Child process is running\\n");
    sleep(2);
    exit(42);  // 자식 프로세스 종료
} else {
    // 부모 프로세스에서 실행되는 코드
    printf("Parent process is waiting for child (PID: %d) to finish...\\n", (int)childPID);
    // 특정 자식 프로세스의 종료를 기다림
    waitpid(childPID, &status, 0);

    if (WIFEXITED(status)) {
        printf("Child process (PID: %d) exited with status: %d\\n", (int)childPID, WEXITSTATUS(status));
    }
}

return 0;

```

}

위의 코드에서 waitpid 함수를 사용하여 특정 자식 프로세스(childPID)의 종료를 기다리고, 해당 자식 프로세스의 종료 상태를 확인하여 출력합니다. 부모 프로세스가 waitpid 함수를 사용하여 특정 자식 프로세스를 대기시킬 수 있습니다.

/end

# execl() 함수

### 헤더:

```c

#include <unistd.h>
```

### 함수 원형:

```c
int execl(const char *path, const char *arg0, ... /* (char *) NULL */);
```

### 설명:

execl 함수는 새로운 프로그램을 실행하고 현재 프로세스의 이미지를 새로운 프로그램 이미지로 대체합니다. 이 함수는 가변 개수의 문자열 인수를 받아 프로그램에 전달합니다.

### 반환값:

execl 함수는 호출에 실패하면 -1을 반환하며, 새로운 프로그램의 실행이 성공하면 해당 함수는 현재 프로세스의 이미지를 변경하고 반환되지 않습니다.

### 구체적인 예시:

```c
#include <stdio.h>
#include <unistd.h>

int main() {
	printf("Executing ls -l using execl...\n");
	if (execl("/bin/ls", "ls", "-l", NULL) == -1) {
	    perror("execl");
	    return 1;  // 실패 시 프로그램 종료
	}
	
	// 아래 코드는 실행되지 않음
	printf("This line is not reached\\n");
	
	return 0;
}

```

/end

# execv 함수

### 헤더:

```c
#include <unistd.h>
```

### 함수 원형:

```c
int execv(const char *path, char *const argv[]);
```

### 설명:

execv 함수는 execl과 유사하게 동작하지만 명령행 인수들을 문자열 배열로 전달합니다. argv 배열에는 실행할 프로그램과 그 인수들이 포함됩니다.

### 반환값:

execv 함수는 호출에 실패하면 -1을 반환하며, 새로운 프로그램의 실행이 성공하면 해당 함수는 현재 프로세스의 이미지를 변경하고 반환되지 않습니다.

### 구체적인 예시:

```c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>

int main() {
	char *command = "/bin/ls";  // 실행할 프로그램 경로
	char *args[] = {"/bin/ls", "-l", NULL};  // 프로그램에 전달할 명령행 인수 배열
	printf("Executing ls -l using execv...\\n");
	
	if (execv(command, args) == -1) {
	    perror("execv");
	    return 1;  // 실패 시 프로그램 종료
	}
	
	// 아래 코드는 실행되지 않음
	printf("This line is not reached\\n");
	
	return 0;
}
```

/end

# execle 함수

### 헤더:

```c
#include <unistd.h>
```

### 함수 원형:

```c
int execle(const char *path, const char *arg0, ... /* (char *) NULL, char *const envp[] */);
```

### 설명:

execle 함수는 execl과 유사하며, 환경 변수(envp)를 명시적으로 전달할 수 있는 점이 다릅니다. 환경 변수는 새로운 프로그램에서 사용할 환경 설정을 제어할 때 유용합니다.

### 반환값:

execle 함수는 호출에 실패하면 -1을 반환하며, 새로운 프로그램의 실행이 성공하면 해당 함수는 현재 프로세스의 이미지를 변경하고 반환되지 않습니다.

### 구체적인 예시:

```c
#include <stdio.h>
#include <unistd.h>

int main() {
printf("Executing printenv using execle...\n");
char *args[] = {"/usr/bin/printenv", NULL};
char *envp[] = {"PATH=/bin:/usr/bin", "USER=John", NULL};

if (execle("/usr/bin/printenv", "printenv", NULL, envp) == -1) {
    perror("execle");
    return 1;  // 실패 시 프로그램 종료
}

// 아래 코드는 실행되지 않음
printf("This line is not reached\\n");

return 0;
}
```

/end

# execve 함수

### 헤더:

```c
#include <unistd.h>
```

### 함수 원형:

```c
int execve(const char *path, char *const argv[], char *const envp[]);
```

### 설명:

execve 함수는 execv와 유사하지만 환경 변수(envp)를 명시적으로 전달할 수 있는 점이 다릅니다. 이 함수를 사용하면 실행 중인 프로세스의 환경을 완전히 제어할 수 있습니다.

### 반환값:

execve 함수는 호출에 실패하면 -1을 반환하며, 새로운 프로그램의 실행이 성공하면 해당 함수는 현재 프로세스의 이미지를 변경하고 반환되지 않습니다.

### 구체적인 예시:

```c
#include <stdio.h>
#include <unistd.h>

int main() {
	printf("Executing printenv using execve...\n");
	char *args[] = {"/usr/bin/printenv", NULL};
	char *envp[] = {"PATH=/bin:/usr/bin", "USER=John", NULL};

if (execve("/usr/bin/printenv", args, envp) == -1) {
    perror("execve");
    return 1;  // 실패 시 프로그램 종료
}

	// 아래 코드는 실행되지 않음
	printf("This line is not reached\\n");
	
	return 0;
}
```

각 함수는 실행 중인 프로세스의 이미지를 새로운 프로그램 이미지로 대체하며, 각각 다양한 방식으로 명령행 인수와 환경 변수를 전달할 수 있습니다.

/end

# execlp 함수

### 헤더:

```c
#include <unistd.h>
```

### 함수 원형:

```c
int execlp(const char *file, const char *arg0, ...);
```

file은 실행할 프로그램의 이름만 지정

→ ls만을 지정하면, 함수는 시스템의 PATH 환경 변수에서 해당 프로그램을 찾아 실행합니다.

### 설명:

execlp 함수는 새로운 프로그램을 실행하고, 파일 검색 경로(PATH 환경 변수)를 통해 실행할 프로그램을 찾습니다. 이 함수는 가변 개수의 문자열 매개변수를 받아 실행할 프로그램과 그 프로그램에 전달할 명령행 인수를 지정합니다. arg0은 실행될 프로그램의 이름을 지정하며, 나머지 매개변수는 명령행 인수를 나타냅니다.

### 반환:

함수가 성공하면 실행된 프로세스는 현재 프로세스 이미지로 대체되므로 함수가 성공적으로 반환되지 않습니다.
함수가 실패하면 -1을 반환하며, 오류가 발생한 경우 errno 변수에 오류 코드가 설정됩니다.

### 구체적 예시

```c

#include <stdio.h>
#include <unistd.h>

int main() {
	printf("Executing 'ls' using execlp...\n");
	if (execlp("ls", "ls", "-l", NULL) == -1) {
	    perror("execlp");
	    return 1;  // 실패 시 프로그램 종료
	}
	
	// 아래 코드는 실행되지 않음
	printf("This line is not reached.\\n");
	
	return 0;
}
```

/end

# execvp 함수

### 헤더:

```c
#include <unistd.h>
```

### 함수 원형:

```c
int execvp(const char *file, char *const argv[]);
```

### 설명:

execvp 함수는 execlp와 유사하지만, 실행할 프로그램과 명령행 인수가 배열로 전달됩니다. file은 실행될 프로그램의 경로를 나타내며, argv는 실행될 프로그램에 전달할 명령행 인수를 담은 배열입니다. 파일 검색 경로(PATH 환경 변수)를 통해 실행할 프로그램을 찾습니다.

### 반환:

함수가 성공하면 실행된 프로세스는 현재 프로세스 이미지로 대체되므로 함수가 성공적으로 반환되지 않습니다.
함수가 실패하면 -1을 반환하며, 오류가 발생한 경우 errno 변수에 오류 코드가 설정됩니다.

### 구체적 예시:

```c
#include <stdio.h>
#include <unistd.h>

int main() {
	printf("Executing 'ls' using execvp...\n");
	char *args[] = {"ls", "-l", NULL};
	if (execvp("ls", args) == -1) {
	    perror("execvp");
	    return 1;  // 실패 시 프로그램 종료
	}
	
	// 아래 코드는 실행되지 않음
	printf("This line is not reached.\\n");
	
	return 0;
}
```

/end

# system 함수

### 헤더:

```c
#include <stdlib.h>
```

### 함수 원형:

```c
int system(const char *command);
```

### 설명:

system 함수는 명령어 문자열 command를 실행합니다. 이 함수는 명령어를 실행하기 위해 셸을 호출하고, 명령어 문자열을 셸로 전달하여 실행합니다. 실행된 명령어는 셸에서 실행되므로 셸에서 사용 가능한 모든 기능과 명령어를 사용할 수 있습니다.

### 반환:

명령어가 성공적으로 실행되면, 셸에서 반환한 상태 코드가 반환됩니다.
명령어 실행이 실패하거나 오류가 발생하면 -1이 반환됩니다.

### 구체적 예시:

```c
#include <stdio.h>
#include <stdlib.h>

int main() {
int status;
printf("Executing 'ls -l' using system...\n");
// system 함수를 사용하여 'ls -l' 명령어 실행
status = system("ls -l");

// 시스템 명령어 실행 결과를 확인
if (WIFEXITED(status)) {
    int exit_status = WEXITSTATUS(status);
    printf("Command exited with status: %d\\n", exit_status);
} else {
    printf("Command execution failed.\\n");
}

return 0;
}
```

}

위의 예시에서, system 함수를 사용하여 "ls -l" 명령어를 실행하고, 실행 결과를 확인합니다. 함수는 시스템 명령어 실행 후 반환한 상태 코드를 반환하며, WIFEXITED 매크로를 사용하여 명령어가 정상 종료되었는지 확인합니다.

### 구체적 코드 예시

```c
#include <stdio.h>
#include <stdlib.h>

main()
{
	int		status;

// 'date'라는 shell command를 실행한다.
	if ((status = system("date")) < 0)  { 
// system()은 command의 종료 상태를 반환한다.
		perror("system"); 
// 에러가 발생한 경우에는 -1을 반환한다.
		exit(1);
	}
	printf("exit status = %d\n", status); 
// 'date' command의 종료 상태를 출력한다.

// 'nosuchcommand'라는 존재하지 않는 shell command를 실행하려고 한다. 
	if ((status = system("nosuchcommand")) < 0)  { 
		perror("system");
		exit(1);
	}
	printf("exit status = %d\n", status); 
// 실패한 경우, 종료 상태 코드가 non-zero일 것이다.

 // 두 개의 shell commands('who', 'exit 44')를 순차적으로 실행한다.
 // ';' 문자열은 여러 commands를 한 줄에 작성할 수 있게 해준다.
	if ((status = system("who; exit 44")) < 0)  {
		perror("system");
		exit(1);
	}
	printf("exit status = %d\n", status); 
//'exit 44' command 때문에 종료 상태 코드가 44일 것이다.
}
```

/end

# env 함수

### 설명:

extern char **environ는 전역 변수로서, 시스템 환경 변수 정보를 저장하고 있는 변수입니다. extern char **environ를 선언하면 해당 변수는 이미 시스템에서 환경 변수 정보를 저장하고 있습니다. 이 변수는 일반적으로 시스템 라이브러리에 의해 초기화되며, main 함수 내에서 선언만 해도 환경 변수 정보에 액세스할 수 있습니다.

일반적으로, 환경 변수는 char *envp[]와 같은 형태의 인수로 main 함수에 전달됩니다. 하지만 environ은 C 언어 표준이 아니며, 특정 시스템 또는 컴파일러에 종속적인 확장 기능입니다. 이 변수는 시스템 라이브러리에서 관리되며, 주로 시스템 환경 변수를 읽고 수정하는 데 사용됩니다.

environ 변수를 사용하면 시스템 환경 변수에 직접 접근할 수 있어, 특정 환경 변수의 값을 확인하거나 변경할 때 유용할 수 있습니다. 하지만 이것은 표준 C 라이브러리의 일부가 아니며, 이식성 문제가 있을 수 있으므로 주의가 필요합니다.

### 구체적 코드 예시

```c
#include <stdio.h>

main(int argc, char *argv[], char *envp[])
{
	int			i;
	char		**p;
	extern char	**environ;

	printf("List command-line arguments\n");
	for (i = 0 ; i < argc ; i++)  {
		printf("%s\n", argv[i]);
	}

	printf("\n");
	printf("List environment variables from environ variable\n");
	for (p = environ ; *p != NULL ; p++)  {
		printf("%s\n", *p);
	}

	printf("\n");
	printf("List environment variables from envp variable\n");
	for (p = envp ; *p != NULL ; p++)  {
		printf("%s\n", *p);
	}
}
```

차이점은 envp는 main 함수의 인수로 전달되고 사용자가 직접 활용할 수 있으며, environ은 시스템 라이브러리에 의해 관리되는 변수로 사용자가 extern 선언을 통해 환경 변수에 액세스할 수 있습니다.

/end

# pthread_create함수

### 헤더:

```c
#include <pthread.h>
```

### 함수 원형:

```c
int pthread_create(
	pthread_t *thread, 
	const pthread_attr_t *attr, 
	void *(*start_routine) (void *), 
	void *arg
);
```

### 설명:

pthread_create 함수는 새로운 스레드를 생성하고 시작하는 함수입니다. 이 함수를 호출하면 새로운 스레드가 생성되며, 해당 스레드가 수행할 함수 및 인수를 지정할 수 있습니다.

thread: 새로 생성된 스레드의 식별자를 저장할 포인터 변수입니다.
attr: 스레드의 특성을 지정하는 데 사용되는 스레드 특성 객체의 포인터입니다. 일반적으로 NULL을 사용하여 기본 특성을 사용합니다.
start_routine: 새로 생성된 스레드가 실행할 함수의 포인터입니다. 이 함수는 void *를 받아서 void *를 반환해야 합니다.
arg: start_routine 함수에 전달할 인수로, void * 형식의 포인터 변수입니다.

pthread_create 함수를 호출하면 새로운 스레드가 생성되고 지정한 함수 (start_routine)가 실행됩니다. start_routine 함수는 arg를 인수로 받아서 작업을 수행하고, 작업이 완료되면 스레드는 종료됩니다.

### 반환:

함수 호출에 성공하면 0을 반환합니다.
실패하면 오류 코드를 반환하며, 오류가 발생한 경우에는 새로운 스레드가 생성되지 않습니다.

### 구체적 예시:

```c
#include <stdio.h>
#include <pthread.h>

void
PrintMsg(char *msg)
{
	printf("%s", msg);

	pthread_exit(NULL);
}

main()
{
	pthread_t	tid1, tid2;
	char		*msg1 = "Hello, ";
	char		*msg2 = "World!\n";

//printmsg하는 함수를 만들어라, msg 하나만 넣어라. 순서대로 실행하면 hello world
	if (pthread_create(&tid1, NULL, (void *)PrintMsg, (void *)msg1) < 0)  {
		perror("pthread_create");
		exit(1);
	}

	if (pthread_create(&tid2, NULL, (void *)PrintMsg, (void *)msg2) < 0)  {
		perror("pthread_create");
		exit(1);
	}

	printf("Threads created: tid=%d, %d\n", tid1, tid2);
	
	if (pthread_join(tid1, NULL) < 0)  {
		perror("pthread_join");
		exit(1);
	}
	if (pthread_join(tid2, NULL) < 0)  {
		perror("pthread_join");
		exit(1);
	}

	printf("Threads terminated: tid=%d, %d\n", tid1, tid2);
}
```

/end

# pthread_exit 함수:

### 헤더:

```c
#include <pthread.h>
```

### 함수 원형:

```c
void pthread_exit(void *value_ptr);
```

### 설명:

pthread_exit 함수는 현재 스레드를 종료하고 반환 값을 지정합니다. 이 함수를 호출하면 현재 스레드는 종료되며, value_ptr로 지정한 값을 반환합니다. 이 값은 다른 스레드에서 pthread_join 함수를 사용하여 검색할 수 있습니다.

value_ptr: 현재 스레드의 반환 값을 지정하는 포인터입니다. 반환 값은 void * 형식이며, 원하는 데이터 형식으로 형변환하여 지정할 수 있습니다.

/end

# pthread_join 함수:

### 헤더:

```c
#include <pthread.h>
```

### 함수 원형:

```c
int pthread_join(pthread_t thread, void **value_ptr);
```

### 설명:

pthread_join 함수는 특정 스레드가 종료될 때까지 대기하고, 그 스레드의 반환 값을 검색하는 함수입니다. 주로 부모 스레드가 자식 스레드의 종료와 반환 값을 기다릴 때 사용됩니다.

thread: 대기할 스레드의 식별자입니다.
value_ptr: 스레드의 반환 값을 저장할 포인터입니다. 스레드가 종료될 때 반환한 값은 이 포인터를 통해 검색됩니다.

### 반환:

함수 호출에 성공하면 0을 반환합니다.
실패하면 오류 코드를 반환합니다.

### 구체적 예시:

```c
#include <pthread.h>
#include <stdio.h>

void *thread_function(void *arg) {
	int thread_arg = *((int *)arg);
	int result = thread_arg * 2;
	// 스레드 종료하며 반환 값 설정
	pthread_exit((void *)&result);
}

int main() {
	pthread_t thread_id;
	int arg = 5;
	int *result;
	
	// 스레드 생성
	if (pthread_create(&thread_id, NULL, thread_function, &arg) != 0) {
	    perror("pthread_create");
	    return 1;
	}
	
	// 부모 스레드에서도 일부 작업 수행 가능
	printf("Parent thread is running.\\n");
	
	// 스레드가 종료될 때까지 대기하고 반환 값을 검색
	if (pthread_join(thread_id, (void **)&result) != 0) {
	    perror("pthread_join");
	    return 1;
	}
	
	printf("Child thread returned: %d\\n", *result);
	
	return 0;
}
```

이 예시에서는 pthread_exit를 사용하여 스레드를 종료하면서 반환 값을 설정하고, pthread_join를 사용하여 부모 스레드에서 해당 반환 값을 검색합니다.

/end

# C 문자열 정리

# strcpy

### 설명:

origin에 있는 문자열을 dest로 복사하는 함수

### 헤더:

```c
<string.h>
```

### 형태:

char *strcpy(char* dest, const char *origin)인수:*

*char* dest: 복사한 값을 넣을 문자열

const char* origin: 복사할 문자열반환값: 복사된 문자열에 대한 포인터

### 주의할 점:

널문자(\0)가 있는 곳을 문자열의 끝으로 판단하고, **널문자가 나올 때까지 복사**한다.

> char dest[10]에 "hello" 복사 가능
> 
> 
> char dest[10]에 "hi im fine thank you" (22글자) 복사 불가능 (런타임 에러)
> 

### 구현:

```c
char	*replica_strcpy(char *dest, char *src)
{
	int	idx;

	idx = 0;
	while (src[idx] != '\0')
	{
		dest[idx] = src[idx];
		idx++;
	}
	dest[idx] = '\0';
	return (dest);
}

```

> dest에 널포인터가 들어오면 프로그램이 죽는다.
> 
> 
> 0번지 다음에는 heap에 code section이 있는데, 이를 침범하게 되기 때문에 segment fault가 발생한다.
> 
> 참조할 수 없는 영역이기 때문에 MMU에서 Memory Protection Fault 오류로 차단하는 것이다.
> 

/end

# strncpy

### 설명:

origin에 있는 문자열을 dest로 복사를 하는데, n 만큼만 복사하는 함수

### 헤더:

```c
#include <string.h>
```

### 형태:

char *strncpy(char* dest, const char *origin, size_t len)*

### *반환값:*

*복사된 문자열에 대한 포인터인수:char* dest: 복사한 값을 넣을 문자열const char* origin: 복사할 문자열size_t len: 복사할 길이

### 주의할 점:

strncpy는 '\0'를 상관하지 않고 n의 길이만큼만 복사

> dest2[100];
> 
> 
> char origin[] = hi im fine thank you"; (22글자)
> 
> strncpy(dest2, origin, 4)
> 
> 결과: "hi i" (\0 없이 복사 -> 문자열의 끝이 지정돼있지 않으므로 **4번 인덱스부터 99번 인덱스에는 쓰레기값 저장**)
> 

### 구현

```c
char	*replica_strncpy(char *dest, char *src, unsigned int n)
{
	unsigned int		idx;

	idx = 0;
	while (*(src + idx) && idx < n)
	{
		*(dest + idx) = *(src + idx);
		++idx;
	}
	while (idx < n)
	{
		*(dest + idx) = '\0';
		++idx;
	}
	return (dest);
}

```

/end

# strlcpy

설명: strncpy와 유사하게 작동하지만, strncpy와 달리 항상 뒤에 널문자를 삽입한다.

헤더: <string.h>

형태: size_t strlcpy(char *dest, const char* origin, size_t dstsize)

반환값: 함수가 생성한 문자열의 총 길이

인수:

char *dest: 복사한 값을 넣을 문자열const char* origin: 복사할 문자열size_t len: 복사할 길이

> strncpy VS strlcpy
> 
> 
> **strncpy()**
> 
> strncpy(str, "123456", 100);
> 
> >123456\0
> 
> strncpy(str, "123456", 4);
> 
> > 1234
> 
> **strlcpy()**
> 
> strlcpy(str, "123456", 100);
> 
> 123456\0
> 
> strlcpy(str, "123456", 4);
> 
> 123\0
> 
> 이렇듯 **strncpy**는 널문자와 관계없이 **항상 지정 인덱스**까지 무조건 같게 만들고
> 
> **strlcpy**는 마지막 인덱스는 항상 널문자로 지정하여 저장하기 때문에 **origin의 길이가 len보다 짧다면 len - 1만큼 저장**하고 **마지막은 널문자**로 저장한다.
> 

구현

```
unsigned	int	replica_strlcpy(char *dest, char *src, unsigned int size)
{
	unsigned int	idx;
	unsigned int	len_src;

	idx = 0;
	len_src = 0;
	while (*(src + len_src))
		++len_src;
	while (*(src + idx) && idx < size - 1 && size != 0)
	{
		*(dest + idx) = *(src + idx);
		++idx;
	}
	if (size > 0)
		*(dest + idx) = '\0';
	return (len_src);
}

```

/end

# strcmp

설명:

두 문자열이 같은지 판단하는 함수다.

두 문자열이 같으면 0 다르면 양수 혹은 음수를 반환한다.

앞에서부터 하나씩 비교하다가 다른 문자열이 나오면 앞 문자에서 뒤 문자의 차이값을 반환한다.

따라서 앞 문자가 더 크면 양수를 작으면 음수를 반환한다.

Ex)

strcmp(“ABC”, “ABC”) = 0

strcmp(“ABF”,”ABC”) > 0

strcmp(“AB”, “ABC”) < 0

헤더: <string.h>

형태: char *strcmp( const char* s1, const char * s2 )

구현

```
int	replica_strcmp(char *s1, char *s2)
{
	int	idx;

	idx = 0;
	while ((s1[idx] != '\0') && (s2[idx] != '\0') && (s1[idx] == s2[idx]))
		idx ++;
	return (s1[idx] - s2[idx]);
}
```

/end

# strncmp

설명:

strcmp와 유사하게 동작하지만, n번째까지만 비교한다

반환값은 strcmp와 동일하게 두 문자열이 같으면 0 다르면 양수 혹은 음수를 반환한다.

Ex)

strcmp(“ABC”, “AB”, 2) = 0

strcmp(“ABF”,”AB”, 3) > 0

헤더: <string.h>

형태: char *strncmp( const char* s1, const char * s2, size_t n )

구현

```
int	replica_strncmp(char *s1, char *s2, unsigned int n)
{
	unsigned int	idx;

	if (n == 0)
		return (0);
	idx = 0;
	while (s1[idx] != '\0' && s2[idx] != '\0' && s1[idx] == s2[idx] && idx < n)
		idx++;
	if (idx == n)
		return (s1[n - 1] - s2[n - 1]);
	else
		return (s1[idx] - s2[idx]);
}
```

/end

# strcat

설명:origin에 있는 문자열을 dest 뒤쪽에 이어 붙이는 함수, dest 문자열 끝의 널문자는 삭제되고 그 위치에 origin이 붙는다.

ex)

char origin[] = "aaa";

char dest[20] = "bbb";

strcat(dest, origin);

printf("%s",dest) > aaabbb

형태: char *strcat(char* dest, const char *src);인수:char* dest: src를 붙일 대상 문자열char* src: dest 뒤에 붙여질 문자열

구현

```
char	*replica_strcat(char *dest, char *src)
{
	int	si;
	int	di;

	di = 0;
	while (dest[di] != '\0')
		di++;
	si = 0;
	while (src[si] != 0)
		dest[di++] = src[si++];
	dest[di] = '\0';
	return (dest);
}
```

/end

# strncat

구현

```
char	*replica_strncat(char *dest, char *src, unsigned int nb)
{
	unsigned int	di;
	unsigned int	si;

	di = 0;
	si = 0;
	while (dest[di] != '\0')
		di++;
	while (si < nb && src[si] != '\0')
		dest[di++] = src[si++];
	dest[di] = '\0';
	return (dest);
}
```

/end

# strlcat

구현

```
int	len_arr(char *str)
{
	int	i;

	i = 0;
	while (str[i])
		i++;
	return (i);
}

unsigned int	replica_strlcat(char *dest, char *src, unsigned int size)
{
	unsigned int	idx1;
	unsigned int	idx2;
	unsigned int	len_dest;
	unsigned int	len_src;

	if (src[0] == '\0')
		return (0);
	idx1 = len_arr(dest);
	idx2 = 0;
	len_dest = len_arr(dest);
	len_src = len_arr(src);
	if (len_dest > size)
		return (size + len_src);
	while ((idx1 + 1 < size) && (src[idx2] != '\0'))
		dest[idx1++] = src[idx2++];
	dest[idx1] = '\0';
	return (len_src + len_dest);
}
```

/end

# strstr

설명:

str안에서 to_find가 있는지 판단하고, 만약 있다면 그 위치에 해당하는 포인터를 반환하며, 없다면 널포인터를 반환한다.

구현

```
char	*ft_strstr(char *str, char *to_find)
{
	int	idx1;
	int	idx2;

	idx1 = 0;
	idx2 = 0;
	if (*to_find == '\0')
		return (str);
	while (str[idx1] != '\0')
	{
		if (str[idx1] == to_find[idx2])
		{
			if (to_find[++idx2] == '\0')
				return (&str[idx1] - (idx2 - 1));
		}
		else
			idx2 = 0;
		idx1++;
	}
	return (0);
}
```

/end

# strdup

설명: strcpy는 단순히 문자열만 복사하지만, strdup은 추가적으로 메모리를 할당해준다.

헤더: <string.h>

형태: char *strdup(const char* string)

반환값: 복사된 데이터의 주소 (에러 발생시 null반환)

인수:

데이터를 복사할 주소, const *char형

**strcpy가 있는데 strdup이 필요한 이유**

strcpy는 복사된 배열을 스택에 저장한다. 반면, strdup은 힙에 메모리를 새로 할당하여 저장한다.

main 함수에 직접 사용하거나 함수내에서도 반환할 필요가 없는 경우에는 큰 차이가 없다.

하지만 함수내에서 반환할 필요가 있을 때 strcpy를 사용하여 복사된 배열을 반환하려고 하면 에러가 발생한다.

이 때 복사된 배열은 스택에 저장되었기 때문에 함수가 끝나면 소멸되기 때문이다.

따라서 이런 경우에는 strdup을 이용하여 복사해야한다.

또 사용자는 strdup이 malloc 함수 **호출로 메모리를 할당하기 때문에 반환 된 char 포인터를 해제해야한다**.

구현

```
#include <stdlib.h>

char	*ft_strdup(char *src)
{
	char	*str;
	int 	size;
	int		i;

	size = 0;
	i = 0;
	while (!(src + size))
		size++;
	str = (char *)malloc(size);
	while (src[i])
	{
		str[i] = src[i];
		++i;
	}
	return (str);
}
```

/end

## init_arr

char 배열을 길이만큼 받아서 0으로 초기화한다.

```c
#include <stdio.h>
void init_arr(char* arr, int len)
{
	for (int i = 0; i < len; i++) arr[i] = 0;
}

int main(int argc, char **argv)
{
	char str[] = "hello";
	init_arr(str, 5);
	printf("%s", str);
}
```

/end

# atoi

**`atoi`** 함수는 문자열을 정수로 변환하는 C 표준 라이브러리 함수입니다. 함수 이름 "atoi"는 "ASCII to Integer"의 약어입니다.

함수의 프로토타입은 다음과 같습니다:

```c
cCopy code
int atoi(const char *str);

```

인자설명:

- **`str`**: 정수로 변환하려는 문자열입니다.

반환값:

 해당 문자열이 표현하는 정수 값을 반환

/end

## struct sorting

```c
#include <stdio.h>
#include <stdlib.h>
#include <sys/stat.h>

// 비교 함수
int compare(const void *a, const void *b) {
    return ((struct stat *)a)->st_size - ((struct stat *)b)->st_size;
}

int main() {
    // stat 구조체 배열 생성 및 초기화
    struct stat files[] = {
        { .st_size = 100 },
        { .st_size = 50 },
        { .st_size = 200 },
        // 여러 다른 파일 정보들...
    };
    
    int num_files = sizeof(files) / sizeof(files[0]);
    
    // st_size를 기준으로 정렬
    qsort(files, num_files, sizeof(struct stat), compare);
    
    // 정렬된 결과 출력
    printf("정렬된 파일 크기:\n");
    for (int i = 0; i < num_files; i++) {
        printf("파일 %d: %lld bytes\n", i + 1, (long long)files[i].st_size);
    }
    
    return 0;
}
```

/end

## bubble sort

```c
#include <stdio.h>

void bubbleSort(int arr[], int n) {
    for (int i = 0; i < n - 1; i++) {
        for (int j = 0; j < n - i - 1; j++) {
            // 현재 원소가 다음 원소보다 크다면 교환
            if (arr[j] > arr[j + 1]) {
                // 두 원소를 교환
                int temp = arr[j];
                arr[j] = arr[j + 1];
                arr[j + 1] = temp;
            }
        }
    }
}

int main() {
    int arr[] = {64, 34, 25, 12, 22, 11, 90};
    int n = sizeof(arr) / sizeof(arr[0]);
    printf("정렬 전 배열: ");
    for (int i = 0; i < n; i++) {
        printf("%d ", arr[i]);
    }
    printf("\n");

    bubbleSort(arr, n);

    printf("버블 정렬 후 배열: ");
    for (int i = 0; i < n; i++) {
        printf("%d ", arr[i]);
    }
    printf("\n");

    return 0;
}
```

/end

# qsort

**`qsort`** 함수는 배열을 정렬하는 함수로, 사용자가 제공한 비교 함수를 사용하여 정렬을 수행합니다.

**`qsort`** 함수의 프로토타입은 다음과 같습니다:

```c
cCopy code
void qsort(void *base, size_t nmemb, size_t size, int (*compar)(const void *, const void *));

```

- **`base`**: 정렬할 배열의 포인터입니다.
- **`nmemb`**: 배열의 요소 수입니다.
- **`size`**: 각 요소의 크기(바이트)입니다.
- **`compar`**: 비교 함수의 포인터입니다. 이 함수는 두 요소를 비교하여 정렬 순서를 결정합니다.

**`qsort`** 함수는 정렬된 배열을 원래의 배열에 덮어쓰기 때문에 원본 배열을 변경시킵니다. 따라서 원본 배열을 보존해야 하는 경우 정렬하기 전에 배열을 복사해두어야 합니다.

예를 들어, 정수 배열을 정렬하는 **`qsort`**의 사용 예제는 다음과 같습니다:

```c
cCopy code
#include <stdio.h>#include <stdlib.h>// 비교 함수
int compare(const void *a, const void *b) {
    return (*(int *)a - *(int *)b);
}

int main() {
    int numbers[] = {5, 2, 9, 1, 5, 6};
    int size = sizeof(numbers) / sizeof(numbers[0]);

    // 배열 정렬
    qsort(numbers, size, sizeof(int), compare);

    // 정렬된 배열 출력
    printf("Sorted array: ");
    for (int i = 0; i < size; ++i) {
        printf("%d ", numbers[i]);
    }
    printf("\n");

    return 0;
}

```

이 예제에서는 정수 배열을 정렬하는 비교 함수 **`compare`**를 정의하고, 이를 **`qsort`** 함수로 전달하여 배열을 정렬합니다. 결과적으로 정렬된 배열이 출력됩니다.

/end

# min

c에는 min과 max가 없어서 직접 정의 해야한다.

```c
int min(int a, int b) {
	return (a < b) ? a : b;
}
```

```c
#include <stdio.h>

int findMin(int arr[], int size) {
    if (size <= 0) {
        return -1; // 배열이 비어있을 때 오류 표시 (-1 또는 다른 오류 코드)
    }

    int min = arr[0]; // 초기값으로 배열의 첫 번째 요소 설정

    for (int i = 1; i < size; i++) {
        if (arr[i] < min) {
            min = arr[i];
        }
    }

    return min;
}

int main() {
    int numbers[] = {12, 5, 8, 21, 3, 17};
    int size = sizeof(numbers) / sizeof(numbers[0]);

    int minimum = findMin(numbers, size);
    printf("Minimum: %d\n", minimum);

    return 0;
}
```

/end

# max

c에는 min과 max가 없어서 직접 정의 해야한다.

```c
int max(int a, int b) {
   return (a > b) ? a : b;
}
```

```c
int findMax(int arr[], int size) {
    if (size <= 0) {
        return -1; // 배열이 비어있을 때 오류 표시 (-1 또는 다른 오류 코드)
    }

    int max = arr[0]; // 초기값으로 배열의 첫 번째 요소 설정

    for (int i = 1; i < size; i++) {
        if (arr[i] > max) {
            max = arr[i];
        }
    }

    return max;
}

int main() {
    int numbers[] = {12, 5, 8, 21, 3, 17};
    int size = sizeof(numbers) / sizeof(numbers[0]);

    int maximum = findMax(numbers, size);
    printf("Maximum: %d\n", maximum);

    return 0;
}
```

/end

# struct

DIR
FILE

dirent

stat

/end

## DIR

**`DIR`** 구조체는 C 언어에서 디렉토리를 나타내는 구조체입니다. 

이 구조체는 파일 시스템에서 디렉토리에 대한 정보를 저장하고 조작하기 위해 사용됩니다.

```c
struct dirent {
	ino_t d_ino;           // 파일의 i-node 번호
	char  d_name[];        // 파일 이름
};
typedef struct dirent DIR;
```

멤버설명:

- **`d_ino`**: 파일의 i-node 번호를 나타냅니다. i-node는 파일 시스템에서 파일에 대한 정보를 저장하는 데이터 구조입니다.
- **`d_name`**: 디렉토리 내의 파일 이름을 나타냅니다. 크기가 가변적인 배열로 정의되어 있어 실제 파일 이름의 길이에 따라 메모리가 할당됩니다.

/end

## FILE

**`FILE`** 구조체는 C 언어에서 파일 입출력을 처리하는 데 사용되는 구조체입니다. 이 구조체는 파일 스트림을 나타내며, 파일에서 데이터를 읽거나 파일에 데이터를 쓸 때 사용됩니다.

멤버 설명:

- **`int _file`:** 파일 디스크립터(File Descriptor)입니다. 파일 디스크립터는 운영체제에서 파일을 식별하는 번호입니다. 실제로 파일 시스템 내 파일을 가리키는 역할을 합니다.
- **`int _flags`:** 파일 상태 플래그들을 저장합니다. 예를 들어, 파일이 읽기 모드로 열렸는지, 쓰기 모드로 열렸는지 등을 나타냅니다.
- **`int _filedes`:** 파일 디스크립터와 관련된 내부 사용을 위한 변수입니다.
- **`unsigned char *_base`:** 파일 버퍼의 시작 주소를 가리킵니다. 버퍼는 파일에서 데이터를 읽거나 데이터를 파일에 쓸 때 사용됩니다.
- **`int _bf._size`:** 파일 버퍼의 크기를 나타냅니다.
- **`int _lbfsize`:** 라인 버퍼의 크기를 나타냅니다. 라인 버퍼는 **`stdout`** 스트림에서 사용됩니다.
- **`struct _IO_FILE *_chain`:** 다중 스트림의 연결 정보를 나타냅니다.
- **`int _blksize`:** 파일 시스템에서 읽기 및 쓰기 작업을 수행할 때 사용되는 블록 크기를 나타냅니다.

/end

## dirent

**`dirent`** 구조체는 디렉토리에서 파일 엔트리(파일 이름, 파일 속성 등)를 나타내기 위해 사용되는 구조체입니다.

```c
struct dirent {
    ino_t d_ino;           /* 파일의 inode 번호 */
    off_t d_off;           /* 파일 엔트리의 오프셋(offset) */
    unsigned short d_reclen; /* 파일 엔트리의 길이 */
    unsigned char d_type;   /* 파일의 형식 (DT_REG, DT_DIR 등) */
    char d_name[];         /* 파일 이름 */
};
```

위의 구조체 멤버들은 다음과 같은 역할을 합니다:

- **`d_ino`**: 파일의 inode 번호를 나타내는 정수형 변수입니다.
- **`d_off`**: 파일 엔트리의 오프셋(offset)을 나타내는 변수입니다.
- **`d_reclen`**: 파일 엔트리의 길이를 나타내는 변수로, 일반적으로 **`sizeof(struct dirent)`**로 계산됩니다.
- **`d_type`**: 파일의 형식을 나타내는 변수로, 예를 들어, 일반 파일인지 디렉토리인지를 나타내는데 사용됩니다.
- **`d_name`**: 파일의 이름을 나타내는 문자열입니다. 이는 유동적인 길이를 가지므로 배열의 크기가 정해져 있지 않습니다.

/end

## stat

**`stat`** 구조체는 파일의 메타데이터 정보를 저장하는 데 사용됩니다.

```c
struct stat {
    dev_t st_dev;         /* 파일이 위치한 장치의 ID */
    ino_t st_ino;         /* 파일의 inode 번호 */
    mode_t st_mode;       /* 파일의 권한 및 파일 형식 */
    nlink_t st_nlink;     /* 하드 링크의 개수 */
    uid_t st_uid;         /* 파일의 소유자 ID */
    gid_t st_gid;         /* 파일의 그룹 ID */
    dev_t st_rdev;        /* 특수 파일의 장치 ID */
    off_t st_size;        /* 파일의 크기 (바이트) */
    blksize_t st_blksize; /* 파일 시스템 I/O 블록 크기 */
    blkcnt_t st_blocks;   /* 파일이 차지하는 블록의 개수 */
    time_t st_atime;      /* 파일의 최근 접근 시간 */
    time_t st_mtime;      /* 파일의 최근 수정 시간 */
    time_t st_ctime;      /* 파일의 최근 상태 변경 시간 */
};
```

**`stat`** 구조체의 멤버들의 자료형은 다음과 같습니다:

1. **`st_dev`**: 정수형 (**`dev_t`**)
2. **`st_ino`**: 정수형 (**`ino_t`**)
3. **`st_mode`**: 정수형 (**`mode_t`**)
4. **`st_nlink`**: 정수형 (**`nlink_t`**)
5. **`st_uid`**: 정수형 (**`uid_t`**)
6. **`st_gid`**: 정수형 (**`gid_t`**)
7. **`st_rdev`**: 정수형 (**`dev_t`**)
8. **`st_size`**: 정수형 (**`off_t`**)
9. **`st_blksize`**: 정수형 (**`blksize_t`**)
10. **`st_blocks`**: 정수형 (**`blkcnt_t`**)
11. **`st_atime`**: 정수형 (**`time_t`**)
12. **`st_mtime`**: 정수형 (**`time_t`**)
13. **`st_ctime`**: 정수형 (**`time_t`**)

/end

## File type macros

| S_ISREG() | regular file |
| --- | --- |
| S_ISDIR() | directory file |
| S_ISCHR() | character special file |
| S_ISBLK() | block special file |
| S_ISFIFO() | pipe or FIFO |
| S_ISLNK() | symbolic link |
| S_ISSOCK() | socket |

struct stat {

| mode_t | st_mode | 파일 타입&모드 | ex) 0755 (파일 유형 비트+권한 비트) |
| --- | --- | --- | --- |
| ino_t | st_ino | i-node number |  |
| dev_t | st_dev | 파일이 저장된 device의 number | 하드디스크 여러 개일 때 필요 |
| dev_t | st_rdev | device number for 특별한 files |  |
| nlink_t | st_nlink | link 개수 |  |
| uid_t | st_uid | owner의 user ID |  |
| gid_t | st_gid | owner의 group ID |  |
| off_t | st_size | 일반 file들의 byte 크기 |  |
| time_t | st_atime | last access 시간 |  |
| time_t | st_mtime | 마지막 수정 시간 |  |
| time_t | st_ctime | 마지막 파일 상태 변경 시간 |  |
| long | st_blksize | best I/O block size | 하드디스크만 사용. ssd는 사용X |
| long | st_blocks | no. of 512-byte blocks allocated |  |

}

# Problem

## 연습문제1

[1] 다음을 출력시키는 프로그램을 ‘show’를 작성하시오. Source file은 ‘show.c’로 할 것. (20
점) [주의사항: loop를 사용해야 함]
$ ./show
1 2 3 4 5 6 7 8 9
1 2 3 4 5 6 7 8
1 2 3 4 5 6 7
1 2 3 4 5 6
1 2 3 4 5
1 2 3 4
1 2 3
1 2
1

```c
#include <stdio.h>

main(){
        for(int j = 9; j != 0; j--){
                for(int i=1; i <= j; i++){
                        printf("%d ", i);
                }
                printf("\n");
        }
}
```

## 연습문제2

[2] String의 문자를 모두 대문자로 바꾸는 void strupper(char str[]) 함수를 작성하고, 그 예를
보이는 프로그램 ‘upper’를 작성할 것. Source file은 ‘upper.c’로 할 것. (20점)
$ ./upper
HELLO, WORLD!

```c
#include <stdlib.h>
#include <sys/wait.h>
#include <unistd.h>
#include <pthread.h>
#include <string.h>
#include <sys/types.h>
#include <stdio.h>
#include <sys/stat.h>
#include <dirent.h>
#include <grp.h>
#include <pwd.h>
#include <time.h>
#include <ctype.h>
#include <fcntl.h>
#define MAX_BUF 256

void strupper(char str[]){
        int i = 0;
        while(str[i] != '\0'){
                if(96< str[i] && str[i] < 123){
                        str[i] = str[i] - 32;
                }
                printf("%c", str[i]);
                i++;
        }
        printf("\n");
}

int main()
{
        char str[MAX_BUF] = "hello, world!";
        strupper(str);

}
~
```

## 연습문제3

[3] Text file을 입력으로 하여 단어의 수를 출력하는 프로그램 ‘count’를 작성할 것. Source file
은 ‘count.c’로 할 것. (20점)
$ ./count count.c
28

```c
#include <stdlib.h>
#include <sys/wait.h>
#include <unistd.h>
#include <pthread.h>
#include <string.h>
#include <sys/types.h>
#include <stdio.h>
#include <sys/stat.h>
#include <dirent.h>
#include <grp.h>
#include <pwd.h>
#include <time.h>
#include <ctype.h>
#include <fcntl.h>

#define MAX_BUF 1024

int main(int argc, char **argv)
{
        FILE *file = fopen(argv[1], "r");
        char prev = ' ';
        int c;
        char curr;
        int count = 0;
        while((c = fgetc(file)) != EOF){
                curr = c;
                if(prev != ' ' && (curr == ' ' || curr == '\n' || curr == '\t')){
                        count++;
                }
                prev = curr;
        }
        fclose(file);
        printf("%d\n", count);

}
```

## 연습문제4

[4] File을 삭제하는 프로그램 ‘myrm’을 작성하시오. 이때, 여러 개의 file을 동시에 삭제할 수
있어야 한다. Source file은 ‘myrm.c’로 할 것. (20점) [주의사항: source file(*.c)로 삭제하는
command를 실행하지 말 것. 다른 문제의 source file을 삭제하고, 실수했다고 주장하면 안
됨. 별도의 directory에서 작업하는 것이 안전함]
$ ./myrm *.o

```c
#include <stdlib.h>
#include <stdio.h>
#include <dirent.h>
#include <string.h>

main(int argc, char **argv) {
    while(*argv){
        remove(*argv);
        argv++;
        }
}
```

## 연습문제5

[5] 현재의 directory에서 file의 크기가 특정 크기 (command-line argument로 주어짐) 이상인
프로그램의 이름을 출력하는 프로그램 ‘size’를 작성하시오. Source file은 ‘size.c’로 할 것.
(20점)
$ ./size 500
size.o
myrm.o
count.o

```c
#include <stdlib.h>
#include <sys/wait.h>
#include <unistd.h>
#include <pthread.h>
#include <string.h>
#include <sys/types.h>
#include <stdio.h>
#include <sys/stat.h>
#include <dirent.h>
#include <grp.h>
#include <pwd.h>
#include <time.h>
#include <ctype.h>
#include <fcntl.h>

int main(int argc, char **argv)
{
        DIR *dir;
        struct dirent *pDirent;
        struct stat buf;
        dir = opendir(".");
        while((pDirent  = readdir(dir)) != NULL){
                if(lstat(pDirent->d_name, &buf) < 0){
                        continue;
                }
                if((buf.st_size > atoi(argv[1]))){
                        printf("%s\n",pDirent->d_name);
                }
        }

}
```

## 정우-연습문제1

입력받은 파일을 chunk 단위로 출력하는 프로그램을 작성하시오. 단, 파일은 한
개만 입력받는다고 가정한다. (chunk는 화이스 스페이스 단위로 구분된 word, 화
이트 스페이스는 줄바꿈, 탭, 공백문자를 의미한다.)

 
출력 예시)
입력 텍스트:
            hi i'm
sun woo
i'm so stupid
thank             you

```c
#include <stdio.h>

char wt_sp[3] = {' ', '\n', '\t'};

int is_wt(char ch) {
	for (int i = 0; i < 3; i++)
		if (ch == wt_sp[i])
			return 1;
	return 0;
}

int main(int argc, char **argv) {
	if (argc != 2) {
		printf("input error!\n");
		return (0);
	}
	FILE *fp = fopen(argv[1], "r");
	int c, flag = 1;

	while((c = fgetc(fp)) != EOF) {
		if (is_wt(c)) {
			if (flag == 0) {
				flag = 1;
				printf("\n");
			}
		}
		else {
			flag = 0;
			printf("%c", c);
		}
	}
}
```

## 정우-연습문제2

입력받은 파일의 이름과 몇 줄로 이루어졌는지 출력하는 프로그램을 작성하시오.
파일들은 여러개가 들어올 수 있으며 각 출력마다 줄바꿈을 하시오.

```c
#include <stdio.h>

int cline(char *arg)
{
	int cnt = 0, c;	

	FILE *fp = fopen(arg, "r");
	while ((c = fgetc(fp)) != EOF)
		if (c == '\n')
			 cnt++;
	return cnt;
}

int main(int argc, char **argv)
{
	for (int i = 1; i < argc; i++)
		printf("%s %d\n", argv[i], cline(argv[i]));
}
```

## 정우-연습문제3

현재 디렉토리의 모든 .o 파일을 object 디렉토리로 옮기는 omv 프로그램을 작성
하시오. 만약에 object 디렉토리가 없다면 omv는 object 디렉토리를 생성해야한
다. 프로그램이 디렉토리를 만들 경우 권한은 유저에게는 실행, 쓰기, 읽기 권한
을, 그룹 유저에게는 읽기, 실행 권한을, 다른 유저에게는 어떠한 권한도 주지 말
아야 한다.
힌트: man strcat, man strlen

```c
#include <stdio.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <dirent.h>
#include <string.h>

int main(int argc, char *argv[])
{
	DIR *dir;
	struct dirent *ent;
	int len;

	mkdir("object", 0750);
	dir = opendir(".");	
	while ((ent = readdir(dir)))
	{
		len = strlen(ent->d_name);	
		if (len >= 2 && ent->d_name[len - 2] == '.' && ent->d_name[len - 1] == 'o')
		{
			char new_name[100] = {0};
			strcat(new_name, "object/");ㅌ
			strcat(new_name, ent->d_name);
			rename(ent->d_name, new_name);
		}
	}
	
}
```

# 정우-연습문제4

두 개의 스레드를 만들어서 한 스레드는 1부터 1000까지의 홀수를, 나머지는 1부
터 1000까지의 짝수를 모두 더한 뒤 짝수의 합에서 홀수의 합을 빼는 프로그램
을 작성하시오. 뺄셈 연산은 단 한번만 이루어져야 한다.

```c
#include <stdio.h>
#include <pthread.h>

int o, e;

void *odd_numbers(void *args) {
	for (int i = 1; i <= 1000; i += 2) o += i;
	return NULL;
}

void *even_numbers(void *args) {
	for (int i = 2; i <= 1000; i += 2) e += i;
	return NULL;
}

int main() {
    pthread_t odd;
	pthread_t even;
    
    if (pthread_create(&odd, NULL, odd_numbers, NULL) != 0) {
        perror("pthread_create");
        return 1;
    };

    if (pthread_create(&even, NULL, even_numbers, NULL) != 0) {
        perror("pthread_create");
		return 1;
    }

    if (pthread_join(odd, NULL) != 0) {
        perror("pthread_join");
    }
	
    if (pthread_join(even, NULL) != 0) {
        perror("pthread_join");
        return 1;
    }
    printf("%d\n", e - o);
}
```

# 정우-연습문제5

현재 디렉토리에 있는 모든 파일에 대하여, other 사용자에게 읽기 권한과 실행
권한이 모두 주어져있다면 그룹사용자에게도 읽기 권한과 실행 권한을 부여하는
프로그램을 작성하라. (other 사용자에게 읽기 권한과 실행 권한이 모두 주어져있
지 않은 경우에는 별도의 동작을 하지 마라)

```c
#include <stdio.h>
#include <sys/types.h>
#include <dirent.h>
#include <sys/stat.h>

int main()
{
	DIR *dir;
	struct dirent * ent;
	struct stat statbuf;	

	dir = opendir(".");
	while((ent = readdir(dir)) != NULL)
	{
		lstat(ent->d_name, &statbuf);
		if((statbuf.st_mode & S_IXOTH) && (statbuf.st_mode & S_IROTH))
		{
			chmod(ent->d_name, (statbuf.st_mode | S_IXGRP) | S_IRGRP);
		}
	}
}
```

## 정우 연습문제-6

테이블과 열의 이름을 입력받았을 때, 해당 열을 출력하는 프로그램을 작성하라, 각 element는 공백으로 구분되며, 각 튜플은 줄바꿈으로 구분된다. 첫 행은 열의 이름을 나타낸다. 별도의 오류처리는 하지 않는다.

출력 예시)

**student.txt**

s_id s_name s_age

1 ImJungWoo 24

2 ParkSunWoo 24

3 BaekJiWon 23

./select student.txt s_name

ImJungWoo

ParkSunWoo

BaekJiWon

```c
#include <stdio.h>
#include <string.h>

int main() {
    char file_name[100];
    char column_name[100];

    // 파일 이름과 열 이름 입력 받기
    printf("Enter the file name: ");
    scanf("%s", file_name);
    printf("Enter the column name: ");
    scanf("%s", column_name);

    FILE *file = fopen(file_name, "r");
    char line[1000];
    char *token;
    int column_index = -1;

    // 첫 줄 읽기 (열 이름이 있는 줄)
    fgets(line, sizeof(line), file);
    // 열 이름을 기반으로 열 인덱스 찾기
    token = strtok(line, " ");
    int index = 0;
    while (token != NULL) {
        if (strcmp(token, column_name) == 0) {
            column_index = index;
            break;
        }
        token = strtok(NULL, " ");
        index++;
    }

    // 열 값 출력
    while (fgets(line, sizeof(line), file) != NULL) {
        token = strtok(line, " ");
        for (int i = 0; i < column_index; i++) {
            token = strtok(NULL, " ");
        }
        // strtok로 분리된 토큰이 NULL이 아닌 경우에만 출력
        if (token != NULL) {
            printf("%s\n", token);
        }
    }

    // 파일 닫기
    fclose(file);
    return 0;
}
```

# 21-2 연습문제1번

[1] Command-line에서 십진수를 입력 받아 제곱하여 출력하는 프로그램 ‘square’를 작성하시오. Source file은 ‘square.c’로 할 것. (20점)

$ ./square 8

64

```c
#include <stdio.h>
#include <stdlib.h>

int main(int argc, char **argv) {
    if (argc != 2) {
        printf("Usage: %s <number>\n", argv[0]);
        return 1;
    }

    int number = atoi(argv[1]); // 명령줄 인수를 정수로 변환

    int square = number * number; // 제곱 계산

    printf("%d\n", square);

    return 0;
}
```

# 21-2 연습문제2번

[2] Text file에서 word의 개수를 출력하는 command는 다음과 같다.

$ wc -w mywc.c

66 mywc.c

이를 프로그램에서 실행하시오. 즉, child process를 생성하여 child process에서는 execvp() system call을 통하여 실행한다. Parent process는 child process가 종료되기를 기다렸다가 프로그램을 종료한다. Source file은 ‘mywc.c’로 할 것. (20점)

$ ./mywc mywc.c

6 mywc.c

```c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/wait.h>

int main(int argc, char **argv) {
    if (argc != 2) {
        printf("Usage: %s <filename>\n", argv[0]);
        return 1;
    }

    char *file = argv[1];
    char *args[] = {"wc", "-w", file, NULL};

    pid_t child_pid;
    int status;

    if ((child_pid = fork()) == 0) {  // Child process
        execvp("wc", args);
        perror("execvp");
        exit(1);
    } else if (child_pid < 0) {  // Fork error
        perror("fork");
        exit(1);
    } else {  // Parent process
        waitpid(child_pid, &status, 0);
        if (WIFEXITED(status) && WEXITSTATUS(status) == 0) {
            printf("Execution completed.\n");
        } else {
            printf("Execution failed.\n");
        }
    }

    return 0;
}
```

# 21-2 연습문제3번

[3] Quick introduction to C의 숙제2에서 int strcmp_p(char *dst, char *src) 를 작성했었다. 이때, 대소문자 구별없이 비교하는 int stricmp_p(char *dst, char *src) 로 변경하시오. Source file은 ‘stricmp.c’로 할 것. (20점)

void main()

{

char str1[] = “Hello”;

char str2[] = “hello”;

char str3[] = “World!”;

printf(“%d : %d\n”, stricmp_p(str1, str2),

stricmp_p(str1, str3));

}

$ ./stricmp

0 : -1

```c
#include <stdio.h>
#include <ctype.h>

int stricmp_p(const char *dst, const char *src) {
    while (*dst && *src) {
        char c1 = tolower(*dst);
        char c2 = tolower(*src);

        if (c1 != c2) {
            return c1 - c2;
        }

        dst++;
        src++;
    }

    return tolower(*dst) - tolower(*src);
}

int main() {
    char str1[] = "Hello";
    char str2[] = "hello";
    char str3[] = "World!";

    printf("%d : %d\n", stricmp_p(str1, str2), stricmp_p(str1, str3));

    return 0;
}
```

# 21-2 연습문제4번

[4] Text file에서 주어진 문자의 갯수를 출력하는 프로그램 ‘count’를 작성하시오. Source file은 ‘count.c’로 할 것. (20점)

$ ./count count.c f

3

[주어진 예시는 count.c에 존재하는 ‘f’의 개수인 3을 출력하는 것임]

```c
#include <stdio.h>

int main(int argc, char **argv) {
    if (argc != 3) {
        printf("Usage: %s <filename> <character>\n", argv[0]);
        return 1;
    }

    FILE *file = fopen(argv[1], "r");
    if (file == NULL) {
        perror("Error opening file");
        return 1;
    }

    char target = argv[2][0]; // 대상 문자
    int count = 0; // 일치하는 문자 개수

    int ch;
    while ((ch = fgetc(file)) != EOF) {
        if (ch == target) {
            count++;
        }
    }

    printf("%d\n", count);

    fclose(file);

    return 0;
}
```

# 21-2 연습문제5번

[5] 현재의 directory에서 생성된 시간이 가장 최근인 file의 이름을 출력하는 프로그램 ‘new’를 작성하시오. Source file은 ‘new.c’로 할 것. (20점)

$ ./new

new

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <dirent.h>
#include <sys/stat.h>
#include <time.h>

int main() {
    struct dirent *pDirent;
    struct stat buf;
    int latestTime = 0; // time_t를 int로 형변환
    char latestFile[256];

    DIR *dir = opendir(".");

    if (dir == NULL) {
        perror("Failed to open directory");
        return 1;
    }

    while ((pDirent = readdir(dir)) != NULL) {
        if (lstat(pDirent->d_name, &buf) == 0) {
            if (S_ISREG(buf.st_mode)) {
                // time_t를 int로 형변환하여 비교
                int ctime = (int)buf.st_ctime;
                if (ctime > latestTime) {
                    latestTime = ctime;
                    strcpy(latestFile, pDirent->d_name);
                }
            }
        }
    }

    closedir(dir);

    if (latestTime > 0) {
        printf("%s\n", latestFile);
    } else {
        printf("No regular files found in the current directory.\n");
    }

    return 0;
}
```

# 22-2 연습문제1

+,-,x,/ 연산을 수행하는 프로그램 ‘calc’를 작성하시오. Command-line argument 는 “정수 기호 정수” 의 3개로 주어진다. 공백으로 분리 Source file은 ‘calc.c’로 할것

$./calc 11 x 22

# 22-2 연습문제2

문자열과 문자를  입력 받아 해당 문자를 모두 삭제하는 함수 ‘del’을 작성하시오. Source file은 ‘del.c’로 할  것. 단 pointer로 구현해야함

```c
#include <stdlib.h>
#include <sys/wait.h>
#include <unistd.h>
#include <pthread.h>
#include <string.h>
#include <sys/types.h>
#include <stdio.h>
#include <sys/stat.h>
#include <dirent.h>
#include <grp.h>
#include <pwd.h>
#include <time.h>
#include <ctype.h>
#include <fcntl.h>

void del(char *str,  char c){
        char *dst = str;
        while(*str){
                if(*str != c){
                        *dst = *str;
                        dst++;
                }
                str++;
        }
        *dst = '\0';
}

main()
{
        char str[20] = "Hello";
        del(str, 'l');
        puts(str);
}
```

# 22-2 연습문제3

악성코드는 특정 signature를 검사함으로써 탐지하기도 한다. Binary file에서 특정 패턴이 발견된 횟수를 출력하는 프로그램 ‘pattern’

fopen()을 “rb”로 fread함수 사용

```c
#include <stdio.h>
#include <string.h>

#define MAX_BUF 1024

int main(int argc, char **argv) {
    if (argc != 3) {
        printf("Usage: %s <filename> <target_string>\n", argv[0]);
        return 1;
    }

    FILE *file = fopen(argv[1], "rb");
    if (file == NULL) {
        perror("Error opening file");
        return 1;
    }

    char data[MAX_BUF];
    size_t bytes_read;
    const char *target = argv[2]; // 대상 문자열
    int count = 0; // 일치하는 문자열 수

    while ((bytes_read = fread(data, sizeof(char), MAX_BUF, file)) > 0) {
        for (size_t i = 0; i < bytes_read; i++) {
            if (data[i] == target[0]) {
                if (strncmp(&data[i], target, strlen(target)) == 0) {
                    count++; // 문자열이 일치하는 경우
                }
            }
        }
    }

    printf("Number of matches: %d\n", count);

    if (ferror(file)) {
        perror("Error reading file");
    }

    fclose(file);

    return 0;
}
```

/end

# HW3

추가 프로그램 작성

- string.c에 다음의 함수를 추가하고, main함수에 사용 예를 보일 것
- int strcmp_p(char *dst, char *src);
- int strcmp_a(char dst[], char src[]);
- 위 두함수는 strcmp 함수와 같은 일을 수행함

```c
#include <stdio.h>

int
strlen_p(char *str)
{
	int	len = 0;

	while (*str++)  {
		len++;
	}
	return len;
}

int
strlen_a(char str[])
{
	int i;

	for (i = 0 ; str[i] != '\0' ; i++)
		;
	return i;
}

void
strcpy_p(char *dst, char *src)
{
	while (*src)  {
		*dst++ = *src++;
	}
	*dst = *src;
}

void
strcpy_a(char dst[], char src[])
{
	int i;

	for (i = 0 ; src[i] != '\0'; i++)
		dst[i] = src[i];
	dst[i] = src[i];
}

void
strcat_p(char *dst, char *src)
{
	while (*dst++)
		;
	*dst--;
	while (*src)  {
		*dst++ = *src++;
	}
	*dst = *src;
}

void
strcat_a(char dst[], char src[])
{
	int i, j;

	for (i = 0 ; dst[i] != '\0' ; i++)
		;
	for (j = 0 ; src[j] != '\0' ; j++)
		dst[i+j] = src[j];
	dst[i+j] = src[j];
}

//- int strcmp_p(char *dst, char *src);
int strcmp_p(char *dst,char *src){
	while(*dst && *dst == *src){
			*dst++;
			*src++;
	}
	if(*dst == *src){
		return 0;
	} else if(*dst > *src){
		return 1;
	}	else{
			return -1;
}

// - int strcmp_a(char dst[], char src[]);

int strcmp_a(char dst[], char src[]){
	int i =0;
	while(dst[i] && dst[i] == src[i]{
		i++;
	}
	return dst[i] = src[i];	
}

main()
{
	int		len1, len2;
	char	str1[20], str2[20];

	len1 = strlen_p("Hello");
	len2 = strlen_a("Hello");
	printf("strlen: p=%d, a=%d\n", len1, len2);

	strcpy_p(str1, "Hello");
	strcpy_a(str2, "Hello");
	printf("strcpy: p=%s, a=%s\n", str1, str2);

	strcat_p(str1, ", World!");
	strcat_a(str2, ", World!");
	printf("strcat: p=%s, a=%s\n", str1, str2);

	// strcmp 함수 테스트
  int result = strcmp_p("Hello", "hello"); // 문자열 비교 (포인터 사용)
  int result1 = strcmp_p("hello", "hello");
  int result2 = strcmp_p("hello", "Hello");
  printf("result p= %d result1 p= %d result2 p= %d \n", result, result1, result2);
  printf("result diff p= %d \n", strcmp_p("he", "hello"));
  printf("result diff2 p= %d \n", strcmp_p("hell", "hel")); 
  
	int res = strcmp_a("Hello", "hello"); // 문자열 비교 (배열 사용)
  int res1 = strcmp_a("hello", "hello");
  int res2 = strcmp_a("hello", "Hello");
  printf("res a= %d res1 a= %d res2 a= %d \n", res, res1, res2);
  printf("res diff a= %d \n", strcmp_a("he", "hello"));
  printf("res diff2 a= %d \n", strcmp_a("hell", "hel"));
}
```

/end

# HW4

```c
  1 #include <stdio.h>
  2 #include <sys/types.h>
  3 #include <sys/stat.h>
  4 #include <fcntl.h>
  5 
  6 #define MAX_BUF 1024
  7 
  8 int main(int argc, char* argv[]){
  9     if(argc != 3){
 10         printf("must be one variable");
 11         exit(1);
 12     }
 13 
 14     FILE *file = fopen(argv[1], "rt");
 15     FILE *file_to_write = fopen(argv[2], "wt");
 16 
 17     int c;
 18     while((c =  fgetc(file)) != EOF){
 19         printf("%c",toupper(c));
 20         fprintf(file_to_write, "%c", toupper(c));
 21     }
 22 
 23     fclose(file);
 24     fclose(file_to_write);
 25     return 0;
 26 }
```

/end

# HW5

- 숙제2: 추가 프로그램 작성
    - "ls -l" 과 유사하게 동작하는 프로그램 mylsl을 작성하시오.
    - $ ./mylsl

```c
#include <stdio.h>
#include <dirent.h>
#include <unistd.h>
#include <sys/stat.h>
#include <string.h>
#include <pwd.h>
#include <time.h>
#include <grp.h>
#include <stdlib.h>

int main() {
    DIR *dir;
    struct dirent *pDirent;
    struct stat buf;
    struct passwd *pwd;
    struct group *g;
    int count = 0;
    int result;
    char *mode;
    char f[128];
    dir = opendir(".");

    while ((pDirent = readdir(dir)) != NULL) {
        if (strcmp(pDirent->d_name, ".") == 0 || strcmp(pDirent->d_name, "..") == 0) {
            continue;
        }

        if ((result = lstat(pDirent->d_name, &buf)) < 0) {
            continue;
        }

        count += buf.st_blocks / 2;
    }

    printf("TOTAL: %d\n", count);

    rewinddir(dir);
    while ((pDirent = readdir(dir)) != NULL) {
        if (strcmp(pDirent->d_name, ".") == 0 || strcmp(pDirent->d_name, "..") == 0) {
            continue;
        }

        if ((result = lstat(pDirent->d_name, &buf)) < 0) {
            continue;
        }

        if (S_ISREG(buf.st_mode))
            mode = "-";
        else if (S_ISDIR(buf.st_mode))
            mode = "d";
        else if (S_ISCHR(buf.st_mode))
            mode = "c";
        else if (S_ISBLK(buf.st_mode))
            mode = "b";
        else if (S_ISLNK(buf.st_mode))
            mode = "l";

        printf("%s", mode);
        printf((buf.st_mode & S_IRUSR) ? "r" : "-");
        printf((buf.st_mode & S_IWUSR) ? "w" : "-");
        printf((buf.st_mode & S_ISUID) ? "S" : ((buf.st_mode & S_IXUSR) ? "x" : "-"));
        printf((buf.st_mode & S_IRGRP) ? "r" : "-");
        printf((buf.st_mode & S_IWGRP) ? "w" : "-");
        printf((buf.st_mode & S_IXGRP) ? "x" : "-");
        printf((buf.st_mode & S_IROTH) ? "r" : "-");
        printf((buf.st_mode & S_IWOTH) ? "w" : "-");
        printf((buf.st_mode & S_IXOTH) ? "x" : "-");
        printf(" %ld ", buf.st_nlink);
        pwd = getpwuid(buf.st_uid);
        g = getgrgid(buf.st_gid);
        printf("%s %s ", pwd->pw_name, g->gr_name);
        printf("%5ld ", (long)buf.st_size);
        struct tm *ct = localtime(&buf.st_mtime);
        strftime(f, 128, "%b %d %H:%M ", ct);
        printf("%s ", f);

        if (strcmp(mode, "l") == 0) {
            char buff[1024];
            int n;
            if ((n = readlink(pDirent->d_name, buff, 1024)) == -1) {
                perror("readlink");
                exit(1);
            }
            buff[n] = '\0';
            printf("%s -> %s\n", pDirent->d_name, buff);
        } else {
            printf("%s\n", pDirent->d_name);
        }
    }
    closedir(dir);
    return 0;
}
```

/end

# HW6

- 숙제2: 추가 프로그램 작성
    - int mysystem(char *cmd) 함수를 구현하시오. 동작은 "system" system call과 동일해야 하며, fork, execv, waitpid system call을 이용하여 구현한다.

```c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>

#define MAX_BUF 1024
int mysystem(char *cmd){
	int pid;
	int status;
	char *argv[] = {"sh","-c",cmd,NULL};	
	if((pid = fork()) < 0){
		perror("fork");
		return -1;
	} else if(pid == 0){
			if(execv("/bin/sh", argv) < 0){
					perror("execv");
					return -1;
			}
	}
	if(waitpid(pid, &status, 0)<0){
		perror("waitpid");
		return -1;
	} 
	return status;
}

main(){
	int status;
	char cmd[MAX_BUF];
	while(1){
		printf("CMD> ");
		fgets(cmd, MAX_BUF ,stdin);
		if (cmd[0] == 'q')
            break;
		if((status = mysystem(cmd))<0){
			perror("mysystem");
			exit(1);
		}
	printf("status = %d\n", status);
}
}
```

- 숙제3: 추가 프로그램 작성
    - 1부터 100까지의 합을 구하는 프로그램 tadd를 작성하시오. 두개의 thread를 생성하여 각각 1~50, 51~100까지의 합을 구하고, main thread가 각 thread가 종료되기를 기다린 후 각각의 합을 더하여 출력해야 함
    
    ```c
    #include <stdio.h>
    #include <pthread.h>
    #include <stdlib.h>
    
    typedef struct SumValue {
        int s;
        int sum;
    } SUMVALUE, *SUM;
    
    void *add_sum(void *arg) {
        SUMVALUE *test = (SUM)arg;
        int idx = test->s;
    
        for (int i = idx; i < idx + 50; i++)
            test->sum += i;
    
        return NULL;
    }
    
    int main() {
        pthread_t tid1, tid2;
        SUM arg1 = (SUM)malloc(sizeof(SUMVALUE));
        arg1->s = 1;
        arg1->sum = 0;
        SUM arg2 = (SUM)malloc(sizeof(SUMVALUE));
        arg2->s = 51;
        arg2->sum = 0;
    
        if (pthread_create(&tid1, NULL, add_sum, arg1) != 0) {
            perror("pthread_create");
            return 1;
        }
    
        if (pthread_create(&tid2, NULL, add_sum, arg2) != 0) {
            perror("pthread_create");
            return 1;
        }
    
        pthread_join(tid1, NULL);
        pthread_join(tid2, NULL);
        printf("%d\n", (arg1->sum + arg2->sum));
    
        free(arg1);
        free(arg2);
    
        return 0;
    }
    ```
    
    /end
# 기말고사 정리

# 

## Alarm 종류

1. **SIGALRM**

설명: 알람을 설정하고 시간 초과를 나타내는 시그널로 사용됩니다. 주어진 시간이 경과하면 이 시그널이 발생합니다.

1. **SIGCHLD**

설명: 자식 프로세스의 종료 또는 중단을 나타내는 시그널로, 부모 프로세스가 자식 프로세스의 상태를 확인하는데 사용됩니다.

1. **SIGINT**

설명: 인터럽트를 나타내는 시그널로, 주로 Ctrl+C 키 조합을 사용하여 프로세스를 중지시키는데 사용됩니다.

1. **SIGPIPE**

설명: 파이프가 끊어졌을 때 발생하는 시그널로, 파이프로 데이터를 보낼 때 파이프의 다른 끝이 닫힌 경우에 발생합니다.

1. **SIGSEGV**

설명: 잘못된 메모리 접근(세그멘테이션 오류)를 나타내는 시그널로, 프로세스가 메모리의 올바르지 않은 부분에 접근하려고 할 때 발생합니다

1. **SIGUSR1 및 SIGUSR2:**

설명: 사용자 정의 시그널로, 프로그램에 사용자 정의 동작을 트리거하는데 사용됩니다. 개발자가 자신의 응용프로그램에 맞게 정의할 수 있습니다.

1. **SIGSYS:**

설명: 시스템 호출 오류를 나타내는 시그널로, 프로세스가 시스템 호출을 잘못 사용하였을 때 발생합니다.

```c
#include <unistd.h>
#include <stdio.h>
#include <signal.h>

void alarm_handler(int signo) {
	printf("Alarm received!\n");
}

int main() {
	signal(SIGALRM, alarm_handler);
	unsigned int remaining = alarm(5);  // 5초 후에 SIGALRM 시그널 발생
	printf("Alarm set. Remaining: %u seconds\\n", remaining);
	pause();  // 시그널을 기다립니다.
	
	return 0;
}
```

/end

# Pause

## 헤더:

```c
#include <unistd.h>
```

## 함수 원형:

```c
int pause(void);
```

## 설명:

 pause 함수는 시그널을 받을 때까지 프로세스를 대기시킵니다. 주로 시그널 핸들링을 위한 루프에서 사용됩니다.

## 반환값:

항상 -1을 반환하며, 시그널을 받을 때까지 대기합니다.

## 간단한 예시

```c
#include <unistd.h>
#include <stdio.h>
#include <signal.h>

void signal_handler(int signo) {
	printf("Signal received: %d\n", signo);
}

int main() {
	signal(SIGUSR1, signal_handler);
	printf("Waiting for a signal...\n");
	pause();  // 시그널을 받을 때까지 대기
	return 0;
}
```

/end

# Reentrant Functions

- 여러 개의 프로세스가 동시에 진입할 수 있는 함수
- 함수 내부에서 사용되는 데이터를 스택에 저장하고, 각 프로세스마다 별도의 스택 공간을 사용하여 데이터를 보호

```c
#include <stdio.h>
#include <signal.h>
#include <pwd.h>

void
MyAlarmHandler(int signo)
{
	struct passwd	*rootptr;
	signal(SIGALRM, MyAlarmHandler);
	alarm(1);
	printf("in signal handler\n");
	if ((rootptr = getpwnam("root")) == NULL)  {
		perror("getpwnam");
		exit(1);
	}
	return;
}

main()
{
	struct passwd	*ptr;
	signal(SIGALRM, MyAlarmHandler);
	alarm(1);
	for ( ; ; )  {
		if ((ptr = getpwnam("cjs")) == NULL)  {
			perror("getpwnam");
			exit(1);
		}
		if (strcmp(ptr->pw_name, "cjs") != 0)  {
			printf("return value corrupted!, pw_name = %s\n", ptr->pw_name);
			exit(0);
		}
	}
}
```

/end

# pthread_cancel

## 헤더 파일:

```c
#include <pthread.h>
```

## 함수 원형:

```c
int pthread_cancel(pthread_t tid);
```

## 설명:

지정된 쓰레드(tid)에 대해 취소 요청을 보냅니다. 취소 요청은 해당 쓰레드에서 취소 가능한 지점(Cancellation Point)에서 처리됩니다.

## 반환값:

성공 시 0, 실패 시 non-zero 값을 반환합니다.

/end

# pthread_setcancelstate

## 헤더 파일:

```c
<pthread.h>
```

## 함수 원형:

```c
int pthread_setcancelstate(int state, int *oldstate);
```

## 설명:

쓰레드의 취소 상태를 설정합니다. state 인자는 PTHREAD_CANCEL_DISABLE(취소 비활성화) 또는 PTHREAD_CANCEL_ENABLE(취소 활성화, 기본값) 중 하나를 지정합니다. oldstate 포인터를 통해 이전의 취소 상태를 얻을 수 있습니다.
    ◦ 반환값: 성공 시 0, 실패 시 non-zero 값을 반환합니다.

/end

# pthread_setcanceltype

## 헤더 파일:

```c
<pthread.h>
```

## 함수 원형:

```c
int pthread_setcanceltype(int type, int *oldtype);
```

## 설명:

쓰레드의 취소 타입을 설정합니다. type 인자는 PTHREAD_CANCEL_ASYNCHRONOUS(비동기 취소) 또는 PTHREAD_CANCEL_DEFERRED(지연 취소, 기본값) 중 하나를 지정합니다. oldtype 포인터를 통해 이전의 취소 타입을 얻을 수 있습니다.
    ◦ 반환값: 성공 시 0, 실패 시 non-zero 값을 반환합니다.

```c
#include <stdio.h>
#include <signal.h>
#include <pthread.h>

pthread_t ThreadId[2]; // 두 개의 쓰레드 식별자를 저장하는 배열

void SigIntHandler(int signo) {
    int i;
    printf("Received a SIGINT signal by thread %d\n", pthread_self());
    printf("Terminate other threads: tid=%d, %d\n", ThreadId[0], ThreadId[1]);
    // 다른 쓰레드를 종료하기 위해 pthread_cancel 함수를 호출
    for (i = 0; i < 2; i++) {
        if (pthread_cancel(ThreadId[i])) {
            perror("pthread_cancel");
            exit(1);
        }
    }
    // 종료된 쓰레드를 기다리기 위해 pthread_join 함수를 호출
    for (i = 0; i < 2; i++) {
        if (pthread_join(ThreadId[i], NULL)) {
            perror("pthread_join");
            exit(1);
        }
    }
    printf("Threads terminated: tid=%d, %d\n", ThreadId[0], ThreadId[1]);
    exit(0);
}

void Thread1(void *dummy) {
    printf("Thread %d created....\n", pthread_self());

    // 쓰레드 취소 상태와 타입 설정
    if (pthread_setcancelstate(PTHREAD_CANCEL_ENABLE, NULL)) {
        perror("pthread_setcancelstate");
        pthread_exit(NULL);
    }
    if (pthread_setcanceltype(PTHREAD_CANCEL_ASYNCHRONOUS, NULL)) {
        perror("pthread_setcanceltype");
        pthread_exit(NULL);
    }

    while (1)
        ;
}

void Thread2(void *dummy) {
    printf("Thread %d created....\n", pthread_self());

    // 쓰레드 취소 상태와 타입 설정
    if (pthread_setcancelstate(PTHREAD_CANCEL_ENABLE, NULL)) {
        perror("pthread_setcancelstate");
        pthread_exit(NULL);
    }
    if (pthread_setcanceltype(PTHREAD_CANCEL_ASYNCHRONOUS, NULL)) {
        perror("pthread_setcanceltype");
        pthread_exit(NULL);
    }

    while (1)
        ;
}

int main() {
    // 두 개의 쓰레드 생성
    if (pthread_create(&ThreadId[0], NULL, (void *) Thread1, NULL) < 0) {
        perror("pthread_create");
        exit(1);
    }
    if (pthread_create(&ThreadId[1], NULL, (void *) Thread2, NULL) < 0) {
        perror("pthread_create");
        exit(1);
    }

    // SIGINT 시그널 핸들러 등록
    signal(SIGINT, SigIntHandler);

    printf("Press ^C to quit\n");

    // 무한 루프
    for (;;) {
        pause(); // 시그널이 발생할 때까지 대기
    }
}
```

**파이프**(pipes): 단방향 통신을 위한 메커니즘으로, 하나의 프로세스에서 데이터를 쓰고 다른 하나의 프로세스에서 데이터를 읽을 수 있습니다. 부모-자식 프로세스 간 통신에 주로 사용됩니다.

**FIFO**: 파이프와 유사하지만 이름이 있는 파이프로서, 별도의 파일 시스템 엔트리를 가지고 있어 다른 프로세스들이 해당 FIFO에 접근할 수 있습니다.

**소켓**(sockets): 네트워크 통신을 위한 메커니즘으로, 인터넷 프로토콜을 통해 프로세스 간 통신이 가능합니다. 로컬 머신 내의 프로세스 간 통신에도 사용할 수 있습니다.

/end

# pipe

```c
int pipe(int pipefd[2]);
```

## 머리글:

```c
#include <unistd.h>
```

## 매개변수:

pipefd: 파이프 읽기 및 쓰기 끝을 위한 파일 설명자가 저장될 두 개의 정수 배열입니다.

pipefd[0]에는 파이프의 읽기 끝 부분에 대한 파일 설명자가 포함됩니다.
pipefd[1]에는 파이프의 쓰기 끝에 대한 파일 설명자가 포함됩니다.

## 설명:

pipe 함수는 파이프를 사용하여 프로세스 간 통신 채널(IPC)을 생성합니다.
명명되지 않은 파이프를 설정하고 파이프의 두 끝을 나타내는 두 개의 파일 설명자(읽기용 pipefd[0] 및 쓰기용 pipefd[1])를 생성합니다.

## 반환 값:

성공하면 '0'을 반환하고 파이프가 성공적으로 생성됩니다.
실패 시 -1을 반환하며 이는 파이프 생성 중 오류를 나타냅니다.

## 간단한 예:

```c
#include <stdio.h>
#include <sys/types.h>
#include <unistd.h>

#define MAX_BUF 128

int main() {
    int n, fd[2]; 
		//n은 읽은 바이트 수, fd는 파이프의 파일 디스크립터
    pid_t pid; 
		//pid_t는 프로세스 ID를 나타내는 데이터 유형입니다
    char buf[MAX_BUF]; 
		//파이프에서 읽은 데이터를 저장할 버퍼

    if (pipe(fd) < 0)  {
				//파이프 생성; fd[0]은 읽기용, fd[1]은 쓰기용
        perror("pipe"); // 파이프 생성 실패 시 오류 메시지 출력
        exit(1); // 오류 코드로 프로그램 종료 
    }

    if ((pid = fork()) < 0)  { 
				// 새로운 프로세스 생성
        perror("fork"); // fork 실패 시 오류 메시지 출력
        exit(1); // 오류 코드로 프로그램 종료
    } 
		else if (pid == 0)  { 
				// 자식 프로세스
        close(fd[1]); // 자식 프로세스에서 파이프의 쓰기 단을 닫음
        printf("자식: 부모가 데이터를 보낼 때까지 대기\n");
        if ((n = read(fd[0], buf, MAX_BUF)) < 0)  { 
						// 파이프에서 데이터 읽기
            perror("read"); // 읽기 실패 시 오류 메시지 출력
            exit(1); // 오류 코드로 프로그램 종료
        }
        printf("자식: 부모로부터 받은 데이터: ");
        fflush(stdout); // 출력 버퍼를 비움
        write(STDOUT_FILENO, buf, n); // 받은 데이터를 표준 출력
    } else  { // 부모 프로세스
        close(fd[0]); // 부모 프로세스에서 파이프의 읽기 단을 닫음
        strcpy(buf, "안녕, 세상!\n"); // 버퍼에 메시지를 복사
        printf("부모: 자식에게 데이터를 보냄\n");
				//null 캐릭터도 추가해야하므로 +1을 해준다
        write(fd[1], buf, strlen(buf) + 1); 
				// 자식 프로세스가 읽을 데이터를 파이프에 씀
    }

    exit(0); // 프로그램 종료
}
```

## pipe를 사용해야 하는 경우:

'파이프' 기능은 관련된 두 프로세스 간의 단방향 통신 채널을 설정하는 데 사용됩니다.
상위 프로세스와 하위 프로세스 간에 또는 파이프라인의 서로 다른 프로세스 간에 정보를 전달해야 할 때 일반적으로 사용됩니다.
예를 들어 셸 명령과 같이 일련의 연결된 작업에서 한 프로세스의 출력을 다른 프로세스의 입력으로 리디렉션하려는 시나리오에서 파이프를 사용할 수 있습니다.

## 응용

```c
#include <stdio.h>
#include <sys/types.h>
#include <unistd.h>

static int	Pfd1[2], Pfd2[2];

void
TELL_WAIT(void)
{
	if (pipe(Pfd1) < 0 || pipe(Pfd2) < 0)  {
// Pfd1가 안만들어졌으면 참인지 -> pfd2가 참인지 확인, 
// 이미 pfd1이 안만들어지면 끝
// 만들어졌으면 pfd2확인
// 하나는 parent -> child
// 하나는 child->parent
		perror("pipe");
		exit(1);
	}
}
void
TELL_PARENT(void)
{
	// 기다렸다 깨어나는 용도로 한다
	if (write(Pfd2[1], "c", 1) != 1)  {
		perror("write");
		exit(1);
	}
}
void
WAIT_PARENT(void)
{
	// read하는 코드
	char	c;
	if (read(Pfd1[0], &c, 1) != 1)  {
		perror("read");
		exit(1);
	}
	if (c != 'p')  {
		fprintf(stderr, "WAIT_PARENT: incorrect data");
		exit(1);
	}
}
void
TELL_CHILD(void)
{
	if (write(Pfd1[1], "p", 1) != 1)  {
		perror("write");
		exit(1);
	}
}
void
WAIT_CHILD(void)
{
	char	c;

	if (read(Pfd2[0], &c, 1) != 1)  {
		perror("read");
		exit(1);
	}
	if (c != 'c')  {
		fprintf(stderr, "WAIT_CHILD: incorrect data");
		exit(1);
	}
}
```

첫 번째 코드 블록은 양방향 통신을 위해 단일 파이프를 사용합니다.
두 번째 코드 블록은 두 개의 별도 파이프를 사용하여 상위 프로세스와 하위 프로세스 간의 신호 또는 동기화를 위한 별도의 통신 채널을 설정하여 명확하고 분리된 상태를 보장합니다.

/end

# dup

## 머리글:

```c
#include <unistd.h>
```

## 기능 프로토타입:

```c
int dup(int oldfd);
```

## 매개변수:

oldfd: 복제할 파일 설명자를 지정합니다.

## 설명:

dup 함수는 파일 설명자 oldfd를 복제합니다.
원본 oldfd와 동일한 열린 파일 설명을 참조하는 새 파일 설명자를 반환합니다.
dup에 의해 반환된 새 파일 설명자는 사용 가능한 가장 낮은 파일 설명자 번호입니다.

## 반환 값:

성공 시 새 파일 설명자를 반환합니다.
오류 시 '-1'을 반환합니다.

## 간단한 예시

```c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>

int main() {
    int fd[2];
    pid_t child;

    if (pipe(fd) == -1) {
        perror("pipe");
        exit(1);
    }

    child = fork();
    if (child == (pid_t)(-1)) {
        perror("fork");
        exit(1);
    } else if (child == (pid_t)0) {
				//dup가 지금 사용하지 않는 것과 duplciate 하므로 1을 먼저 close해야한다
        close(1);
        close(fd[0]);
        
				// 파이프의 쓰기 끝을 가르키게 됨
        if (dup(fd[1]) == -1) {
            perror("dup");
            exit(1);
        }
        
        if ((execlp("ls", "ls", "-l", NULL)) == -1) {
            perror("execlp");
            exit(1);
        }
    } else {
				//dup가 지금 사용하지 않는 것과 duplciate 하므로 0을 먼저 close해야한다
        close(0);
        close(fd[1]);
        
				// 0 이 fd[0]을 가르키게 됨
        if (dup2(fd[0], 0) == -1) {
            perror("dup2");
            exit(1);
        }
        
        if ((execlp("more", "more", NULL)) == -1) {
            perror("execlp");
            exit(1);
        }
    }

    return 0;
}
```

1. pipe(fd):

파일 디스크립터 fd[0]는 읽기용, fd[1]은 쓰기용으로 사용되는 파이프를 생성합니다.

2. fork():

자식 프로세스가 ls -l을 실행하고 부모 프로세스가 more를 실행합니다.

3. 자식 프로세스 (ls -l 실행):

표준 출력을 닫습니다 (close(1)).
파이프의 읽기 끝을 닫습니다 (close(fd[0])).
파이프의 쓰기 끝을 표준 출력으로 복제합니다 (dup(fd[1])), 이로써 표준 출력이 파이프의 쓰기 끝을 가리키도록 합니다.
execlp를 사용하여 ls -l을 실행합니다.

4. 부모 프로세스 (more 실행):

표준 입력을 닫습니다 (close(0)).
파이프의 쓰기 끝을 닫습니다 (close(fd[1])).
파이프의 읽기 끝을 표준 입력으로 복제합니다 (dup2(fd[0], 0)), 이로써 표준 입력이 파이프의 읽기 끝을 가리키도록 합니다.
execlp를 사용하여 more를 실행합니다.
이 코드는 ls -l의 출력을 more의 입력으로 전달하는 파이프라인을 설정합니다. 그러나 dog가 아닌 perror와 추가적인 닫는 중괄호 등 몇 가지 문법 오류가 있으므로 코드가 올바르게 컴파일되고 실행되려면 수정해야 합니다.

/end

# dup2

## 머리글:

```c
#include <unistd.h>
```

## 기능 프로토타입:

```c
int dup2(int oldfd, int newfd);
```

### 매개변수:

- **`oldfd`**: 복제할 파일 설명자.
- **`newfd`**: **`oldfd`**가 복사되어야 하는 파일 설명자입니다.

### 설명:

- **`dup2`** 함수는 파일 설명자 **`oldfd`**를 설명자 **`newfd`**에 복제합니다.
- **`newfd`**가 이미 열려 있는 경우 **`dup2`**는 **`oldfd`**를 복제하기 전에 이를 닫습니다.
- **`oldfd`**가 **`newfd`**와 동일한 파일이나 리소스를 참조하는지 확인합니다.
- **`oldfd`**와 **`newfd`**가 동일한 경우 **`dup2`**는 아무 작업도 수행하지 않고 **`newfd`**를 반환합니다.
- 성공 시 새 파일 설명자를 반환하고, 오류 시 **`1`**을 반환합니다.

### 반환 값:

- 성공하면 새 파일 설명자를 반환합니다.
- 실패 시 **`1`**을 반환하고 **`errno`**를 설정합니다.

### 예:

```c
#include <unistd.h>
#include <stdio.h>
#include <stdlib.h>
#include <sys/stat.h>
#include <string.h>
#include <fcntl.h>

int main(void){
        int fd1, ret;
        char message[32]={"STDERR from fd1\n"};

        //그림 1번
        fd1=open("made_by_fd1",O_RDWR|O_CREAT, S_IRUSR|S_IWUSR);
        if(fd1<0){
                printf("file open error\n");
                exit(0);
        }
        //표준 입출력으로 print됨
        printf("file open\n");

        //fd1의 파일 디스크립터가 명시한 STDOUT_FILENO의 파일 디스크립터로
        //복제됨,
        //그림 2번
        ret=dup2(fd1,STDOUT_FILENO);

        //fd1으로 출력됨
        printf("fd1 :%d, ret:%d\n",fd1,ret);

        //STDERR_FILENO 디스크립터가 명시된 fd1으로 복제됨
        //그림 3번
        ret=dup2(STDERR_FILENO,fd1);

        //fd1은 에러로 출력됨
        write(fd1,message,strlen(message));

        //stdout이 file로 써짐
        printf("printf를 썼지만 파일에 기록됨 \n");

        close(fd1);

}
```

![img1.daumcdn.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/dfa28d76-5333-40b3-9780-fbbeab3c8ca0/db83bea8-7733-4ec7-9379-2b37d6dea52b/img1.daumcdn.png)

/end

# FIFO

- 파이프와 유사하지만 일반 파일처럼 파일 시스템의 특정한 파일명으로 통신 채널을 지정한다는 차이점이 있습니다. 일반 파일과의 차이점은 **두 프로세스가 동시에 FIFO를 열어야 동작**할 수 있습니다. 예를 들어 FIFO를 O_RDONLY 모드로 생성하는 프로세스는 FIFO를 O_WRONLY 모드로 생성하는 프로세스가 동작할 때 까지 대기하게 됩니다. 통상 정상 동작하면 0, 실패하면 -1을 리턴합니다.

# mkfifo

## 머리글:

```c
#include <sys/types.h>
#include <sys/stat.h>
```

## 기능 프로토타입:

```c
int mkfifo(const char *pathname, mode_t mode);
```

## 매개변수:

- **`pathname`**: 생성할 FIFO(Named Pipe)의 경로입니다.
- **`모드`**: 생성된 FIFO의 권한/모드입니다.

### 설명:

- **`mkfifo`** 함수는 주어진 **`pathname`**을 사용하여 FIFO(명명된 파이프)를 생성합니다.
- FIFO는 관련되지 않은 프로세스의 통신을 허용하는 특수 파일입니다.
- **`mode`**는 **`chmod`** 명령과 유사한 방식으로 생성된 FIFO의 권한을 지정합니다(예: 소유자의 읽기 권한에 대한 **`S_IRUSR`**).
- FIFO가 이미 존재하는 경우 **`O_EXCL`** 플래그가 설정되지 않으면 **`mkfifo`**는 성공을 반환합니다.

### 반환 값:

- 성공 시 '0'을 반환합니다.
- 실패 시 **`1`**을 반환하고 **`errno`**를 설정하여 오류를 나타냅니다.

### 예

## fifos.c

```c
#include <stdio.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <unistd.h>
#include <signal.h>
#include <errno.h>
#include "fifo.h"

void
SigIntHandler(int signo)
{
	if (remove(SERV_FIFO) < 0)  {
		perror("remove");
		exit(1);
	}

	exit(0);
}

main()
{
	int			fd, cfd, n;
	MsgType		msg;

	if (signal(SIGINT, SigIntHandler) == SIG_ERR)  {
		perror("signal");
		exit(1);
	}

	if (mkfifo(SERV_FIFO, 0600) < 0)  {
		if (errno != EEXIST)  {
			perror("mkfifo");
			exit(1);
		}
	}

	if ((fd = open(SERV_FIFO, O_RDWR)) < 0)  {
		perror("open");
		exit(1);
	}

	while (1)  {
		if ((n = read(fd, (char *)&msg, sizeof(msg))) < 0)  {
			if (errno == EINTR)  {
				continue;
			}
			else  {
				perror("read");
				exit(1);
			}
		}
		printf("Received request: %s.....", msg.data);
		// ./.fifo123 열기
		if ((cfd = open(msg.returnFifo, O_WRONLY)) < 0)  {
			perror("open");
			exit(1);
		}
		sprintf(msg.data, "This is a reply from %d.", getpid());
		write(cfd, (char *)&msg, sizeof(msg));
		close(cfd);
		printf("Replied.\n");
	~~~~}
}
```

## fifoc.c

```c
#include <stdio.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <unistd.h>
#include <errno.h>
#include "fifo.h"

main()
{
	char		fname[MAX_FIFO_NAME];
	int			fd, sfd, n;
	MsgType		msg;

	sprintf(fname, ".fifo%d", getpid());
	if (mkfifo(fname, 0600) < 0)  {
		perror("mkfifo");
		exit(1);
	}

	if ((fd = open(fname, O_RDWR)) < 0)  {
		perror("open");
		exit(1);
	}
	if ((sfd = open(SERV_FIFO, O_RDWR)) < 0)  {
		perror("open");
		exit(1);
	}

	strcpy(msg.returnFifo, fname);
	sprintf(msg.data, "This is a request from %d.", getpid());
	write(sfd, (char *)&msg, sizeof(msg));
	printf("Sent a request.....");

	if ((n = read(fd, (char *)&msg, sizeof(msg))) < 0)  {
		perror("read");
		exit(1);
	}

	printf("Received reply: %s\n", msg.data);

	close(fd);
	close(sfd);

	if (remove(fname) < 0)  {
		perror("remove");
		exit(1);
	}
}
```

fifos 에서 SERV_FIFO로 서버 fifo를 만든다 → 기다림 

fifoc에서 serv_fifo 열어서 메세지를 씀 → 메세지 안에는 클라이언트 피포의 이름을 적음. 

fifos에서 serv_fifo에 온 메세지 읽고 받은다음에  클라이언트 피포에다가 적음. 

fifoc에서 받아서 출력

/end

# shmget

머리글:

```c
#include <sys/types.h>
#include <sys/ipc.h>
#include <sys/shm.h>
```

shmget 함수는 공유 메모리 식별자(ID)를 얻기 위해 사용됩니다. 아래는 함수의 원형입니다.

```c
int shmget(key_t key, int size, int flag);
```

- key는 공유 메모리 세그먼트를 식별하는 키입니다. ftok() 함수를 사용하거나 고유한 식별자를 사용할 수 있습니다.
- size는 공유 메모리 세그먼트의 크기를 지정합니다. 새로운 세그먼트를 생성하는 경우 크기를 지정해야 합니다. 기존 세그먼트를 참조하는 경우 크기를 0으로 지정할 수 있습니다.
- flag는 공유 메모리 세그먼트의 권한과 플래그를 지정합니다.
함수는 성공하면 공유 메모리 ID를 반환하고, 오류 발생 시 -1을 반환합니다.

## 사용 예:

```c
#define	MY_ID		0
#define	SHM_KEY		(0x9000 + MY_ID)
#define	SHM_SIZE	1024
#define	SHM_MODE	(SHM_R | SHM_W | IPC_CREAT)
```

```c
#include <stdio.h>
#include <sys/types.h>
#include <sys/ipc.h>
#include <sys/shm.h>

#define ARRAY_SIZE      40000
#define MALLOC_SIZE     100000
#define SHM_SIZE        100000
#define SHM_MODE        (SHM_R | SHM_W)

char    Array[ARRAY_SIZE];

main()
{
        int             shmid;
        char    *ptr, *shmptr;

        if ((ptr = (char *)malloc(MALLOC_SIZE)) == NULL)  {
                perror("malloc");
                exit(1);
        }

        if ((shmid = shmget(IPC_PRIVATE, SHM_SIZE, SHM_MODE)) < 0)  {
                perror("shmget");
                exit(1);
        }
        if ((shmptr = shmat(shmid, 0, 0)) == (void *) -1)  {
                perror("shmat");
                exit(1);
        }

        printf("Array[] from %p to %p\n", &Array[0], &Array[ARRAY_SIZE]);
        printf("Stack around %p\n", &shmid);
        printf("Malloced from %p to %p\n", ptr, ptr+MALLOC_SIZE);
        printf("Shared memory attached from %p to %p\n", shmptr, shmptr+SHM_SIZE);

        if (shmctl(shmid, IPC_RMID, 0) < 0)  {
                perror("shmctl");
                exit(1);
        }
}
```

/end

# shmctl

shmctl 함수는 공유 메모리 제어 작업을 위해 사용됩니다. 아래는 함수의 원형입니다.

```c
int shmctl(int shmid, int cmd, struct shmid_ds *buf);
```

shmid는 shmget으로 얻은 공유 메모리 ID입니다.
cmd는 공유 메모리 세그먼트에 대해 수행할 명령을 지정합니다.
buf는 공유 메모리 세그먼트에 관한 정보를 담고 있는 shmid_ds 구조체에 대한 포인터입니다.

shmctl에서 중요한 명령 중 하나는 IPC_RMID입니다. 이 명령은 시스템에서 공유 메모리 세그먼트를 제거하는 데 사용됩니다. shmctl과 함께 이 명령을 사용하면 제공된 shmid와 연결된 공유 메모리 세그먼트를 시스템에서 할당 해제합니다.

IPC_STAT: 공유 메모리 세그먼트에 대한 정보를 가져와 shmid_ds 구조에 저장합니다.
IPC_SET: 공유 메모리 세그먼트에 대한 shmid_ds 구조에 정보를 설정합니다.
IPC_RMID: 공유 메모리 세그먼트를 제거합니다.

## 머리글:

```c
#include <sys/types.h>
#include <sys/ipc.h>
#include <sys/msg.h>
```

## 공유 메모리 세그먼트를 제거하는 사용법 예:

```c
#include <stdio.h>
#include <sys/types.h>
#include <sys/ipc.h>
#include <sys/shm.h>

#define ARRAY_SIZE      40000
#define MALLOC_SIZE     100000
#define SHM_SIZE        100000
#define SHM_MODE        (SHM_R | SHM_W)

char    Array[ARRAY_SIZE];

main()
{
        int             shmid;
        char    *ptr, *shmptr;

        if ((ptr = (char *)malloc(MALLOC_SIZE)) == NULL)  {
                perror("malloc");
                exit(1);
        }

        if ((shmid = shmget(IPC_PRIVATE, SHM_SIZE, SHM_MODE)) < 0)  {
                perror("shmget");
                exit(1);
        }
        if ((shmptr = shmat(shmid, 0, 0)) == (void *) -1)  {
                perror("shmat");
                exit(1);
        }

        printf("Array[] from %p to %p\n", &Array[0], &Array[ARRAY_SIZE]);
        printf("Stack around %p\n", &shmid);
        printf("Malloced from %p to %p\n", ptr, ptr+MALLOC_SIZE);
        printf("Shared memory attached from %p to %p\n", shmptr, shmptr+SHM_SIZE);

        if (shmctl(shmid, IPC_RMID, 0) < 0)  {
                perror("shmctl");
                exit(1);
        }
}
```

```c
#define	MY_ID		0
#define	SHM_KEY		(0x9000 + MY_ID)
#define	SHM_SIZE	1024
#define	SHM_MODE	(SHM_R | SHM_W | IPC_CREAT)
```

```c
#include <stdio.h>
#include <sys/types.h>
#include <sys/ipc.h>
#include <sys/shm.h>
#include "shm.h"

main()
{
	int		shmid;
	char	*ptr, *pData;
	int		*pInt;

	if ((shmid = shmget(SHM_KEY, SHM_SIZE, SHM_MODE)) < 0)  {
		perror("shmget");
		exit(1);
	}
	if ((ptr = shmat(shmid, 0, 0)) == (void *) -1)  {
		perror("shmat");
		exit(1);
	}

	pInt = (int *)ptr;
	while ((*pInt) == 0)
		;

	pData = ptr + sizeof(int);
	printf("Received request: %s.....", pData);
	sprintf(pData, "This is a reply from %d.", getpid());
	*pInt = 0;
	printf("Replied.\n");

	sleep(1);

	if (shmctl(shmid, IPC_RMID, 0) < 0)  {
		perror("shmctl");
		exit(1);
	}
}
```

/end

# shmat

shmat은 호출 프로세스의 주소 공간에 공유 메모리 세그먼트를 연결하는 데 사용됩니다.

## 헤더:

```c
#include <sys/types.h>
#include <sys/ipc.h>
#include <sys/shm.h>
```

## 프로토타입:

```c
void *shmat(int shmid, void *addr, int flag);
```

## 반환값:

성공 시, 연결된 공유 메모리 세그먼트의 포인터를 반환합니다.
오류 시, -1을 반환합니다.

## 설명:

shmid는 shmget으로 얻은 공유 메모리 세그먼트의 ID입니다.
addr은 세그먼트를 연결할 주소를 지정합니다.
flag는 세그먼트를 연결하는 옵션을 제공합니다.

예시:

```c
#include <stdio.h>
#include <sys/types.h>
#include <sys/ipc.h>
#include <sys/shm.h>
#include "shm.h"

main()
{
	int		shmid;
	char	*ptr, *pData;
	int		*pInt;

	if ((shmid = shmget(SHM_KEY, SHM_SIZE, SHM_MODE)) < 0)  {
		perror("shmget");
		exit(1);
	}
	if ((ptr = shmat(shmid, 0, 0)) == (void *) -1)  {
		perror("shmat");
		exit(1);
	}

	pInt = (int *)ptr;
	while ((*pInt) == 0)
		;

	pData = ptr + sizeof(int);
	printf("Received request: %s.....", pData);
	sprintf(pData, "This is a reply from %d.", getpid());
	*pInt = 0;
	printf("Replied.\n");

	sleep(1);

	if (shmctl(shmid, IPC_RMID, 0) < 0)  {
		perror("shmctl");
		exit(1);
	}
}
```

이 예제는 공유 메모리 세그먼트를 생성하고, 커널이 선택한 주소(NULL)에 프로세스 주소 공간에 연결하고, 공유 메모리를 사용한 후 shmdt를 사용하여 연결을 해제합니다.

/end

# shmdt

shmdt는 호출 프로세스의 주소 공간에서 공유 메모리 세그먼트를 연결 해제하는 데 사용됩니다.

## 헤더:

```c
#include <sys/types.h>
#include <sys/ipc.h>
#include <sys/shm.h>
```

## 프로토타입:

```c
int shmdt(void *addr);
```

## 반환값:

성공 시, 0을 반환합니다.
오류 시, -1을 반환합니다.

## 설명:

addr은 연결을 해제할 공유 메모리 세그먼트의 시작 주소입니다.

예시: (프로그램 내에서의 사용법은 이전 예시를 참고하세요.)

## 코드

```c
// ...
void *shared_memory = shmat(shmid, NULL, 0); // 세그먼트 연결

// ... (공유 메모리 사용)

if (shmdt(shared_memory) == -1) { // 세그먼트 연결 해제
perror("shmdt");
return -1;
}
```

이 함수들은 프로세스가 공유 메모리 세그먼트를 연결하고 연결을 해제하여 여러 프로세스 간의 메모리 영역을 효율적으로 공유할 수 있게 합니다.

/end

# mmap

mmap 함수는 파일을 메모리에 매핑하거나 새로운 메모리 매핑을 생성합니다.

헤더:

```c
#include <sys/types.h>
#include <sys/mman.h>
```

프로토타입:

```c
caddr_t mmap(caddr_t addr, size_t len, int prot, int flags, int fd, off_t off);
```

반환값:
성공 시, 매핑된 영역의 시작 주소를 반환합니다.
오류 시, -1을 반환합니다.

설명:
addr은 매핑된 영역의 시작 주소를 지정합니다. 0일 경우 시스템이 시작 주소를 선택하도록 합니다.
len은 매핑할 영역의 크기를 지정합니다.
prot은 메모리 영역에 대한 보호 모드를 지정합니다. (PROT_READ, PROT_WRITE, PROT_EXEC, PROT_NONE 등)
flags는 매핑된 메모리의 특성을 설정합니다. (MAP_FIXED, MAP_SHARED, MAP_PRIVATE 등)
fd는 파일 디스크립터입니다.
off는 파일에서 오프셋을 지정합니다.

예시:

```c
#include <stdio.h>
#include <fcntl.h>
#include <sys/types.h>
#include <sys/mman.h>
#include <unistd.h>

#define FILE_SIZE 4096

int main() {
	int fd;
	char *mapped;
	fd = open("example.txt", O_RDWR); // 파일 열기
	if (fd == -1) {
	    perror("open");
	    return -1;
	}
	
	mapped = mmap(0, FILE_SIZE, PROT_READ | PROT_WRITE, MAP_SHARED, fd, 0); // 파일 매핑
	if (mapped == MAP_FAILED) {
	    perror("mmap");
	    return -1;
	}
	
	// 매핑된 메모리에 접근하여 데이터 쓰기
	sprintf(mapped, "This is a test.");
	
	// 매핑 해제
	if (munmap(mapped, FILE_SIZE) == -1) {
	    perror("munmap");
	    return -1;
	}
	
	close(fd); // 파일 닫기
	
	return 0;
}
```

이 예제는 파일을 열고 해당 파일을 메모리에 매핑한 후 매핑된 메모리에 데이터를 쓰고, 매핑을 해제하는 간단한 과정을 보여줍니다. 실제 프로그램에서는 오류 처리와 동기화를 고려해야 합니다.

⇒ 버츄얼 어드레스 할당

## mycp3.c

```c
#include <stdio.h>
#include <sys/types.h>
#include <sys/mman.h>
#include <sys/stat.h>
#include <fcntl.h>

main(int argc, char *argv[])
{
	int			fdin, fdout;
	char		*src, *dst;
	struct stat	statbuf;

	if (argc != 3)  {
		fprintf(stderr, "Usage: %s source destination\n", argv[0]);
		exit(1);
	}

	if ((fdin = open(argv[1], O_RDONLY)) < 0)  {
		perror("open");
		exit(1);
	}
	if ((fdout = open(argv[2], O_RDWR | O_CREAT | O_TRUNC, 0644)) < 0)  {
		perror("open");
		exit(1);
	}

	if (fstat(fdin, &statbuf) < 0)  {
		perror("fstat");
		exit(1);
	}
	if (lseek(fdout, statbuf.st_size-1, SEEK_SET) < 0)  {
		perror("lseek");
		exit(1);
	}
	write(fdout, "", 1);

	if ((src = mmap(0, statbuf.st_size, PROT_READ, MAP_SHARED, fdin, 0)) 
		== (caddr_t) -1)  {
		perror("mmap");
		exit(1);
	}
	if ((dst = mmap(0, statbuf.st_size, PROT_WRITE, MAP_SHARED, fdout, 0)) 
		== (caddr_t) -1)  {
		perror("mmap");
		exit(1);
	}

	memcpy(dst, src, statbuf.st_size);

	close(fdin);
	close(fdout);
}
```

이 프로그램은 파일 복사를 수행하는데 메모리 매핑을 활용합니다.

소스(argv[1]) 파일을 읽기 전용 모드로 열고 대상(argv[2]) 파일을 읽기/쓰기 모드로 엽니다.
fstat을 사용하여 소스 파일의 크기를 확인하고 대상 파일의 크기를 설정합니다.
mmap을 사용하여 소스는 PROT_READ, 대상은 PROT_WRITE로 메모리에 매핑합니다.
memcpy를 사용하여 소스 메모리 매핑의 내용을 대상으로 복사합니다.
파일 디스크립터를 닫습니다.

이 프로그램은 파일 입출력에 메모리 매핑을 활용하여 대용량 파일 복사를 수행합니다.

## mips.c

```c
#include <stdio.h>
#include <sys/types.h>
#include <sys/mman.h>
#include <fcntl.h>
#include "synclib.h"

#define	NLOOPS	10
#define	SIZE	sizeof(long)

int
update(long *ptr)
{
	return ((*ptr)++);
}

main()
{
	int		fd, i, counter;
	pid_t	pid;
	caddr_t	area;

	if ((fd = open("/dev/zero", O_RDWR)) < 0)  {
		perror("open");
		exit(1);
	}
	if ((area = mmap(0, SIZE, PROT_READ | PROT_WRITE, MAP_SHARED, fd, 0))
		== (caddr_t) -1)  {
		perror("mmap");
		exit(1);
	}
	close(fd);

	TELL_WAIT();
	if ((pid = fork()) < 0)  {
		perror("fork");
		exit(1);
	}
	else if (pid > 0)  {
		for (i = 0 ; i < NLOOPS ; i += 2)  {
			if ((counter = update((long *) area)) != i)  {
				fprintf(stderr, "Counter mismatch\n");
				exit(1);
			}
			printf("Parent: counter=%d\n", counter);
			TELL_CHILD();
			WAIT_CHILD();
		}
	}
	else  {
		for (i = 1 ; i < NLOOPS ; i += 2)  {
			WAIT_PARENT();
			if ((counter = update((long *) area)) != i)  {
				fprintf(stderr, "Counter mismatch\n");
				exit(1);
			}
			printf("Child : counter=%d\n", counter);
			TELL_PARENT();
		}
	}
}
```

이 프로그램은 메모리 매핑을 사용한 프로세스간 통신(IPC)을 보여줍니다.

/dev/zero 파일을 열어 무한의 널 바이트 스트림을 얻습니다.
mmap을 사용하여 부모와 자식 프로세스가 공유하는 메모리 영역을 생성합니다(PROT_READ | PROT_WRITE).
부모와 자식 프로세스가 번갈아가며 메모리 내의 값을 증가시키고, TELL_WAIT, TELL_CHILD, WAIT_CHILD, WAIT_PARENT, TELL_PARENT 함수를 사용하여 서로 알리고 동기화합니다.

이 예제는 메모리 매핑을 사용하여 다중 프로세스 간 통신 및 동기화를 구현하는 방법을 보여줍니다. 이는 프로세스 간의 데이터 공유와 통신에 유용합니다.

/end

# prodcons

```c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <pthread.h>
#include <sys/time.h>
#include "prodcons.h"

BoundedBufferType	Buf;

void
ThreadUsleep(int usecs)
{
	pthread_cond_t		cond;
	pthread_mutex_t		mutex;
	struct timespec		ts;
	struct timeval		tv;

	if (pthread_cond_init(&cond, NULL) < 0)  {
		perror("pthread_cond_init");
		pthread_exit(NULL);
	}
	if (pthread_mutex_init(&mutex, NULL) < 0)  {
		perror("pthread_mutex_init");
		pthread_exit(NULL);
	}

	gettimeofday(&tv, NULL);
	ts.tv_sec = tv.tv_sec + usecs/1000000;
	ts.tv_nsec = (tv.tv_usec + (usecs%1000000)) * 1000;
	if (ts.tv_nsec >= 1000000000)  {
		ts.tv_nsec -= 1000000000;
		ts.tv_sec++;
	}

	if (pthread_mutex_lock(&mutex) < 0)  {
		perror("pthread_mutex_lock");
		pthread_exit(NULL);
	}
	if (pthread_cond_timedwait(&cond, &mutex, &ts) < 0)  {
		perror("pthread_cond_timedwait");
		pthread_exit(NULL);
	}

	if (pthread_cond_destroy(&cond) < 0)  {
		perror("pthread_cond_destroy");
		pthread_exit(NULL);
	}
	if (pthread_mutex_destroy(&mutex) < 0)  {
		perror("pthread_mutex_destroy");
		pthread_exit(NULL);
	}
}

void
Producer(void *dummy)
{
	int		i, data;

	printf("Producer: Start.....\n");

	for (i = 0 ; i < NLOOPS ; i++)  {
		if (Buf.counter == MAX_BUF)  {
			printf("Producer: Buffer full. Waiting.....\n");
			while (Buf.counter == MAX_BUF)
				;
		}

		printf("Producer: Producing an item.....\n");
		data = (rand()%100)*10000;
		Buf.buf[Buf.in].data = data;
		Buf.in = (Buf.in + 1) % MAX_BUF;
		Buf.counter++;

		ThreadUsleep(data);
	}

	printf("Producer: Produced %d items.....\n", i);
	printf("Producer: %d items in buffer.....\n", Buf.counter);
	
	pthread_exit(NULL);
}

void
Consumer(void *dummy)
{
	int		i, data;

	printf("Consumer: Start.....\n");

	for (i = 0 ; i < NLOOPS ; i++)  {
		if (Buf.counter == 0)  {
			printf("Consumer: Buffer empty. Waiting.....\n");
			while (Buf.counter == 0)
				;
		}

		printf("Consumer: Consuming an item.....\n");
		data = Buf.buf[Buf.out].data;
		Buf.out = (Buf.out + 1) % MAX_BUF;
		Buf.counter--;

		ThreadUsleep((rand()%100)*10000);
	}

	printf("Consumer: Consumed %d items.....\n", i);
	printf("Consumer: %d items in buffer.....\n", Buf.counter);

	pthread_exit(NULL);
}

main()
{
	pthread_t	tid1, tid2;

	srand(0x8888);

	if (pthread_create(&tid1, NULL, (void *)Producer, (void *)NULL) < 0)  {
		perror("pthread_create");
		exit(1);
	}

	if (pthread_create(&tid2, NULL, (void *)Consumer, (void *)NULL) < 0)  {
		perror("pthread_create");
		exit(1);
	}

	if (pthread_join(tid1, NULL) < 0)  {
		perror("pthread_join");
		exit(1);
	}
	if (pthread_join(tid2, NULL) < 0)  {
		perror("pthread_join");
		exit(1);
	}

	printf("Main    : %d items in buffer.....\n", Buf.counter);
}
```

# producer

```c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/ipc.h>
#include <sys/shm.h>
#include "prodcons.h"

main()
{
	BoundedBufferType	*pBuf;
	int					shmid, i, data;

	if ((shmid = shmget(SHM_KEY, SHM_SIZE, SHM_MODE)) < 0)  {
		perror("shmget");
		exit(1);
	}
	if ((pBuf = (BoundedBufferType *)shmat(shmid, 0, 0)) == (void *) -1)  {
		perror("shmat");
		exit(1);
	}

	srand(0x8888);
	for (i = 0 ; i < NLOOPS ; i++)  {
		if (pBuf->counter == MAX_BUF)  {
			printf("Producer: Buffer full. Waiting.....\n");
			while (pBuf->counter == MAX_BUF)
				;
		}

		printf("Producer: Producing an item.....\n");
		data = (rand()%100)*10000;
		pBuf->buf[pBuf->in].data = data;
		pBuf->in = (pBuf->in + 1) % MAX_BUF;
		pBuf->counter++;

		usleep(data);
	}

	printf("Producer: Produced %d items.....\n", i);

	sleep(2);
	printf("Producer: %d items in buffer.....\n", pBuf->counter);
	
	if (shmctl(shmid, IPC_RMID, 0) < 0)  {
		perror("shmctl");
		exit(1);
	}
}
```

# consumer

```c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/ipc.h>
#include <sys/shm.h>
#include "prodcons.h"

main()
{
	BoundedBufferType	*pBuf;
	int					shmid, i, data;

	if ((shmid = shmget(SHM_KEY, SHM_SIZE, SHM_MODE)) < 0)  {
		perror("shmget");
		exit(1);
	}
	if ((pBuf = (BoundedBufferType *)shmat(shmid, 0, 0)) == (void *) -1)  {
		perror("shmat");
		exit(1);
	}

	srand(0x9999);
	for (i = 0 ; i < NLOOPS ; i++)  {
		if (pBuf->counter == 0)  {
			printf("Consumer: Buffer empty. Waiting.....\n");
			while (pBuf->counter == 0)
				;
		}

		printf("Consumer: Consuming an item.....\n");
		data = pBuf->buf[pBuf->out].data;
		pBuf->out = (pBuf->out + 1) % MAX_BUF;
		pBuf->counter--;

		usleep((rand()%100)*10000);
	}

	printf("Consumer: Consumed %d items.....\n", i);
	printf("Consumer: %d items in buffer.....\n", pBuf->counter);
}
```

/end

# Semaphore

## 세마포어 설정을 위한 시스템 콜

**세마포어 세트 ID 획득**

int semget(key_t key, int nsems, int flag);
세마포어 세트의 ID를 획득하는 함수.
성공 시 세마포어 ID를 반환하고, 실패 시 -1을 반환합니다.

**세마포어 제어 작업**

int semctl(int semid, int semnum, int cmd, union semun arg);
세마포어에 대한 제어 작업을 수행하는 함수.
성공 시 명령에 따라 의존하는 양수값을 반환하고, 실패 시 -1을 반환합니다.

**세마포어 연산**

int semop(int semid, struct sembuf semop[], size_t nops);
세마포어 연산을 수행하는 함수.
성공 시 0을 반환하고, 실패 시 -1을 반환합니다.

**세마포어 제어 작업의 명령어(cmd)와 인자(union semun)**
IPC_STAT: 세마포어 세트의 정보를 가져옵니다.

IPC_SET: 세마포어 세트의 속성을 설정합니다.

IPC_RMID: 시스템으로부터 세마포어 세트를 삭제합니다.

GETVAL: 세마포어 값을 반환합니다.

SETVAL: 세마포어 값을 설정합니다.

GETPID: 마지막으로 세마포어에 접근한 프로세스의 PID를 가져옵니다.

GETNCNT: 세마포어 증가를 기다리는 프로세스의 수를 반환합니다.

GETZCNT: 세마포어가 0이 될 때까지 기다리는 프로세스의 수를 반환합니다.

GETALL: 세마포어 세트 내 모든 세마포어 값을 가져옵니다.

SETALL: 세마포어 세트 내 모든 세마포어 값을 설정합니다.

union semun: semctl 함수의 네 번째 인자로 사용되는 구조체 유니언.

int val;: SETVAL을 위한 값.
struct semid_ds *buf;: IPC_STAT 및 IPC_SET을 위한 semid_ds 구조체.
ushort *array;: GETALL 및 SETALL을 위한 세마포어 값 배열.

## 세마포어 연산에 대한 세마포어 구조체 (struct sembuf)

struct sembuf:
ushort sem_num;: 세마포어 세트 내 세마포어 멤버 번호 (0, 1, ..., nsems-1).
short sem_op;: 세마포어 연산 (-, 0, +).
short sem_flg;: IPC_NOWAIT, SEM_UNDO.

세마포어 연산에서 sem_op의 값에 따라 세마포어 값이 증가하거나 감소하며, 해당 값에 따라 프로세스가 대기하거나 반환됩니다. 예를 들어, sem_op이 양수인 경우에는 세마포어 값이 증가하고, 음수인 경우에는 세마포어 값이 감소하며, sem_op이 0이고 세마포어 값이 0이 아닌 경우에는 프로세스가 대기하게 됩니다.

또한, 프로세스가 세마포어를 사용한 후 종료되더라도, SEM_UNDO 플래그를 사용하여 세마포어 조정을 통해 자원을 해제할 수 있습니다.

```c
## semaphore.c

```jsx
#include <stdio.h>
#include "semlib.h"
 
 
int
semInit(key_t key)
{
    int     semid;

    if ((semid = semget(key, 1, 0600 | IPC_CREAT)) < 0)  {
		perror("semget");
        return -1;
    }

    return semid;
}
 
int
semInitValue(int semid, int value)
{
    union semun {
            int     val;
    } semun;

    semun.val = value;
    if (semctl(semid, 0, SETVAL, semun) < 0)  {
		perror("semctl");
        return -1;
    }
 
    return semid;
}
 
int
semWait(int semid)
{
    struct sembuf   semcmd;
 
    semcmd.sem_num = 0;
    semcmd.sem_op = -1;
    semcmd.sem_flg = SEM_UNDO;
    if (semop(semid, &semcmd, 1) < 0)  {
		perror("semop");
        return -1;
    }
 
    return 0;
}
 
int
semTryWait(int semid)
{
    struct sembuf   semcmd;
 
    semcmd.sem_num = 0;
    semcmd.sem_op = -1;
    semcmd.sem_flg = IPC_NOWAIT | SEM_UNDO;
    if (semop(semid, &semcmd, 1) < 0)  {
		perror("semop");
        return -1;
    }
 
    return 0;
}

int
semPost(int semid)
{
    struct sembuf   semcmd;
 
    semcmd.sem_num = 0;
    semcmd.sem_op = 1;
    semcmd.sem_flg = SEM_UNDO;
    if (semop(semid, &semcmd, 1) < 0)  {
		perror("semop");
        return -1;
    }
 
    return 0;
}

int
semGetValue(int semid)
{
    union semun {
            int     val;
    } dummy;
 
    return semctl(semid, 0, GETVAL, dummy);
}
 
int
semDestroy(int semid)
{
    union semun {
            int     val;
    } dummy;
 
    if (semctl(semid, 0, IPC_RMID, dummy) < 0)  {
		perror("semctl");
        return -1;
    }
    close(semid);
 
    return 0;
}
```
```

/end

# semInit

설명 및 반환 값:

```jsx
semInit(key_t 키)
```

설명: 세마포어를 초기화하고 해당 ID를 반환합니다.

반환 값:

성공 시: 세마포어 ID를 반환합니다.
실패 시: -1을 반환합니다.

```c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/ipc.h>
#include <sys/shm.h>
#include "semlib.h"
#include "prodcons.h"

main()
{
	BoundedBufferType	*pBuf;
	int					shmid, i, data;
	int					emptySemid, fullSemid, mutexSemid;

	if ((shmid = shmget(SHM_KEY, SHM_SIZE, SHM_MODE)) < 0)  {
		perror("shmget");
		exit(1);
	}
	if ((pBuf = (BoundedBufferType *)shmat(shmid, 0, 0)) == (void *) -1)  {
		perror("shmat");
		exit(1);
	}

	if ((emptySemid = semInit(EMPTY_SEM_KEY)) < 0)  {
		fprintf(stderr, "semInit failure\n");
		exit(1);
	}
	if ((fullSemid = semInit(FULL_SEM_KEY)) < 0)  {
		fprintf(stderr, "semInit failure\n");
		exit(1);
	}
	if ((mutexSemid = semInit(MUTEX_SEM_KEY)) < 0)  {
		fprintf(stderr, "semInit failure\n");
		exit(1);
	}

	srand(0x8888);
	for (i = 0 ; i < NLOOPS ; i++)  {
		if (semWait(emptySemid) < 0)  {
			fprintf(stderr, "semWait failure\n");
			exit(1);
		}
		if (semWait(mutexSemid) < 0)  {
			fprintf(stderr, "semWait failure\n");
			exit(1);
		}

		printf("Producer: Producing an item.....\n");
		data = (rand()%100)*10000;
		pBuf->buf[pBuf->in].data = data;
		pBuf->in = (pBuf->in + 1) % MAX_BUF;
		pBuf->counter++;

		if (semPost(mutexSemid) < 0)  {
			fprintf(stderr, "semPost failure\n");
			exit(1);
		}
		if (semPost(fullSemid) < 0)  {
			fprintf(stderr, "semPost failure\n");
			exit(1);
		}
		usleep(data);
	}

	printf("Producer: Produced %d items.....\n", i);

	sleep(2);
	printf("Producer: %d items in buffer.....\n", pBuf->counter);
	
	if (semDestroy(emptySemid) < 0)  {
		fprintf(stderr, "semDestroy failure\n");
	}
	if (semDestroy(fullSemid) < 0)  {
		fprintf(stderr, "semDestroy failure\n");
	}
	if (semDestroy(mutexSemid) < 0)  {
		fprintf(stderr, "semDestroy failure\n");
	}
	if (shmctl(shmid, IPC_RMID, 0) < 0)  {
		perror("shmctl");
		exit(1);
	}
}
```

/end

# semInitValue

```jsx
semInitValue(int semid, int value)
```

설명 : 특정 값으로 세마포어를 초기화합니다.

매개변수:

semid: 세마포어 ID.
value: 세마포어의 초기 값입니다.
반환 값:

성공 시: 0을 반환합니다.
실패 시: -1을 반환합니다.

/end

# semWait

```jsx
semWait(int semid)
```

설명: 세마포어에 대해 대기(P 연산)를 수행합니다.

매개변수:

semid: 세마포어 ID.
반환 값:

성공 시: 0을 반환합니다.
실패 시: -1을 반환합니다.

```c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/ipc.h>
#include <sys/shm.h>
#include "semlib.h"
#include "prodcons.h"

main()
{
	BoundedBufferType	*pBuf;
	int					shmid, i, data;
	int					emptySemid, fullSemid, mutexSemid;

	if ((shmid = shmget(SHM_KEY, SHM_SIZE, SHM_MODE)) < 0)  {
		perror("shmget");
		exit(1);
	}
	if ((pBuf = (BoundedBufferType *)shmat(shmid, 0, 0)) == (void *) -1)  {
		perror("shmat");
		exit(1);
	}

	if ((emptySemid = semInit(EMPTY_SEM_KEY)) < 0)  {
		fprintf(stderr, "semInit failure\n");
		exit(1);
	}
	if ((fullSemid = semInit(FULL_SEM_KEY)) < 0)  {
		fprintf(stderr, "semInit failure\n");
		exit(1);
	}
	if ((mutexSemid = semInit(MUTEX_SEM_KEY)) < 0)  {
		fprintf(stderr, "semInit failure\n");
		exit(1);
	}

	if (semInitValue(emptySemid, MAX_BUF) < 0)  {
		fprintf(stderr, "semInitValue failure\n");
		exit(1);
	}
	if (semInitValue(fullSemid, 0) < 0)  {
		fprintf(stderr, "semInitValue failure\n");
		exit(1);
	}
	if (semInitValue(mutexSemid, 1) < 0)  {
		fprintf(stderr, "semInitValue failure\n");
		exit(1);
	}

	srand(0x9999);
	for (i = 0 ; i < NLOOPS ; i++)  {
		if (semWait(fullSemid) < 0)  {
			fprintf(stderr, "semWait failure\n");
			exit(1);
		}
		if (semWait(mutexSemid) < 0)  {
			fprintf(stderr, "semWait failure\n");
			exit(1);
		}
		printf("Consumer: Consuming an item.....\n");
		data = pBuf->buf[pBuf->out].data;
		pBuf->out = (pBuf->out + 1) % MAX_BUF;
		pBuf->counter--;

		if (semPost(mutexSemid) < 0)  {
			fprintf(stderr, "semPost failure\n");
			exit(1);
		}
		if (semPost(emptySemid) < 0)  {
			fprintf(stderr, "semPost failure\n");
			exit(1);
		}

		usleep((rand()%100)*10000);
	}

	printf("Consumer: Consumed %d items.....\n", i);
	printf("Consumer: %d items in buffer.....\n", pBuf->counter);
}
```

/end

# semTryWait

```jsx
semTryWait(int semid)
```

설명: 세마포어에서 비차단 대기를 시도합니다.

매개변수:

semid: 세마포어 ID.
반환 값:

성공 시: 대기가 성공하면 0을 반환합니다.
실패 시: 세마포어를 사용할 수 없는 경우(사용 중) -1을 반환합니다.

/end

# semPost

```jsx
semPost(int semid)
```

설명: 세마포어에 신호(V 연산)를 수행합니다.

매개변수:

semid: 세마포어 ID.
반환 값:

성공 시: 0을 반환합니다.
실패 시: -1을 반환합니다.

/end

# semGetValue

```jsx
semGetValue(int semid)
```

설명: 세마포어의 현재 값을 검색합니다.

매개변수:

semid: 세마포어 ID.
반환 값:

성공 시 세마포어의 현재 값을 반환합니다.
실패 시: -1을 반환합니다.

/end

# semDestroy

```jsx
semDestroy(int semid)
```

설명 : 세마포어를 파괴합니다.

매개변수:

semid: 세마포어 ID.
반환 값:

성공 시: 0을 반환합니다.
실패 시: -1을 반환합니다.

/end

# pthread_mutex

## pthread_mutex_init

헤더: 

```java
#include <pthread.h>
```

타입: 초기화 함수
설명: 뮤텍스를 mattr에 지정된 속성으로 초기화합니다. mattr이 NULL이면 기본 속성을 사용합니다.
반환값: 성공 시 0, 에러 발생 시 0이 아닌 값.
사용 예시:

```c
pthread_mutex_t mutex;
pthread_mutexattr_t attr;
pthread_mutexattr_init(&attr);
pthread_mutex_init(&mutex, &attr);
```

## pthread_mutex_destroy

**헤더**: 

```c
#include <pthread.h>
```

**타입**: 해제 함수
**설명**: 뮤텍스 객체를 해제하고 관련된 모든 자원을 해제합니다.
**반환값**: 성공 시 0, 에러 발생 시 0이 아닌 값.
**사용 예시:**

```c
pthread_mutex_t mutex;
pthread_mutex_init(&mutex, NULL);
pthread_mutex_destroy(&mutex);
```

## pthread_mutex_lock

헤더:

```c
 #include <pthread.h>
```

타입: 잠금 함수
설명: 뮤텍스를 잠그고, 다른 쓰레드가 락을 얻을 때까지 대기합니다.
반환값: 성공 시 0, 에러 발생 시 0이 아닌 값.
사용 예시:

```c
pthread_mutex_t mutex;
pthread_mutex_init(&mutex, NULL);
pthread_mutex_lock(&mutex);
// 임계 영역
pthread_mutex_unlock(&mutex);
```

## pthread_mutex_trylock

헤더:

```c
 #include <pthread.h>
```

**타입**: 비차단 잠금 함수
**설명**: 락을 얻으려 시도합니다. 즉시 반환되며, 락을 획득하면 (0), 다른 쓰레드가 이미 락을 가지고 있을 경우 (0이 아닌 값) 실패합니다.
**반환값**: 성공 시 (0 - 락 획득), 다른 쓰레드가 이미 락을 가지고 있을 경우 (0이 아닌 값).
**사용 예시:**

```c
pthread_mutex_t mutex;
pthread_mutex_init(&mutex, NULL);
if (pthread_mutex_trylock(&mutex) == 0) {
// 락을 획득함
pthread_mutex_unlock(&mutex);
} else {
// 락 획득 실패
}
```

## pthread_mutex_unlock

헤더:

```c
 #include <pthread.h>
```

타입: 잠금 해제 함수
설명: 뮤텍스와 연관된 락을 해제합니다.
반환값: 성공 시 0, 에러 발생 시 0이 아닌 값.
사용 예시:

```c
pthread_mutex_t mutex;
pthread_mutex_init(&mutex, NULL);
pthread_mutex_lock(&mutex);
// 임계 영역
pthread_mutex_unlock(&mutex);
```

/end

# pthread_cond

## pthread_cond_init

헤더:

```c
 #include <pthread.h>
```

함수 원형: int pthread_cond_init(pthread_cond_t *cond, pthread_condattr_t *cattr);
설명: 조건 변수를 초기화합니다. cattr로 지정된 속성을 사용하며, cattr이 NULL이면 기본 속성을 사용합니다.
반환값: 성공 시 0, 에러 발생 시 0이 아닌 값.
예시 코드:

```c
pthread_cond_t condition;
pthread_cond_init(&condition, NULL);
```

## pthread_cond_destroy

헤더:

```c
 #include <pthread.h>
```

함수 원형: int pthread_cond_destroy(pthread_cond_t *cond);
설명: 조건 변수를 파괴하고 연관된 자원을 해제합니다.
반환값: 성공 시 0, 에러 발생 시 0이 아닌 값.
예시 코드:

```c
pthread_cond_t condition;
pthread_cond_init(&condition, NULL);
pthread_cond_destroy(&condition);
```

## pthread_cond_wait

헤더:

```c
 #include <pthread.h>
```

함수 원형: int pthread_cond_wait(pthread_cond_t *cond, pthread_mutex_t *mutex);
설명: 조건 변수의 신호를 기다립니다. 조건 변수와 연결된 뮤텍스를 잠근 상태에서 기다립니다.
반환값: 성공 시 0, 에러 발생 시 0이 아닌 값.

예시 코드:

```c
pthread_cond_t condition;
pthread_mutex_t mutex;
pthread_cond_init(&condition, NULL);
pthread_mutex_init(&mutex, NULL);
pthread_mutex_lock(&mutex);
pthread_cond_wait(&condition, &mutex);
```

## pthread_cond_signal

헤더:

```c
 #include <pthread.h>
```

함수 원형: int pthread_cond_signal(pthread_cond_t *cond);
설명: 대기 중인 하나의 스레드에 신호를 보냅니다. 대기 중인 스레드가 없으면 아무런 효과가 없습니다.
반환값: 성공 시 0, 에러 발생 시 0이 아닌 값.
예시 코드:

```c
pthread_cond_t condition;
pthread_cond_init(&condition, NULL);
pthread_cond_signal(&condition);
```

## pthread_cond_broadcast

헤더:

```c
 #include <pthread.h>
```

함수 원형: int pthread_cond_broadcast(pthread_cond_t *cond);
설명: 대기 중인 모든 스레드에게 신호를 보냅니다. 모든 스레드가 신호를 받아서 깨어납니다.
반환값: 성공 시 0, 에러 발생 시 0이 아닌 값.
예시 코드:

```c
pthread_cond_t condition;
pthread_cond_init(&condition, NULL);
pthread_cond_broadcast(&condition);
```

/end

# prodcons

```c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <semaphore.h>
#include <pthread.h>
#include <sys/time.h>
#include "prodcons.h"

BoundedBufferType	Buf;
sem_t				EmptySem, FullSem, MutexSem;

void
ThreadUsleep(int usecs)
{
	pthread_cond_t		cond;
	pthread_mutex_t		mutex;
	struct timespec		ts;
	struct timeval		tv;

	if (pthread_cond_init(&cond, NULL) < 0)  {
		perror("pthread_cond_init");
		pthread_exit(NULL);
	}
	if (pthread_mutex_init(&mutex, NULL) < 0)  {
		perror("pthread_mutex_init");
		pthread_exit(NULL);
	}

	gettimeofday(&tv, NULL);
	ts.tv_sec = tv.tv_sec + usecs/1000000;
	ts.tv_nsec = (tv.tv_usec + (usecs%1000000)) * 1000;
	if (ts.tv_nsec >= 1000000000)  {
		ts.tv_nsec -= 1000000000;
		ts.tv_sec++;
	}

	if (pthread_mutex_lock(&mutex) < 0)  {
		perror("pthread_mutex_lock");
		pthread_exit(NULL);
	}
	if (pthread_cond_timedwait(&cond, &mutex, &ts) < 0)  {
		perror("pthread_cond_timedwait");
		pthread_exit(NULL);
	}

	if (pthread_cond_destroy(&cond) < 0)  {
		perror("pthread_cond_destroy");
		pthread_exit(NULL);
	}
	if (pthread_mutex_destroy(&mutex) < 0)  {
		perror("pthread_mutex_destroy");
		pthread_exit(NULL);
	}
}

void
Producer(void *dummy)
{
	int		i, data;

	printf("Producer: Start.....\n");

	for (i = 0 ; i < NLOOPS ; i++)  {
		if (sem_wait(&EmptySem) < 0)  {
			perror("sem_wait");
			pthread_exit(NULL);
		}
		if (sem_wait(&MutexSem) < 0)  {
			perror("sem_wait");
			pthread_exit(NULL);
		}

		printf("Producer: Producing an item.....\n");
		data = (rand()%100)*10000;
		Buf.buf[Buf.in].data = data;
		Buf.in = (Buf.in + 1) % MAX_BUF;
		Buf.counter++;

		if (sem_post(&MutexSem) < 0)  {
			perror("sem_post");
			pthread_exit(NULL);
		}
		if (sem_post(&FullSem) < 0)  {
			perror("sem_post");
			pthread_exit(NULL);
		}

		ThreadUsleep(data);
	}

	printf("Producer: Produced %d items.....\n", i);
	printf("Producer: %d items in buffer.....\n", Buf.counter);
	
	pthread_exit(NULL);
}

void
Consumer(void *dummy)
{
	int		i, data;

	printf("Consumer: Start.....\n");

	for (i = 0 ; i < NLOOPS ; i++)  {
		if (sem_wait(&FullSem) < 0)  {
			perror("sem_wait");
			pthread_exit(NULL);
		}
		if (sem_wait(&MutexSem) < 0)  {
			perror("sem_wait");
			pthread_exit(NULL);
		}

		printf("Consumer: Consuming an item.....\n");
		data = Buf.buf[Buf.out].data;
		Buf.out = (Buf.out + 1) % MAX_BUF;
		Buf.counter--;

		if (sem_post(&MutexSem) < 0)  {
			perror("sem_post");
			pthread_exit(NULL);
		}
		if (sem_post(&EmptySem) < 0)  {
			perror("sem_post");
			pthread_exit(NULL);
		}

		ThreadUsleep((rand()%100)*10000);
	}

	printf("Consumer: Consumed %d items.....\n", i);
	printf("Consumer: %d items in buffer.....\n", Buf.counter);

	pthread_exit(NULL);
}

main()
{
	pthread_t	tid1, tid2;

	srand(0x9999);

	if (sem_init(&EmptySem, 0, MAX_BUF) < 0)  {
		perror("sem_init");
		exit(1);
	}
	if (sem_init(&FullSem, 0, 0) < 0)  {
		perror("sem_init");
		exit(1);
	}
	if (sem_init(&MutexSem, 0, 1) < 0)  {
		perror("sem_init");
		exit(1);
	}

	if (pthread_create(&tid1, NULL, (void *)Producer, (void *)NULL) < 0)  {
		perror("pthread_create");
		exit(1);
	}

	if (pthread_create(&tid2, NULL, (void *)Consumer, (void *)NULL) < 0)  {
		perror("pthread_create");
		exit(1);
	}

	if (pthread_join(tid1, NULL) < 0)  {
		perror("pthread_join");
		exit(1);
	}
	if (pthread_join(tid2, NULL) < 0)  {
		perror("pthread_join");
		exit(1);
	}

	printf("Main    : %d items in buffer.....\n", Buf.counter);

	if (sem_destroy(&EmptySem) < 0)  {
		perror("sem_destroy");
	}
	if (sem_destroy(&FullSem) < 0)  {
		perror("sem_destroy");
	}
	if (sem_destroy(&MutexSem) < 0)  {
		perror("sem_destroy");
	}
}
```

/end

# **socket**

헤더:

```c
#include <sys/types.h>
#include <sys/socket.h>
```

설명:
이 함수는 소켓을 생성하는데 사용됩니다. 생성된 소켓은 통신에 사용될 수 있습니다.

첫 번째 인자, family:
이 값은 소켓의 주소 체계(address family)를 지정합니다. 주소 체계는 통신에 사용되는 주소 형식을 나타내는데, 다양한 종류가 있습니다.

- PF_UNIX, PF_LOCAL: 로컬 IPC(Inter-Process Communication)를 위한 주소 체계입니다. FIFO를 사용하여 IPC할 수 있으므로 소켓을 사용할 필요가 없습니다. FIFO를 사용하여 소켓을 한 번 더 싸는 것은 선택적인 방법입니다.
- PF_INET: 인터넷을 위한 주소 체계로 IPv4를 사용합니다.
- PF_INET6: 인터넷을 위한 주소 체계로 IPv6를 사용합니다.
- PF_IPX: IPX 프로토콜을 사용하는 주소 체계입니다.
- PF_X25: X.25 프로토콜을 사용하는 주소 체계입니다.

두 번째 인자, type:
이 값은 소켓의 타입을 지정합니다. 소켓 타입은 통신 방식을 나타내며, 다음과 같은 종류가 있습니다.

- SOCK_STREAM: 스트림(socket) 소켓으로 TCP를 사용하는 연결 지향적인 통신 방식입니다.
- SOCK_DGRAM: 데이터그램(socket) 소켓으로 UDP를 사용하는 비연결성 통신 방식입니다.
- SOCK_RAW: raw socket으로 프로토콜에 직접 접근할 수 있는 소켓입니다. 일반적으로 네트워크 프로토콜의 패킷을 직접 다루는 용도로 사용됩니다.

세 번째 인자, protocol:
이 값은 소켓에 사용될 프로토콜을 지정합니다. 일반적으로 0으로 설정하며, 시스템에서 알맞은 프로토콜을 선택합니다.

예를 들어, `socket(AF_INET, SOCK_STREAM, 0)`는 인터넷 주소 체계(IPv4)를 사용하고 TCP를 위한 스트림 소켓을 생성하는 것을 의미합니다.

반환값:

- 성공 시 소켓 디스크립터 (socket descriptor)
- 실패 시 -1

간단한 예시:

```c
#include <stdio.h>
#include <sys/types.h>
#include <sys/socket.h>

int main() {
    int sockfd = socket(PF_INET, SOCK_STREAM, 0);
    if (sockfd == -1) {
        perror("소켓 생성 에러");
        return 1;
    }

    printf("소켓이 성공적으로 생성되었습니다.\\n");

    return 0;
}

```

이 예시에서는 `PF_INET`을 사용하여 인터넷 프로토콜을 위한 소켓을 생성하고 있습니다. `SOCK_STREAM`은 TCP를 사용하는 스트림 소켓을 의미합니다. 소켓이 성공적으로 생성되면 "소켓이 성공적으로 생성되었습니다."라는 메시지가 출력됩니다.

/end

# bind

헤더:

```c
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>

```

설명:
이 함수는 이름이 없는 소켓에 주소를 바인딩하는데 사용됩니다. 소켓에 주소를 바인딩하면 해당 주소로 들어오는 연결 요청을 수신할 수 있습니다.

반환값:

- 성공 시 0
- 실패 시 -1

파라미터:

- sd: 바인딩할 소켓 디스크립터 (socket descriptor)
- myaddr: 바인딩할 주소 정보가 담긴 sockaddr 구조체 포인터
- addrlen: myaddr 구조체의 크기 (sizeof(struct sockaddr))

간단한 예시:

```c
#include <stdio.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>

int main() {
    int sockfd = socket(AF_INET, SOCK_STREAM, 0);
    if (sockfd == -1) {
        perror("소켓 생성 에러");
        return 1;
    }

    struct sockaddr_in addr;
    addr.sin_family = PF_INET;
    addr.sin_port = htons(8080); // 예시로 포트번호 8080을 사용
    addr.sin_addr.s_addr = INADDR_ANY;

    int bind_result = bind(sockfd, (struct sockaddr*)&addr, sizeof(addr));
    if (bind_result == -1) {
        perror("바인딩 에러");
        return 1;
    }

    printf("주소가 성공적으로 바인딩되었습니다.
");

    return 0;
}

```

이 예시에서는 먼저 소켓을 생성한 후, sockaddr_in 구조체를 사용하여 주소 정보를 설정합니다. sin_family는 PF_INET으로 설정하여 IPv4 주소 체계를 사용하고, sin_port는 htons 함수를 사용하여 포트번호 8080을 Big-endian으로 설정합니다. sin_addr.s_addr는 INADDR_ANY로 설정하여 모든 네트워크 인터페이스에서 들어오는 연결 요청을 수신할 수 있도록 합니다.

그리고 bind 함수를 호출하여 소켓에 주소를 바인딩합니다. 바인딩이 성공하면 "주소가 성공적으로 바인딩되었습니다."라는 메시지가 출력됩니다.

/end

# struct

## struct in_addr

네트워크 바이트 순서로 표현된 32비트 주소를 나타내는 구조체입니다. `u_long s_addr` 필드를 통해 주소를 저장합니다.

## struct sockaddr_in

`struct sockaddr_in`은 IPv4 주소 체계를 사용하는 주소 정보를 담는 구조체입니다. 각 필드의 역할은 다음과 같습니다:

`short sin_family`: 주소 체계를 지정하는데, `PF_INET`으로 설정하여 IPv4 주소 체계를 사용함을 나타냅니다.

`u_short sin_port`: 16비트 포트 번호입니다. `htons` 함수를 사용하여 Big-endian으로 변환된 값이 저장됩니다.

`struct in_addr sin_addr`: 네트워크 바이트 순서로 표현된 주소가 저장되는 `struct in_addr` 구조체입니다.

`char sin_zero[8]`: 사용되지 않는 영역으로, 일반적으로 0으로 초기화됩니다.

## struct sockaddr_un

`struct sockaddr_un`은 로컬 IPC(Inter-Process Communication)를 위한 주소 정보를 담는 구조체입니다. 주로 파일 시스템의 경로를 사용하여 통신하는데, 각 필드의 역할은 다음과 같습니다:

`short sun_family`: 주소 체계를 지정하는데, `PF_UNIX`로 설정하여 로컬 IPC를 사용함을 나타냅니다.`char sun_path[108]`: 경로 이름을 저장하는 배열로, 로컬 파일 시스템의 파일 경로를 사용하여 소켓을 식별합니다. 최대 108바이트까지 저장 가능합니다.

/end

# connect

설명:
이 함수는 클라이언트 소켓에서 서버 소켓으로의 연결을 수립하기 위해 사용됩니다. 지정된 서버 주소로 연결을 시도합니다.

반환값:

- 성공 시 0
- 실패 시 -1

파라미터:

- sd: 연결을 시도할 소켓 디스크립터 (socket descriptor)
- servaddr: 연결할 서버의 주소 정보가 담긴 sockaddr 구조체 포인터
- addrlen: servaddr 구조체의 크기 (sizeof(struct sockaddr))

간단한 예시:

## tcpc.c

```c
#include <stdio.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include "tcp.h"

main(int argc, char *argv[])
{
	int					sockfd, n;
	struct sockaddr_in	servAddr;
	MsgType				msg;

	if ((sockfd = socket(PF_INET, SOCK_STREAM, 0)) < 0)  {
		perror("socket");
		exit(1);
	}

	bzero((char *)&servAddr, sizeof(servAddr));
	servAddr.sin_family = PF_INET;
	servAddr.sin_addr.s_addr = inet_addr(SERV_HOST_ADDR);
	servAddr.sin_port = htons(SERV_TCP_PORT);

	if (connect(sockfd, (struct sockaddr *) &servAddr, sizeof(servAddr)) < 0)  {
		perror("connect");
		exit(1);
	}

	msg.type = MSG_REQUEST;
	sprintf(msg.data, "This is a request from %d.", getpid());
	if (write(sockfd, (char *)&msg, sizeof(msg)) < 0)  {
		perror("write");
		exit(1);
	}
	printf("Sent a request.....");
		
	if ((n = read(sockfd, (char *)&msg, sizeof(msg))) < 0)  {
		perror("read");
		exit(1);
	}
	printf("Received reply: %s\n", msg.data);

	close(sockfd);
}
```

이 예시에서는 먼저 클라이언트 소켓을 생성한 후, sockaddr_in 구조체를 사용하여 서버의 주소 정보를 설정합니다. sin_family는 PF_INET으로 설정하여 IPv4 주소 체계를 사용하고, sin_port는 htons 함수를 사용하여 포트번호 8080을 Big-endian으로 설정합니다. sin_addr.s_addr는 inet_addr 함수를 사용하여 서버의 IP 주소를 설정합니다.

그리고 connect 함수를 호출하여 클라이언트 소켓에서 서버 소켓으로의 연결을 시도합니다. 연결이 성공하면 "서버와의 연결이 성공적으로 수립되었습니다."라는 메시지가 출력됩니다.

/end

# listen

함수명: listen
설명:
이 함수는 서버 소켓에서 연결 요청을 수신하기 위해 대기 상태로 전환합니다. 지정된 소켓에서 들어오는 연결 요청을 처리할 준비를 합니다.

반환값:

- 성공 시 0
- 실패 시 -1

파라미터:

- sd: 연결 요청을 수신할 소켓 디스크립터 (socket descriptor)
- backlog: 대기열에 유지할 연결 요청의 최대 개수. 일반적으로 5를 사용합니다.

간단한 예시:

## tcps.c

```c
#include <stdio.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <signal.h>
#include "tcp.h"

int	Sockfd;

void
CloseServer()
{
	close(Sockfd);
	printf("\nTCP Server exit.....\n");

	exit(0);
}

main(int argc, char *argv[])
{
	int					newSockfd, cliAddrLen, n;
	struct sockaddr_in	cliAddr, servAddr;
	MsgType				msg;

	signal(SIGINT, CloseServer);

	if ((Sockfd = socket(PF_INET, SOCK_STREAM, 0)) < 0)  {
		perror("socket");
		exit(1);
	}

	bzero((char *)&servAddr, sizeof(servAddr));
	servAddr.sin_family = PF_INET;
	servAddr.sin_addr.s_addr = htonl(INADDR_ANY);
	servAddr.sin_port = htons(SERV_TCP_PORT);

	if (bind(Sockfd, (struct sockaddr *) &servAddr, sizeof(servAddr)) < 0)  {
		perror("bind");
		exit(1);
	}

	listen(Sockfd, 5);

	printf("TCP Server started.....\n");

	cliAddrLen = sizeof(cliAddr);
	while (1)  {
		newSockfd = accept(Sockfd, (struct sockaddr *) &cliAddr, &cliAddrLen);
		if (newSockfd < 0)  {
			perror("accept");
			exit(1);
		}
		
		if ((n = read(newSockfd, (char *)&msg, sizeof(msg))) < 0)  {
			perror("read");
			exit(1);
		}
		printf("Received request: %s.....", msg.data);

		msg.type = MSG_REPLY;
		sprintf(msg.data, "This is a reply from %d.", getpid());
		if (write(newSockfd, (char *)&msg, sizeof(msg)) < 0)  {
			perror("write");
			exit(1);
		}
		printf("Replied.\n");

		usleep(10000);
		close(newSockfd);
	}
}
```

이 예시에서는 먼저 서버 소켓을 생성한 후, listen 함수를 호출하여 연결 요청을 수신하기 위해 대기 상태로 전환합니다. listen 함수의 두 번째 인자인 backlog은 대기열에 유지할 연결 요청의 최대 개수로, 일반적으로 5를 사용합니다.

대기 상태로 전환된 후 "연결 요청을 수신하기 위해 대기 중입니다."라는 메시지가 출력됩니다. 이제 서버는 accept 함수를 사용하여 클라이언트의 연결 요청을 수락할 수 있습니다.

/end

# accept

함수명: accept
설명:
이 함수는 서버 소켓에서 클라이언트의 연결 요청을 수락하기 위해 사용됩니다. 대기 중인 연결 요청 중 하나를 선택하여 연결을 수락하고, 새로운 소켓을 생성하여 해당 클라이언트와의 통신에 사용합니다.

반환값:

- 성공 시 새로운 소켓 디스크립터 (new socket descriptor)
- 실패 시 -1

파라미터:

- sd: 연결 요청을 수락할 소켓 디스크립터 (socket descriptor)
- peer: 클라이언트의 주소 정보를 저장할 sockaddr 구조체 포인터
- addrlen: peer 구조체의 크기를 나타내는 int 포인터

간단한 예시:

```c
#include <stdio.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <signal.h>
#include "tcp.h"

int	Sockfd;

void
CloseServer()
{
	close(Sockfd);
	printf("\nTCP Server exit.....\n");

	exit(0);
}

main(int argc, char *argv[])
{
	int					newSockfd, cliAddrLen, n;
	struct sockaddr_in	cliAddr, servAddr;
	MsgType				msg;

	signal(SIGINT, CloseServer);

	if ((Sockfd = socket(PF_INET, SOCK_STREAM, 0)) < 0)  {
		perror("socket");
		exit(1);
	}

	bzero((char *)&servAddr, sizeof(servAddr));
	servAddr.sin_family = PF_INET;
	servAddr.sin_addr.s_addr = htonl(INADDR_ANY);
	servAddr.sin_port = htons(SERV_TCP_PORT);

	if (bind(Sockfd, (struct sockaddr *) &servAddr, sizeof(servAddr)) < 0)  {
		perror("bind");
		exit(1);
	}

	listen(Sockfd, 5);

	printf("TCP Server started.....\n");

	cliAddrLen = sizeof(cliAddr);
	while (1)  {
		newSockfd = accept(Sockfd, (struct sockaddr *) &cliAddr, &cliAddrLen);
		if (newSockfd < 0)  {
			perror("accept");
			exit(1);
		}
		
		if ((n = read(newSockfd, (char *)&msg, sizeof(msg))) < 0)  {
			perror("read");
			exit(1);
		}
		printf("Received request: %s.....", msg.data);

		msg.type = MSG_REPLY;
		sprintf(msg.data, "This is a reply from %d.", getpid());
		if (write(newSockfd, (char *)&msg, sizeof(msg)) < 0)  {
			perror("write");
			exit(1);
		}
		printf("Replied.\n");

		usleep(10000);
		close(newSockfd);
	}
}
```

이 예시에서는 서버 소켓을 생성한 후, sockaddr_in 구조체를 사용하여 서버의 주소 정보를 설정합니다. sin_family는 AF_INET으로 설정하여 IPv4 주소 체계를 사용하고, sin_port는 htons 함수를 사용하여 포트번호 8080을 Big-endian으로 설정합니다. sin_addr.s_addr는 INADDR_ANY를 사용하여 모든 네트워크 인터페이스에서의 연결을 허용합니다.

그리고 bind 함수를 호출하여 서버 소켓과 주소를 바인딩한 후, listen 함수를 호출하여 연결 요청을 수신하기 위해 대기 상태로 전환합니다.

accept 함수를 호출하여 대기 중인 연결 요청 중 하나를 수락하고, 새로운 소켓 디스크립터인 client_sockfd를 반환합니다. 이 때, 클라이언트의 주소 정보는 client_addr에 저장되며, client_addrlen은 클라이언트 주소 구조체의 크기를 나타냅니다.

연결이 수락되면 "새로운 클라이언트 연결이 수락되었습니다."라는 메시지가 출력됩니다.

/end

# close

함수명: close
설명:
이 함수는 소켓을 닫아 해당 소켓 디스크립터를 해제합니다. 소켓과 관련된 자원을 정리하고, 해당 소켓에 대한 모든 연결을 끊습니다.

반환값:

- 성공 시 0
- 실패 시 -1

파라미터:

- sd: 닫을 소켓 디스크립터 (socket descriptor)

간단한 예시:

```c
#include <stdio.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <signal.h>
#include "tcp.h"

int	Sockfd;

void
CloseServer()
{
	close(Sockfd);
	printf("\nTCP Server exit.....\n");

	exit(0);
}

main(int argc, char *argv[])
{
	int					newSockfd, cliAddrLen, n;
	struct sockaddr_in	cliAddr, servAddr;
	MsgType				msg;

	signal(SIGINT, CloseServer);

	if ((Sockfd = socket(PF_INET, SOCK_STREAM, 0)) < 0)  {
		perror("socket");
		exit(1);
	}

	bzero((char *)&servAddr, sizeof(servAddr));
	servAddr.sin_family = PF_INET;
	servAddr.sin_addr.s_addr = htonl(INADDR_ANY);
	servAddr.sin_port = htons(SERV_TCP_PORT);

	if (bind(Sockfd, (struct sockaddr *) &servAddr, sizeof(servAddr)) < 0)  {
		perror("bind");
		exit(1);
	}

	listen(Sockfd, 5);

	printf("TCP Server started.....\n");

	cliAddrLen = sizeof(cliAddr);
	while (1)  {
		newSockfd = accept(Sockfd, (struct sockaddr *) &cliAddr, &cliAddrLen);
		if (newSockfd < 0)  {
			perror("accept");
			exit(1);
		}
		
		if ((n = read(newSockfd, (char *)&msg, sizeof(msg))) < 0)  {
			perror("read");
			exit(1);
		}
		printf("Received request: %s.....", msg.data);

		msg.type = MSG_REPLY;
		sprintf(msg.data, "This is a reply from %d.", getpid());
		if (write(newSockfd, (char *)&msg, sizeof(msg)) < 0)  {
			perror("write");
			exit(1);
		}
		printf("Replied.\n");

		usleep(10000);
		close(newSockfd);
	}
}
```

이 예시에서는 먼저 소켓을 생성한 후, 해당 소켓을 사용합니다. 사용이 끝나면 close 함수를 호출하여 소켓을 닫습니다.

소켓이 성공적으로 닫히면 "소켓이 성공적으로 닫혔습니다."라는 메시지가 출력됩니다.

/end

# send

함수명: send
설명:
이 함수는 소켓을 통해 데이터를 전송합니다. 지정된 소켓에 데이터를 보내고, 전송된 바이트 수를 반환합니다.

반환값:

- 성공 시 전송된 바이트 수
- 실패 시 -1

파라미터:

- sd: 데이터를 전송할 소켓 디스크립터 (socket descriptor)
- buf: 전송할 데이터가 저장된 버퍼의 포인터
- nbytes: 전송할 데이터의 크기 (바이트 단위)
- flags: 전송에 대한 옵션 플래그

간단한 예시:

```c
#include <stdio.h>
#include <sys/types.h>
#include <sys/socket.h>

int main() {
    int sockfd = socket(AF_INET, SOCK_STREAM, 0);
    if (sockfd == -1) {
        perror("소켓 생성 에러");
        return 1;
    }

    // 소켓 설정 및 연결

    char message[] = "Hello, server!";
    ssize_t send_result = send(sockfd, message, sizeof(message), 0);
    if (send_result == -1) {
        perror("전송 에러");
        return 1;
    }

    printf("데이터를 성공적으로 전송했습니다.
");

    return 0;
}

```

이 예시에서는 먼저 소켓을 생성한 후, 해당 소켓을 설정하고 연결하는 과정이 생략되었습니다. 그리고 "Hello, server!"라는 메시지를 담은 message 버퍼를 생성하고, send 함수를 호출하여 해당 메시지를 서버로 전송합니다.

전송이 성공하면 "데이터를 성공적으로 전송했습니다."라는 메시지가 출력됩니다.

/end

# sendto

함수명: sendto
설명:
이 함수는 소켓을 통해 데이터를 특정 주소로 전송합니다. 지정된 소켓에 데이터를 보내고, 전송된 바이트 수를 반환합니다.

반환값:

- 성공 시 전송된 바이트 수
- 실패 시 -1

파라미터:

- sd: 데이터를 전송할 소켓 디스크립터 (socket descriptor)
- buf: 전송할 데이터가 저장된 버퍼의 포인터
- nbytes: 전송할 데이터의 크기 (바이트 단위)
- flags: 전송에 대한 옵션 플래그
- to: 데이터를 전송할 목적지 주소 정보가 담긴 sockaddr 구조체 포인터
- addrlen: to 구조체의 크기 (sizeof(struct sockaddr))

간단한 예시:

```c
#include <stdio.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>

int main() {
    int sockfd = socket(AF_INET, SOCK_DGRAM, 0);
    if (sockfd == -1) {
        perror("소켓 생성 에러");
        return 1;
    }

    struct sockaddr_in server_addr;
    server_addr.sin_family = AF_INET;
    server_addr.sin_port = htons(8080); // 예시로 포트번호 8080을 사용
    server_addr.sin_addr.s_addr = inet_addr("127.0.0.1"); // 예시로 서버 IP 주소 127.0.0.1을 사용

    char message[] = "Hello, server!";
    ssize_t sendto_result = sendto(sockfd, message, sizeof(message), 0, (struct sockaddr*)&server_addr, sizeof(server_addr));
    if (sendto_result == -1) {
        perror("전송 에러");
        return 1;
    }

    printf("데이터를 성공적으로 전송했습니다.
");

    return 0;
}

```

이 예시에서는 소켓을 생성한 후, sockaddr_in 구조체를 사용하여 서버의 주소 정보를 설정합니다. 그리고 "Hello, server!"라는 메시지를 담은 message 버퍼를 생성하고, sendto 함수를 호출하여 해당 메시지를 서버로 전송합니다.

전송이 성공하면 "데이터를 성공적으로 전송했습니다."라는 메시지가 출력됩니다.

/end

# recv

설명:
이 함수는 소켓으로부터 데이터를 수신합니다. 지정된 소켓으로부터 데이터를 받아와서 버퍼에 저장하고, 수신한 바이트 수를 반환합니다.

반환값:

- 성공 시 수신한 바이트 수
- 실패 시 -1

파라미터:

- sd: 데이터를 수신할 소켓 디스크립터 (socket descriptor)
- buf: 수신한 데이터를 저장할 버퍼의 포인터
- nbytes: 수신할 데이터의 최대 크기 (바이트 단위)
- flags: 수신에 대한 옵션 플래그

간단한 예시:

```c
#include <stdio.h>
#include <sys/types.h>
#include <sys/socket.h>

int main() {
    int sockfd = socket(AF_INET, SOCK_STREAM, 0);
    if (sockfd == -1) {
        perror("소켓 생성 에러");
        return 1;
    }

    // 소켓 설정 및 연결

    char buffer[1024];
    ssize_t recv_result = recv(sockfd, buffer, sizeof(buffer), 0);
    if (recv_result == -1) {
        perror("수신 에러");
        return 1;
    }

    printf("데이터를 성공적으로 수신했습니다.
");

    return 0;
}

```

이 예시에서는 먼저 소켓을 생성한 후, 해당 소켓을 설정하고 연결하는 과정이 생략되었습니다. 그리고 1024바이트 크기의 버퍼를 생성하고, recv 함수를 호출하여 소켓으로부터 데이터를 수신하여 버퍼에 저장합니다.

수신이 성공하면 "데이터를 성공적으로 수신했습니다."라는 메시지가 출력됩니다.

/end

# recvfrom

함수명: recvfrom
설명:
이 함수는 소켓으로부터 데이터를 특정 주소로부터 수신합니다. 지정된 소켓으로부터 데이터를 받아와서 버퍼에 저장하고, 수신한 바이트 수를 반환합니다.

반환값:

- 성공 시 수신한 바이트 수
- 실패 시 -1

파라미터:

- sd: 데이터를 수신할 소켓 디스크립터 (socket descriptor)
- buf: 수신한 데이터를 저장할 버퍼의 포인터
- nbytes: 수신할 데이터의 최대 크기 (바이트 단위)
- flags: 수신에 대한 옵션 플래그
- from: 데이터를 보낸 송신자의 주소 정보가 담긴 sockaddr 구조체 포인터
- addrlen: from 구조체의 크기를 나타내는 int 포인터

간단한 예시:

```c
#include <stdio.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>

int main() {
    int sockfd = socket(AF_INET, SOCK_DGRAM, 0);
    if (sockfd == -1) {
        perror("소켓 생성 에러");
        return 1;
    }

    struct sockaddr_in server_addr;
    server_addr.sin_family = AF_INET;
    server_addr.sin_port = htons(8080); // 예시로 포트번호 8080을 사용
    server_addr.sin_addr.s_addr = INADDR_ANY;

    int bind_result = bind(sockfd, (struct sockaddr*)&server_addr, sizeof(server_addr));
    if (bind_result == -1) {
        perror("바인딩 에러");
        return 1;
    }

    char buffer[1024];
    struct sockaddr_in client_addr;
    int client_addrlen = sizeof(client_addr);
	  ssize_t recvfrom_result = recvfrom(sockfd, buffer, sizeof(buffer), 0, (struct sockaddr*)&client_addr, &client_addrlen);
	if (recvfrom_result == -1) {
	perror("수신 에러");
	return 1;
	}
	
	printf("수신한 데이터: %s\n", buffer);
	
	// 클라이언트 정보 출력
	char client_ip[INET_ADDRSTRLEN];
	inet_ntop(AF_INET, &(client_addr.sin_addr), client_ip, sizeof(client_ip));
	printf("클라이언트 주소: %s\n", client_ip);
	printf("클라이언트 포트: %d\n", ntohs(client_addr.sin_port));
	
	close(sockfd);
	
	return 0;
	}
```

/end

# htonl

함수명: htonl
설명:
이 함수는 **32비트 호스트 순서 (Host Order) 값을 32비트 네트워크 바이트 순서 (Network Byte Order)로 변환**합니다. 호스트 순서는 호스트의 바이트 순서를 따르고, 네트워크 바이트 순서는 **Big-endian** 순서를 따릅니다.

반환값:
변환된 32비트 네트워크 바이트 순서 값

파라미터:

- hostlong: 변환할 호스트 순서 값

간단한 예시:

```c
#include <stdio.h>
#include <netinet/in.h>

int main() {
    u_long host_value = 123456789;
    u_long network_value = htonl(host_value);

    printf("Host Value: %lu\\n", host_value);
    printf("Network Value: %lu\\n", network_value);

    return 0;
}

```

이 예시에서는 32비트 호스트 순서 값을 `host_value` 변수에 저장한 후, `htonl` 함수를 사용하여 호스트 순서 값을 네트워크 바이트 순서로 변환하여 `network_value` 변수에 저장합니다.

변환된 결과를 출력하면 호스트 순서 값과 네트워크 바이트 순서 값이 다른 것을 확인할 수 있습니다.

/end

# htons

함수명: htons
설명:
이 함수는 16비트 호스트 순서 (Host Order) 값을 16비트 네트워크 바이트 순서 (Network Byte Order)로 변환합니다. 호스트 순서는 호스트의 바이트 순서를 따르고, 네트워크 바이트 순서는 Big-endian 순서를 따릅니다.

반환값:
변환된 16비트 네트워크 바이트 순서 값

파라미터:

- hostshort: 변환할 호스트 순서 값

간단한 예시:

```c
#include <stdio.h>
#include <netinet/in.h>

int main() {
    u_short host_value = 56789;
    u_short network_value = htons(host_value);

    printf("Host Value: %hu\\n", host_value);
    printf("Network Value: %hu\\n", network_value);

    return 0;
}

```

이 예시에서는 16비트 호스트 순서 값을 `host_value` 변수에 저장한 후, `htons` 함수를 사용하여 호스트 순서 값을 네트워크 바이트 순서로 변환하여 `network_value` 변수에 저장합니다.

변환된 결과를 출력하면 호스트 순서 값과 네트워크 바이트 순서 값이 다른 것을 확인할 수 있습니다.

/end

# ntohl

함수명: ntohl
설명:
이 함수는 32비트 네트워크 바이트 순서 (Network Byte Order) 값을 32비트 호스트 순서 (Host Order)로 변환합니다. 네트워크 바이트 순서는 Big-endian 순서를 따르고, 호스트 순서는 호스트의 바이트 순서를 따릅니다.

반환값:
변환된 32비트 호스트 순서 값

파라미터:

- netlong: 변환할 네트워크 바이트 순서 값

간단한 예시:

```c
#include <stdio.h>
#include <netinet/in.h>

int main() {
    u_long network_value = 0x78563412;
    u_long host_value = ntohl(network_value);

    printf("Network Value: 0x%lx\\n", network_value);
    printf("Host Value: 0x%lx\\n", host_value);

    return 0;
}

```

이 예시에서는 32비트 네트워크 바이트 순서 값을 `network_value` 변수에 저장한 후, `ntohl` 함수를 사용하여 네트워크 바이트 순서 값을 호스트 순서로 변환하여 `host_value` 변수에 저장합니다.

변환된 결과를 출력하면 네트워크 바이트 순서 값과 호스트 순서 값이 다른 것을 확인할 수 있습니다.

/end

# ntohs

함수명: ntohs
설명:
이 함수는 16비트 네트워크 바이트 순서 (Network Byte Order) 값을 16비트 호스트 순서 (Host Order)로 변환합니다. 네트워크 바이트 순서는 Big-endian 순서를 따르고, 호스트 순서는 호스트의 바이트 순서를 따릅니다.

반환값:
변환된 16비트 호스트 순서 값

파라미터:

- netshort: 변환할 네트워크 바이트 순서 값

간단한 예시:

```c
#include <stdio.h>
#include <netinet/in.h>

int main() {
    u_short network_value = 0x3412;
    u_short host_value = ntohs(network_value);

    printf("Network Value: 0x%hx\\n", network_value);
    printf("Host Value: 0x%hx\\n", host_value);

    return 0;
}

```

이 예시에서는 16비트 네트워크 바이트 순서 값을 `network_value` 변수에 저장한 후, `ntohs` 함수를 사용하여 네트워크 바이트 순서 값을 호스트 순서로 변환하여 `host_value` 변수에 저장합니다.

변환된 결과를 출력하면 네트워크 바이트 순서 값과 호스트 순서 값이 다른 것을 확인할 수 있습니다.

/end

# inet_addr

함수명: inet_addr
설명:
이 함수는 문자열 형태의 IP 주소를 32비트 주소로 변환합니다. 변환된 32비트 주소를 반환합니다.

반환값:
변환된 32비트 주소 (dotted decimal notation의 IP 주소를 32비트로 변환한 값)

파라미터:

- str: 변환할 IP 주소를 나타내는 문자열 포인터

간단한 예시:

```c
#include <stdio.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>

int main() {
    char ip_address[] = "192.168.0.1";
    unsigned long address = inet_addr(ip_address);

    printf("IP Address: %s
", ip_address);
    printf("32-bit Address: %lu
", address);

    return 0;
}

```

이 예시에서는 문자열 형태의 IP 주소를 `ip_address` 변수에 저장한 후, `inet_addr` 함수를 사용하여 해당 IP 주소를 32비트 주소로 변환하여 `address` 변수에 저장합니다.

변환된 결과를 출력하면 IP 주소와 32비트 주소가 함께 출력됩니다.

/end

# inet_ntoa

설명:
이 함수는 32비트 주소를 dotted decimal notation 형태로 변환합니다. 변환된 문자열을 반환합니다.

반환값:
변환된 dotted decimal notation 형태의 IP 주소 문자열

파라미터:

- inaddr: 변환할 32비트 주소를 나타내는 in_addr 구조체

간단한 예시:

```c
#include <stdio.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>

int main() {
    struct in_addr address;
    address.s_addr = inet_addr("192.168.0.1");

    char* ip_address = inet_ntoa(address);

    printf("32-bit Address: %s
", inet_ntoa(address));
    printf("IP Address: %s
", ip_address);

    return 0;
}

```

이 예시에서는 문자열 형태의 IP 주소를 32비트 주소로 변환한 후, `in_addr` 구조체에 저장합니다. 그리고 `inet_ntoa` 함수를 사용하여 32비트 주소를 dotted decimal notation 형태로 변환하여 `ip_address` 변수에 저장합니다.

변환된 결과를 출력하면 32비트 주소와 IP 주소가 함께 출력됩니다.

/end

# gethostbyname

함수명: gethostbyname
설명:
이 함수는 호스트 이름에 해당하는 IP 주소를 얻기 위해 DNS(Domain Name Service)를 사용합니다. 호스트 이름에 해당하는 IP 주소 정보를 가지고 있는 `hostent` 구조체 포인터를 반환합니다.

반환값:
호스트 이름에 해당하는 IP 주소 정보를 가지고 있는 `hostent` 구조체 포인터 (성공 시), NULL (실패 시)

파라미터:

- name: IP 주소를 얻고자 하는 호스트의 이름을 나타내는 문자열 포인터

간단한 예시:

```c
#include <stdio.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <netdb.h>

int main() {
    char hostname[] = "www.example.com";
    struct hostent* host_info = gethostbyname(hostname);

    if (host_info == NULL) {
        fprintf(stderr, "호스트 정보를 가져오는데 실패했습니다.
");
        return 1;
    }

    printf("Host Name: %s
", host_info->h_name);

    return 0;
}

if ((hp = gethostbyname(argv[1])) == NULL)  {
        fprintf(stderr, "Unknown host: %s\n", argv[1]);
        exit(1);
    }
    memcpy(&servAddr.sin_addr, hp->h_addr, hp->h_length);
}
```

이 예시에서는 호스트 이름을 `hostname` 변수에 저장한 후, `gethostbyname` 함수를 사용하여 호스트 이름에 해당하는 IP 주소 정보를 가져옵니다. 가져온 정보는 `hostent` 구조체 포인터인 `host_info` 변수에 저장됩니다.

호스트 정보를 가져오는데 성공하면 호스트 이름을 출력합니다. 실패할 경우 "호스트 정보를 가져오는데 실패했습니다."라는 에러 메시지를 출력합니다.

```jsx
#include <stdio.h>
#include <netdb.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
int main()
{
    struct hostent *ghbn=gethostbyname("www.kamonesium.in");//change the domain name
    if (ghbn) {
        printf("Host Name->%s\n", ghbn->h_name);
        printf("IP ADDRESS->%s\n",inet_ntoa(*(struct in_addr *)ghbn->h_name) );
    }
}
```

/end

# select

설명:
이 함수는 동기적인 I/O 다중화를 수행하기 위해 사용됩니다. 여러 개의 파일 디스크립터에 대한 I/O 상태를 감시하고, 준비된 디스크립터의 개수를 반환합니다.

반환값:
준비된 디스크립터의 개수 (성공 시), 0 (타임아웃 시간이 경과한 경우), -1 (에러 발생 시)

파라미터:

- maxfd: 감시할 파일 디스크립터의 최대 값 + 1
- readfds: 읽기 작업을 감시할 파일 디스크립터 집합 (fd_set 구조체)
- writefds: 쓰기 작업을 감시할 파일 디스크립터 집합 (fd_set 구조체)
- exceptfds: 예외 상황을 감시할 파일 디스크립터 집합 (fd_set 구조체)
- tvptr: 타임아웃 값을 지정하는 timeval 구조체 포인터
- tvptr이 NULL인 경우:
    ◦ 무한히 기다립니다. 즉, 어떤 조건이 충족될 때까지 계속해서 대기합니다.
- tvptr->tv_sec가 0이고 tvptr->tv_usec가 0인 경우:
    ◦ 전혀 기다리지 않습니다. 즉, 바로 다음 코드를 실행합니다.
- tvptr->tv_sec가 0이 아니고 tvptr->tv_usec가 0이 아닌 경우:
    ◦ 지정된 초와 마이크로초만큼 대기합니다. 즉, 해당 시간 동안 코드 실행을 일시정지합니다.

 **fd_set operation functions**

- § FD_ZERO(fd_set *fd_set); /* Clear all bits in fdset */
- § FD_SET(int fd, fd_set *fdset); /* turn the bit for fd on */
- § FD_CLR(int fd, fd_set *fdset); /* turn the bif for fd off */
- § FD_ISSET(int fd, fd_set *fdset); /* test the bif for fd */

간단한 예시:

```c
#include <stdio.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <sys/un.h>
#include <signal.h>
#include <sys/time.h>
#include <unistd.h>
#include "select.h"

int	TcpSockfd;
int	UdpSockfd;
int	UcoSockfd;
int	UclSockfd;

void
CloseServer()
{
	close(TcpSockfd);
	close(UdpSockfd);
	close(UcoSockfd);
	close(UclSockfd);
	if (remove(UNIX_STR_PATH) < 0)  {
		perror("remove");
	}
	if (remove(UNIX_DG_PATH) < 0)  {
		perror("remove");
	}

	printf("\nServer daemon exit.....\n");

	exit(0);
}

void
MakeTcpSocket()
{
	struct sockaddr_in	servAddr;

	if ((TcpSockfd = socket(PF_INET, SOCK_STREAM, 0)) < 0)  {
		perror("socket");
		exit(1);
	}

	bzero((char *)&servAddr, sizeof(servAddr));
	servAddr.sin_family = PF_INET;
	servAddr.sin_addr.s_addr = htonl(INADDR_ANY);
	servAddr.sin_port = htons(SERV_TCP_PORT);

	if (bind(TcpSockfd, (struct sockaddr *) &servAddr, sizeof(servAddr)) < 0)  {
		perror("bind");
		exit(1);
	}

	listen(TcpSockfd, 5);
}

void
MakeUdpSocket()
{
	struct sockaddr_in	servAddr;

	if ((UdpSockfd = socket(PF_INET, SOCK_DGRAM, 0)) < 0)  {
		perror("socket");
		exit(1);
	}

	bzero((char *)&servAddr, sizeof(servAddr));
	servAddr.sin_family = PF_INET;
	servAddr.sin_addr.s_addr = htonl(INADDR_ANY);
	servAddr.sin_port = htons(SERV_UDP_PORT);

	if (bind(UdpSockfd, (struct sockaddr *) &servAddr, sizeof(servAddr)) < 0)  {
		perror("bind");
		exit(1);
	}

}

void
MakeUcoSocket()
{
	struct sockaddr_un	servAddr;
	int					servAddrLen;

	if ((UcoSockfd = socket(PF_UNIX, SOCK_STREAM, 0)) < 0)  {
		perror("socket");
		exit(1);
	}

	bzero((char *)&servAddr, sizeof(servAddr));
	servAddr.sun_family = PF_UNIX;
	strcpy(servAddr.sun_path, UNIX_STR_PATH);
	servAddrLen = strlen(servAddr.sun_path) + sizeof(servAddr.sun_family);

	if (bind(UcoSockfd, (struct sockaddr *) &servAddr, servAddrLen) < 0)  {
		perror("bind");
		exit(1);
	}

	listen(UcoSockfd, 5);

}

void
MakeUclSocket()
{
	struct sockaddr_un	servAddr;
	int					servAddrLen;

	if ((UclSockfd = socket(PF_UNIX, SOCK_DGRAM, 0)) < 0)  {
		perror("socket");
		exit(1);
	}

	bzero((char *)&servAddr, sizeof(servAddr));
	servAddr.sun_family = PF_UNIX;
	strcpy(servAddr.sun_path, UNIX_DG_PATH);
	servAddrLen = strlen(servAddr.sun_path) + sizeof(servAddr.sun_family);

	if (bind(UclSockfd, (struct sockaddr *) &servAddr, servAddrLen) < 0)  {
		perror("bind");
		exit(1);
	}

}

void
ProcessTcpRequest()
{
	int					newSockfd, cliAddrLen, n;
	struct sockaddr_in	cliAddr;
	MsgType				msg;

	cliAddrLen = sizeof(cliAddr);
	newSockfd = accept(TcpSockfd, (struct sockaddr *) &cliAddr, &cliAddrLen);
	if (newSockfd < 0)  {
		perror("accept");
		exit(1);
	}
		
	if ((n = read(newSockfd, (char *)&msg, sizeof(msg))) < 0)  {
		perror("read");
		exit(1);
	}
	printf("Received TCP request: %s.....", msg.data);

	msg.type = MSG_REPLY;
	sprintf(msg.data, "This is a reply from %d.", getpid());
	if (write(newSockfd, (char *)&msg, sizeof(msg)) < 0)  {
		perror("write");
		exit(1);
	}
	printf("Replied.\n");

	close(newSockfd);
}

void
ProcessUdpRequest()
{
	int					cliAddrLen, n;
	struct sockaddr_in	cliAddr;
	MsgType				msg;

	cliAddrLen = sizeof(cliAddr);
	if ((n = recvfrom(UdpSockfd, (char *)&msg, sizeof(msg), 
				0, (struct sockaddr *)&cliAddr, &cliAddrLen)) < 0)  {
		perror("recvfrom");
		exit(1);
	}
	printf("Received UDP request: %s.....", msg.data);

	msg.type = MSG_REPLY;
	sprintf(msg.data, "This is a reply from %d.", getpid());
	if (sendto(UdpSockfd, (char *)&msg, sizeof(msg),
				0, (struct sockaddr *)&cliAddr, cliAddrLen) < 0)  {
		perror("sendto");
		exit(1);
	}
	printf("Replied.\n");
}

void
ProcessUcoRequest()
{
	int					newSockfd, cliAddrLen, n;
	struct sockaddr_un	cliAddr;
	MsgType				msg;

	cliAddrLen = sizeof(cliAddr);
	newSockfd = accept(UcoSockfd, (struct sockaddr *) &cliAddr, &cliAddrLen);
	if (newSockfd < 0)  {
		perror("accept");
		exit(1);
	}
		
	if ((n = read(newSockfd, (char *)&msg, sizeof(msg))) < 0)  {
		perror("read");
		exit(1);
	}
	printf("Received UNIX-domain CO request: %s.....", msg.data);

	msg.type = MSG_REPLY;
	sprintf(msg.data, "This is a reply from %d.", getpid());
	if (write(newSockfd, (char *)&msg, sizeof(msg)) < 0)  {
		perror("write");
		exit(1);
	}
	printf("Replied.\n");

	close(newSockfd);
}

void
ProcessUclRequest()
{
	int					cliAddrLen, n;
	struct sockaddr_un	cliAddr;
	MsgType				msg;

	cliAddrLen = sizeof(cliAddr);
	if ((n = recvfrom(UclSockfd, (char *)&msg, sizeof(msg), 
				0, (struct sockaddr *)&cliAddr, &cliAddrLen)) < 0)  {
		perror("recvfrom");
		exit(1);
	}
	printf("Received UNIX-domain CL request: %s.....", msg.data);

	msg.type = MSG_REPLY;
	sprintf(msg.data, "This is a reply from %d.", getpid());
	if (sendto(UclSockfd, (char *)&msg, sizeof(msg),
				0, (struct sockaddr *)&cliAddr, cliAddrLen) < 0)  {
		perror("sendto");
		exit(1);
	}
	printf("Replied.\n");
}

main(int argc, char *argv[])
{
	fd_set	fdvar;
	int		count;

	signal(SIGINT, CloseServer);

	MakeTcpSocket();
	MakeUdpSocket();
	MakeUcoSocket();
	MakeUclSocket();

	printf("Server daemon started.....\n");

	while (1)  {
		FD_ZERO(&fdvar);
		FD_SET(TcpSockfd, &fdvar);
		FD_SET(UdpSockfd, &fdvar);
		FD_SET(UcoSockfd, &fdvar);
		FD_SET(UclSockfd, &fdvar);
		if ((count = select(10, &fdvar, (fd_set *)NULL, (fd_set *)NULL, 
			(struct timeval *)NULL)) < 0)  {
			perror("select");
			exit(1);
		}
		while (count--)  {
			if (FD_ISSET(TcpSockfd, &fdvar))  {
				ProcessTcpRequest();
			}
			else if (FD_ISSET(UdpSockfd, &fdvar))  {
				ProcessUdpRequest();
			}
			else if (FD_ISSET(UcoSockfd, &fdvar))  {
				ProcessUcoRequest();
			}
			else if (FD_ISSET(UclSockfd, &fdvar))  {
				ProcessUclRequest();
			}
		}
	}
}
```

이 예시에서는 파일 디스크립터 `sockfd1`과 `sockfd2`를 생성하고 설정한 후, `select` 함수를 사용하여 읽기 작업을 감시합니다. `readfds` 파일 디스크립터 집합을 초기화한 후, 원하는 파일 디스크립터를 집합에 추가합니다.

또한, `timeout` 값을 설정하여 타임아웃을 5초로 지정합니다.

`select` 함수를 호출하여 준비된 디스크립터의 개수를 확인합니다. 반환값에 따라 준비된 디스크립터의 개수, 타임아웃 발생 여부, 에러 발생 여부를 출력합니다.

/end

# readv

```c
ssize_t readv(int fd, struct iovec iov[], int iovcnt);
```

헤더:

```c
#include <sys/types.h>
#include <sys/uio.h>

```

- 설명: readv 함수는 여러 개의 버퍼에 산재되어 있는 데이터를 한 번의 시스템 호출로 읽어옵니다. 각 버퍼는 struct iovec 구조체로 정의되며, iov[] 배열에 저장됩니다.
- 파라미터:
    - fd: 파일 디스크립터, 읽기 작업을 수행할 파일을 가리키는 파일 디스크립터입니다.
    - iov: struct iovec 구조체의 배열입니다. 각 요소는 읽을 데이터의 버퍼 주소와 크기를 담고 있습니다.
    - iovcnt: iov 배열의 요소 개수입니다.
    - 
- 반환값: 성공 시 읽어온 바이트 수, 오류 시 -1을 반환합니다.

/end

# writev

```c
ssize_t writev(int fd, struct iovec iov[], int iovcnt);
```

- 설명: writev 함수는 여러 개의 버퍼에 분산되어 있는 데이터를 한 번의 시스템 호출로 쓰입니다. 각 버퍼는 struct iovec 구조체로 정의되며, iov[] 배열에 저장됩니다.
- 파라미터:
    - fd: 파일 디스크립터, 쓰기 작업을 수행할 파일을 가리키는 파일 디스크립터입니다.
    - iov: struct iovec 구조체의 배열입니다. 각 요소는 쓸 데이터의 버퍼 주소와 크기를 담고 있습니다.
    - iovcnt: iov 배열의 요소 개수입니다.
- 반환값: 성공 시 쓴 바이트 수, 오류 시 -1을 반환합니다.

struct iovec:

```c
struct iovec {
    void *iov_base; /* 버퍼의 시작 주소 */
    size_t iov_len; /* 버퍼의 크기 */
};
```

- 설명: struct iovec는 readv와 writev 함수에서 사용되는 구조체로, 데이터의 버퍼 주소와 크기를 저장합니다. iov_base는 버퍼의 시작 주소를 가리키는 포인터이며, iov_len은 버퍼의 크기를 나타냅니다.

예시:

```c
#include <stdio.h>
#include <sys/types.h>
#include <sys/uio.h>

int main() {
    int fd = open("file.txt", O_RDONLY); // 파일 열기

    struct iovec iov[2]; // iovec 구조체 배열 생성
    char buffer1[10]; // 첫 번째 버퍼
    char buffer2[20]; // 두 번째 버퍼

    iov[0].iov_base = buffer1; // 첫 번째 버퍼 주소 설정
    iov[0].iov_len = sizeof(buffer1); // 첫 번째 버퍼 크기 설정

    iov[1].iov_base = buffer2; // 두 번째 버퍼 주소 설정
    iov[1].iov_len = sizeof(buffer2); // 두 번째 버퍼 크기 설정

    ssize_t bytesRead = readv(fd, iov, 2); // 파일에서 데이터 읽기

    if (bytesRead == -1) {
        perror("readv");
        return 1;
    }

    printf("Read %ld bytes from file.\\n", bytesRead);

    close(fd); // 파일 닫기

    return 0;
}

```

위의 예시는 readv 함수를 사용하여 파일에서 데이터를 읽어오는 간단한 예시입니다. 먼저 파일을 열고, struct iovec 배열을 생성하고 각 버퍼의 주소와 크기를 설정합니다. 그런 다음 readv 함수를 호출하여 파일에서 데이터를 읽어옵니다. 읽어온 바이트 수를 출력한 후 파일을 닫습니다.

/end

# sendmsg

헤더:

```c
#include <sys/types.h>
#include <sys/socket.h>
```

```c
ssize_t sendmsg(int sd, struct msghdr *msg, int flags);
```

- 설명: sendmsg 함수는 scatter/gather 방식으로 데이터를 전송합니다. 여러 개의 버퍼에 산재되어 있는 데이터를 한 번의 시스템 호출로 전송할 수 있습니다. 메시지의 내용과 속성은 struct msghdr 구조체로 정의되며, msg 포인터를 통해 전달됩니다.
- 파라미터:
    - sd: 소켓 디스크립터, 데이터를 전송할 소켓을 가리키는 소켓 디스크립터입니다.
    - msg: struct msghdr 구조체 포인터, 전송할 메시지의 내용과 속성을 담고 있습니다.
    - flags: 전송에 대한 옵션 플래그입니다.
- 반환값: 성공 시 전송한 바이트 수, 오류 시 -1을 반환합니다.

/end

# recvmsg

```c
ssize_t recvmsg(int sd, struct msghdr *msg, int flags);
```

- 설명: recvmsg 함수는 scatter/gather 방식으로 데이터를 수신합니다. 한 번의 시스템 호출로 여러 개의 버퍼에 분산되어 있는 데이터를 수신할 수 있습니다. 메시지의 내용과 속성은 struct msghdr 구조체로 정의되며, msg 포인터를 통해 전달됩니다.
- 파라미터:
    - sd: 소켓 디스크립터, 데이터를 수신할 소켓을 가리키는 소켓 디스크립터입니다.
    - msg: struct msghdr 구조체 포인터, 수신한 메시지의 내용과 속성을 담고 있습니다.
    - flags: 수신에 대한 옵션 플래그입니다.
- 반환값: 성공 시 수신한 바이트 수, 오류 시 -1을 반환합니다.

struct msghdr:

```c
struct msghdr {
    caddr_t msg_name;        /* 옵션으로 사용할 주소 */
    int msg_namelen;         /* 주소의 크기 */
    struct iovec *msg_iov;   /* scatter/gather 배열 */
    int msg_iovlen;          /* msg_iov 배열의 요소 개수 */
    caddr_t msg_accrights;   /* 접근 권한 */
    int msg_accrightslen;    /* 접근 권한의 크기 */
};

```

- 설명: struct msghdr는 sendmsg와 recvmsg 함수에서 사용되는 구조체로, 메시지의 속성과 데이터를 담고 있습니다. msg_name은 옵션으로 사용되는 주소를 가리키는 포인터이며, msg_namelen은 주소의 크기를 나타냅니다. msg_iov는 scatter/gather 배열을 가리키는 포인터이며, msg_iovlen은 msg_iov 배열의 요소 개수를 나타냅니다. msg_accrights와 msg_accrightslen은 접근 권한과 그 크기를 나타냅니다.

예시:

```c
#include <stdio.h>
#include <sys/types.h>
#include <sys/socket.h>

int main() {
    int sockfd = socket(AF_INET, SOCK_STREAM, 0); // 소켓 생성

    struct msghdr msg; // msghdr 구조체 생성
    struct iovec iov[2]; // iovec 구조체 배열 생성
    char buffer1[10] = "Hello, ";
    char buffer2[10] = "World!";

    iov[0].iov_base = buffer1; // 첫 번째 버퍼 주소 설정
    iov[0].iov_len = sizeof(buffer1); // 첫 번째 버퍼 크기 설정

    iov[1].iov_base = buffer2; // 두 번째 버퍼 주소 설정
    iov[1].iov_len = sizeof(buffer2); // 두 번째 버퍼 크기 설정

    msg.msg_name = NULL; // 주소 설정하지 않음
    msg.msg_namelen = 0;
    msg.msg_iov = iov; // iovec 구조체 배열 설정
    msg.msg_iovlen = 2; // iovec 배열의 요소 개수 설정
    msg.msg_accrights = NULL; // 접근 권한 설정하지 않음
    msg.msg_accrightslen = 0;

    ssize_t bytesSent = sendmsg(sockfd, &msg, 0); // 데이터 전송

    if (bytesSent == -1) {
        perror("sendmsg");
        return 1;
    }

    printf("Sent %ld bytes.
", bytesSent);

    close(sockfd); // 소켓 닫기

    return 0;
}

```

/end

# getsockopt

헤더:

```c
#include <sys/types.h>
#include <sys/socket.h>

```

```c
int getsockopt(int sd, int level, int optname, char *optval, int *optlen);
```

- 설명: getsockopt 함수는 소켓 옵션의 값을 조회합니다. 지정한 소켓과 옵션에 대한 값을 얻을 수 있습니다.
- 파라미터:
    - sd: 소켓 디스크립터, 소켓 옵션을 조회할 소켓을 가리키는 소켓 디스크립터입니다.
    - level: 옵션 레벨, 조회할 옵션의 레벨을 지정합니다. 일반적으로 SOL_SOCKET을 사용합니다
    
    - optname: 옵션 이름, 조회할 옵션의 이름을 지정합니다.
    - optval: 옵션 값 버퍼, 조회한 옵션 값을 저장할 버퍼의 포인터입니다.
    - optlen: 옵션 값 버퍼의 크기, optval 버퍼의 크기를 나타냅니다. 조회된 옵션 값의 크기가 저장됩니다.
- 반환값: 성공 시 0, 오류 시 -1을 반환합니다.

/end

# setsockopt

```c
int setsockopt(int sd, int level, int optname, const char *optval, int optlen);
```

- 설명: setsockopt 함수는 소켓 옵션의 값을 설정합니다. 지정한 소켓과 옵션에 대한 값을 설정할 수 있습니다.
- 파라미터:
    - sd: 소켓 디스크립터, 소켓 옵션을 설정할 소켓을 가리키는 소켓 디스크립터입니다.
    - level: 옵션 레벨, 설정할 옵션의 레벨을 지정합니다. 일반적으로 SOL_SOCKET을 사용합니다.
    - optname: 옵션 이름, 설정할 옵션의 이름을 지정합니다.
    - optval: 옵션 값 버퍼, 설정할 옵션 값을 담고 있는 버퍼의 포인터입니다.
    - optlen: 옵션 값 버퍼의 크기, optval 버퍼의 크기를 나타냅니다.
- 반환값: 성공 시 0, 오류 시 -1을 반환합니다.

fcntl & ioctl:

- 설명: fcntl과 ioctl은 소켓 옵션 외에도 파일 디스크립터에 대한 다양한 조작을 수행하는 함수입니다. fcntl은 파일 디스크립터의 속성을 변경하거나 파일 잠금 등을 설정하는 데 사용되며, ioctl은 파일 디스크립터에 대한 특정 동작을 수행하기 위해 사용됩니다. 소켓 옵션과는 관련이 있지만 약간 다른 용도로 사용됩니다.

예시:

```c
#include <stdio.h>
#include <sys/types.h>
#include <sys/socket.h>

int main() {
    int sockfd = socket(AF_INET, SOCK_STREAM, 0); // 소켓 생성

    int optionValue;
    socklen_t optionLen = sizeof(optionValue);

    // SO_REUSEADDR 옵션 조회
    int getOptResult = getsockopt(sockfd, SOL_SOCKET, SO_REUSEADDR, (char *)&optionValue, &optionLen);
    if (getOptResult == -1) {
        perror("getsockopt");
        return 1;
    }

    printf("SO_REUSEADDR option value: %d
", optionValue);

    // SO_REUSEADDR 옵션 설정
    int optionValueNew = 1;
    int setOptResult = setsockopt(sockfd, SOL_SOCKET, SO_REUSEADDR, (const char *)&optionValueNew, sizeof(optionValueNew));
    if (setOptResult == -1) {
        perror("setsockopt");
        return 1;
    }

    printf("SO_REUSEADDR option set to 1
");

    close(sockfd); // 소켓 닫기

    return 0;
}

```

위의 예시는 getsockopt와 setsockopt 함수를 사용하여 SO_REUSEADDR 옵션을 조회하고 설정하는 간단한 예시입니다. 먼저 소켓을 생성한 후 getsockopt 함수를 호출하여 SO_REUSEADDR 옵션의 값을 조회합니다. 조회한 값은 optionValue 변수에 저장되고 출력됩니다. 그런 다음 setsockopt 함수를 호출하여 SO_REUSEADDR 옵션의 값을 1로 설정합니다. 설정 후 "SO_REUSEADDR option set to 1"이 출력됩니다. 소켓을 닫습니다.

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/dfa28d76-5333-40b3-9780-fbbeab3c8ca0/27c7a355-d3d1-4832-910d-7f6cb619738a/Untitled.png)

/end

# 헤더파일

```c
#include <stdio.h>
#include <stdlib.h>
#include <signal.h>
#include <sys/types.h>
#include <unistd.h>
#include <pthread.h>
#include <sys/ipc.h>
#include <sys/shm.h>
#include <sys/mman.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <sys/uio.h>
#include <sys/stat.h>
#include <sys/msg.h>
#include <netdb.h>
#include <string.h>
```

/end

# 커스텀 헤더파일

# 통합

```jsx
#define	SMAX	20
#define	NMAX	10
#define	DMAX	15
#define	MAX_FIFO_NAME	32
#define	SERV_FIFO	"./.fifo"
#define	MY_ID			17
#define	MSG_KEY			(0x8000 + MY_ID)
#define	MSG_REQUEST		1
#define	MSG_REPLY		2
#define	SHM_KEY		(0x9000 + MY_ID)
#define	SHM_SIZE	1024
#define	SHM_MODE	(SHM_R | SHM_W | IPC_CREAT)
#define	EMPTY_SEM_KEY	(0x5000 + MY_ID)
#define	FULL_SEM_KEY	(0x6000 + MY_ID)
#define	MUTEX_SEM_KEY	(0x7000 + MY_ID)
#define	MAX_BUF			2
#define	SERV_TCP_PORT	(7000 + MY_ID)
#define	SERV_HOST_ADDR	"127.0.0.1"
#define	SERV_UDP_PORT	(8000 + MY_ID)
#define	UNIX_STR_PATH	"./.unix-str"
#define	UNIX_DG_PATH	"./.unix-dg"

#include <sys/types.h>
#include <sys/ipc.h>
#include <sys/sem.h>
#include <pthread.h>

typedef struct  {
	int		data;
}
	ItemType;

typedef struct  {
	ItemType	buf[MAX_BUF];
	int			in;
	int			out;
	int			counter;
}
	BoundedBufferType;

#define	SHM_SIZE	sizeof(BoundedBufferType)

typedef struct  {
	long	type;
	char	data[128];
}
	MsgType;

typedef struct {
	char	stud[SMAX];
	char	num[NMAX];
	char	dept[DMAX];
} Record;

typedef struct  {
	char	returnFifo[MAX_FIFO_NAME];
	char	data[128];
}
	FifoMsgType;

void TELL_WAIT(void);
void TELL_PARENT(void);
void WAIT_PARENT(void);
void TELL_CHILD(void);
void WAIT_CHILD(void);

int		semInit(key_t key);
int		semInitValue(int semid, int value);
int		semWait(int semid);
int		semTryWait(int semid);
int		semPost(int semid);
int		semGetValue(int semid);
int		semDestroy(int semid);

typedef struct  {
	int		sval;
	pthread_mutex_t	mutex;
	pthread_cond_t	cond;
}
	sem_t;

int		sem_init(sem_t *sem, int pshared, int value);
int		sem_wait(sem_t *sem);
int		sem_trywait(sem_t *sem);
int		sem_post(sem_t *sem);
int		sem_getvalue(sem_t *sem, int *sval);
int		sem_destroy(sem_t *sem);

typedef struct  {
	char	info[8];
}
	HeaderType;
```

# record.h

```c
#define	SMAX	20
#define	NMAX	10
#define	DMAX	15

typedef struct {
	char	stud[SMAX];
	char	num[NMAX];
	char	dept[DMAX];
} Record;
```

# synclib.h

```c
void TELL_WAIT(void);
void TELL_PARENT(void);
void WAIT_PARENT(void);
void TELL_CHILD(void);
void WAIT_CHILD(void);
```

# synclib.c

```c
#include <stdio.h>
#include <sys/types.h>
#include <unistd.h>

static int	Pfd1[2], Pfd2[2];

void
TELL_WAIT(void)
{
	if (pipe(Pfd1) < 0 || pipe(Pfd2) < 0)  {
		perror("pipe");
		exit(1);
	}
}

void
TELL_PARENT(void)
{
	if (write(Pfd2[1], "c", 1) != 1)  {
		perror("write");
		exit(1);
	}
}

void
WAIT_PARENT(void)
{
	char	c;

	if (read(Pfd1[0], &c, 1) != 1)  {
		perror("read");
		exit(1);
	}
	if (c != 'p')  {
		fprintf(stderr, "WAIT_PARENT: incorrect data");
		exit(1);
	}
}

void
TELL_CHILD(void)
{
	if (write(Pfd1[1], "p", 1) != 1)  {
		perror("write");
		exit(1);
	}
}

void
WAIT_CHILD(void)
{
	char	c;

	if (read(Pfd2[0], &c, 1) != 1)  {
		perror("read");
		exit(1);
	}
	if (c != 'c')  {
		fprintf(stderr, "WAIT_CHILD: incorrect data");
		exit(1);
	}
}
```

# fifo.h

```c
#define	MAX_FIFO_NAME	32

#define	SERV_FIFO	"./.fifo"

typedef struct  {
	char	returnFifo[MAX_FIFO_NAME];
	char	data[128];
}
	MsgType;
```

# msg.h

```c
#define	MY_ID			0
#define	MSG_KEY			(0x8000 + MY_ID)

#define	MSG_REQUEST		1
#define	MSG_REPLY		2

typedef struct  {
	long	type;
	char	data[128];
}
	MsgType;
```

# shm.h

```c
#define	MY_ID		17
#define	SHM_KEY		(0x9000 + MY_ID)
#define	SHM_SIZE	1024
#define	SHM_MODE	(SHM_R | SHM_W | IPC_CREAT)
```

# prodcons.h

```c
#define	MY_ID			17
#define	SHM_KEY			(0x9000 + MY_ID)
#define	SHM_MODE		(SHM_R | SHM_W | IPC_CREAT)

#define	EMPTY_SEM_KEY	(0x5000 + MY_ID)
#define	FULL_SEM_KEY	(0x6000 + MY_ID)
#define	MUTEX_SEM_KEY	(0x7000 + MY_ID)

#define	NLOOPS			20

#define	MAX_BUF			2

typedef struct  {
	int		data;
}
	ItemType;

typedef struct  {
	ItemType	buf[MAX_BUF];
	int			in;
	int			out;
	int			counter;
}
	BoundedBufferType;

#define	SHM_SIZE	sizeof(BoundedBufferType)
```

# semlib.h

```c
#include <sys/types.h>
#include <sys/ipc.h>
#include <sys/sem.h>

int		semInit(key_t key);
int		semInitValue(int semid, int value);
int		semWait(int semid);
int		semTryWait(int semid);
int		semPost(int semid);
int		semGetValue(int semid);
int		semDestroy(int semid);
```

# semlib.c

```c
#include <stdio.h>
#include "semlib.h"
 
 
int
semInit(key_t key)
{
    int     semid;

    if ((semid = semget(key, 1, 0600 | IPC_CREAT)) < 0)  {
		perror("semget");
        return -1;
    }

    return semid;
}
 
int
semInitValue(int semid, int value)
{
    union semun {
            int     val;
    } semun;

    semun.val = value;
    if (semctl(semid, 0, SETVAL, semun) < 0)  {
		perror("semctl");
        return -1;
    }
 
    return semid;
}
 
int
semWait(int semid)
{
    struct sembuf   semcmd;
 
    semcmd.sem_num = 0;
    semcmd.sem_op = -1;
    semcmd.sem_flg = SEM_UNDO;
    if (semop(semid, &semcmd, 1) < 0)  {
		perror("semop");
        return -1;
    }
 
    return 0;
}
 
int
semTryWait(int semid)
{
    struct sembuf   semcmd;
 
    semcmd.sem_num = 0;
    semcmd.sem_op = -1;
    semcmd.sem_flg = IPC_NOWAIT | SEM_UNDO;
    if (semop(semid, &semcmd, 1) < 0)  {
		perror("semop");
        return -1;
    }
 
    return 0;
}

int
semPost(int semid)
{
    struct sembuf   semcmd;
 
    semcmd.sem_num = 0;
    semcmd.sem_op = 1;
    semcmd.sem_flg = SEM_UNDO;
    if (semop(semid, &semcmd, 1) < 0)  {
		perror("semop");
        return -1;
    }
 
    return 0;
}

int
semGetValue(int semid)
{
    union semun {
            int     val;
    } dummy;
 
    return semctl(semid, 0, GETVAL, dummy);
}
 
int
semDestroy(int semid)
{
    union semun {
            int     val;
    } dummy;
 
    if (semctl(semid, 0, IPC_RMID, dummy) < 0)  {
		perror("semctl");
        return -1;
    }
    close(semid);
 
    return 0;
}
```

# semlib2.h

```c
#include <pthread.h>

typedef struct  {
	int		sval;
	pthread_mutex_t	mutex;
	pthread_cond_t	cond;
}
	sem_t;

int		sem_init(sem_t *sem, int pshared, int value);
int		sem_wait(sem_t *sem);
int		sem_trywait(sem_t *sem);
int		sem_post(sem_t *sem);
int		sem_getvalue(sem_t *sem, int *sval);
int		sem_destroy(sem_t *sem);
```

# semlib2.c

```c
#include <stdio.h>
#include <pthread.h>
#include "semlib2.h"

int
sem_init(sem_t *sem, int pshared, int value)
{
	if (pshared)  {
		fprintf(stderr, "Function not supported\n");
		return -1;
	}

	if (pthread_mutex_init(&sem->mutex, NULL) < 0)
		return -1;

	if (pthread_cond_init(&sem->cond, NULL) < 0)
		return -1;

	sem->sval = value;

	return 0;
}

int
sem_wait(sem_t *sem)
{
	if (pthread_mutex_lock(&sem->mutex) < 0)
		return -1;

	if (sem->sval == 0)  {
		while (sem->sval == 0)  {
			if (pthread_cond_wait(&sem->cond, &sem->mutex) < 0)  {
				if (pthread_mutex_unlock(&sem->mutex) < 0)
					return -1;
				return -1;
			}
		}
		sem->sval--;
	}
	else  {
		sem->sval--;
	}

	if (pthread_mutex_unlock(&sem->mutex) < 0)
		return -1;

	return 0;
}

int
sem_trywait(sem_t *sem)
{
	if (pthread_mutex_lock(&sem->mutex) < 0)
		return -1;

	if (sem->sval == 0)  {
		if (pthread_mutex_unlock(&sem->mutex) < 0)
			return -1;
		return -1;
	}
	else  {
		sem->sval--;
	}

	if (pthread_mutex_unlock(&sem->mutex) < 0)
		return -1;

	return 0;
}

int
sem_post(sem_t *sem)
{
	if (pthread_mutex_lock(&sem->mutex) < 0)
		return -1;

	if (sem->sval == 0)  {
		if (pthread_cond_signal(&sem->cond) < 0)  {
			if (pthread_mutex_unlock(&sem->mutex) < 0)
				return -1;
			return -1;
		}
	}

	sem->sval++;

	if (pthread_mutex_unlock(&sem->mutex) < 0)
		return -1;

	return 0;
}

int
sem_getvalue(sem_t *sem, int *sval)
{
	*sval = sem->sval;

	return 0;
}

int
sem_destroy(sem_t *sem)
{
	if (pthread_mutex_destroy(&sem->mutex) < 0)
		return -1;

	if (pthread_cond_destroy(&sem->cond) < 0)
		return -1;

	return 0;
}
```

# tcp.h

```c
#define	MY_ID			0

#define	SERV_TCP_PORT	(7000 + MY_ID)
#define	SERV_HOST_ADDR	"127.0.0.1"

#define	MSG_REQUEST		1
#define	MSG_REPLY		2

typedef struct  {
	int		type;
	char	data[128];
}
	MsgType;
```

# udp.h

```c
#define	MY_ID			0

#define	SERV_UDP_PORT	(8000 + MY_ID)
#define	SERV_HOST_ADDR	"127.0.0.1"

#define	MSG_REQUEST		1
#define	MSG_REPLY		2

typedef struct  {
	int		type;
	char	data[128];
}
	MsgType;
```

# select.h

```c
#define	MY_ID			0

#define	SERV_TCP_PORT	(7000+MY_ID)
#define	SERV_UDP_PORT	(8000+MY_ID)
#define	UNIX_STR_PATH	"./.unix-str"
#define	UNIX_DG_PATH	"./.unix-dg"

#define	MSG_REQUEST		1
#define	MSG_REPLY		2

typedef struct  {
	int		type;
	char	data[128];
}
	MsgType;
```

# sg.h

```c
#define	MY_ID			0

#define	SERV_TCP_PORT	(9000 + MY_ID)
#define	SERV_HOST_ADDR	"127.0.0.1"

#define	MSG_REQUEST		1
#define	MSG_REPLY		2

typedef struct  {
	int		type;
	char	data[128];
}
	MsgType;

typedef struct  {
	char	info[8];
}
	HeaderType;
```

/end

# 기출문제

## napp.c

```c
#include <stdio.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <sys/uio.h>
#include <sys/stat.h>
#include <sys/msg.h>
#include "header.h"
#include <stdlib.h>
#include <unistd.h>
#include <string.h>
#include <fcntl.h>
#include <signal.h>
#include <sys/wait.h>
#include <errno.h>
#include <sys/ipc.h>
#include <sys/shm.h>
#include <sys/sem.h>
#include <sys/time.h>
#include <time.h>

int Calc(int number)
{
        int                     sockfd, n;
        struct sockaddr_in      servAddr;
        MsgType                 msg;

        if ((sockfd = socket(PF_INET, SOCK_STREAM, 0)) < 0)  {
                perror("socket");
                exit(1);
        }

        bzero((char *)&servAddr, sizeof(servAddr));
        bzero((char *)&msg, sizeof(msg));
        bzero((char *)&msg.data, sizeof(msg.data));
        bzero((char *)&msg.type, sizeof(msg.type));

        servAddr.sin_family = PF_INET;
        servAddr.sin_addr.s_addr = inet_addr(SERV_HOST_ADDR);
        servAddr.sin_port = htons(SERV_TCP_PORT);

        if (connect(sockfd, (struct sockaddr *) &servAddr, sizeof(servAddr)) < 0)  {
                perror("connect");
                exit(1);
        }

        msg.type = MSG_REQUEST;
        sprintf(msg.data, "%d", number);
        if (write(sockfd, (char *)&msg, sizeof(msg)) < 0)  {
                perror("write");
                exit(1);
        }

        printf("Sent a request.....%s\n", msg.data);

        if ((n = read(sockfd, (char *)&msg, sizeof(msg))) < 0)  {
                perror("read");
                exit(1);
        }
        printf("Received reply: %s\n", msg.data);
        return atoi(msg.data);

        close(sockfd);
}

int main(int argc, char *argv[]){
    int result;
    result = Calc(atoi(argv[1]));

    printf("result = %d\n", result);
}
```

## nrpc.c

```c
#include <stdio.h>
#include <stdlib.h>
#include <signal.h>
#include <sys/types.h>
#include <unistd.h>
#include <pthread.h>
#include <sys/ipc.h>
#include <sys/shm.h>
#include <sys/mman.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <sys/uio.h>
#include <sys/stat.h>
#include <sys/msg.h>
#include "header.h"

int            Sockfd;

#include <arpa/inet.h>

void
CloseServer()
{
        close(Sockfd);
        printf("\nTCP Server exit.....\n");

        exit(0);
}

main(int argc, char *argv[])
{
        int                                     newSockfd, cliAddrLen, n;
        struct sockaddr_in      cliAddr, servAddr;
        MsgType                         msg;

        signal(SIGINT, CloseServer);

        if ((Sockfd = socket(PF_INET, SOCK_STREAM, 0)) < 0)  {
                perror("socket");
                exit(1);
        }

        bzero((char *)&servAddr, sizeof(servAddr));
        bzero((char *)&cliAddr, sizeof(cliAddr));
        bzero((char *)&msg, sizeof(msg));

        servAddr.sin_family = PF_INET;
        servAddr.sin_addr.s_addr = htonl(INADDR_ANY);
        servAddr.sin_port = htons(SERV_TCP_PORT);

        if (bind(Sockfd, (struct sockaddr *) &servAddr, sizeof(servAddr)) < 0)  {
                perror("bind");
                exit(1);
        }

        listen(Sockfd, 5);

        printf("TCP Server started.....\n");

        cliAddrLen = sizeof(cliAddr);
        while (1)  {
                newSockfd = accept(Sockfd, (struct sockaddr *) &cliAddr, &cliAddrLen);
                if (newSockfd < 0)  {
                        perror("accept");
                        exit(1);
                }

                if ((n = read(newSockfd, (char *)&msg, sizeof(msg))) < 0)  {
                        perror("read");
                        exit(1);
                }
                printf("Received request: %s.....", msg.data);
                int n = atoi(msg.data);
                int sum = 0;
                for(int i=0; i<n; i++) {
                        sum += i;
                }

                msg.type = MSG_REPLY;
                sprintf(msg.data, "%d", sum);

                if (write(newSockfd, (char *)&msg, sizeof(msg)) < 0)  {
                        perror("write");
                        exit(1);
                }
                printf("Replied.\n");

                usleep(10000);
                close(newSockfd);
        }
}
```

## app.c

```c
#include <stdio.h>
#include <stdlib.h>
#include <signal.h>
#include <sys/types.h>
#include <unistd.h>
#include <pthread.h>
#include <sys/ipc.h>
#include <sys/shm.h>
#include <sys/mman.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <sys/uio.h>
#include <sys/stat.h>
#include <sys/msg.h>
#include "header.h"

int Calc(int number){
        int     shmid;
        char    *ptr, *pData;
        int     *pInt;
        int     emptySemid, fullSemid, mutexSemid;

        if ((shmid = shmget(SHM_KEY, SHM_SIZE, SHM_MODE)) < 0)  {
                perror("shmget");
                exit(1);
        }

        if ((ptr = shmat(shmid, 0, 0)) == (void *) -1)  {
                perror("shmat");
                exit(1);
        }

        if((emptySemid = semInit(EMPTY_SEM_KEY)) < 0)  {
                perror("semInit");
                exit(1);
        }

        if((fullSemid = semInit(FULL_SEM_KEY)) < 0)  {
                perror("semInit");
                exit(1);
        }

        if((mutexSemid = semInit(MUTEX_SEM_KEY)) < 0)  {
                perror("semInit");
                exit(1);
        }

        if(semWait(emptySemid) < 0)  {
                perror("semWait");
                exit(1);
        }

        if(semWait(mutexSemid) < 0)  {
                perror("semWait");
                exit(1);
        }

        pInt = (int *)ptr;
        pData = ptr + sizeof(int);
        sprintf(pData, "%d", number);
        printf("Sent number: %s\n", pData);

        if(semPost(mutexSemid) < 0)  {
                perror("semPost");
                exit(1);
        }

            if(semPost(fullSemid) < 0)  {
                    perror("semPost");
                    exit(1);
            }

            if(semWait(emptySemid) < 0)  {
                    perror("semWait");
                    exit(1);
            }

            if(semWait(mutexSemid) < 0)  {
                    perror("semWait");
                    exit(1);
            }

            pInt = (int *)ptr;
            pData = ptr + sizeof(int);
            printf("Received result: %s\n", pData);

            if(semPost(mutexSemid) < 0)  {
                    perror("semPost");
                    exit(1);
            }
            return atoi(pData);

}

main()
{
        int result;
        result = Calc(10);
        printf("Result: %d\n", result);

        sleep(1);
}
```

## rpc.c

```c
#include <stdio.h>
#include <stdlib.h>
#include <signal.h>
#include <sys/types.h>
#include <unistd.h>
#include <pthread.h>
#include <sys/ipc.h>
#include <sys/shm.h>
#include <sys/mman.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <sys/uio.h>
#include <sys/stat.h>
#include <sys/msg.h>
#include "header.h"

int            emptySemid, fullSemid, mutexSemid, shmid;

void SIG_HANDLER(int sig)
{

        if(semDestroy(emptySemid) < 0)  {
                perror("semDestroy");
                exit(1);
        }

        if(semDestroy(fullSemid) < 0)  {
                perror("semDestroy");
                exit(1);
        }

        if(semDestroy(mutexSemid) < 0)  {
                perror("semDestroy");
                exit(1);
        }

        if(shmctl(shmid, IPC_RMID, 0) < 0)  {
                perror("shmctl");
                exit(1);
        }

        if (sig == SIGINT)  {
                printf("SIGINT received.\n");
                exit(0);
        }
}

main()
{
        char    *ptr, *pData;
        int             *pInt;

        signal(SIGINT, SIG_HANDLER);

        if ((shmid = shmget(SHM_KEY, SHM_SIZE, SHM_MODE)) < 0)  {
                perror("shmget");
                exit(1);
        }
        if ((ptr = shmat(shmid, 0, 0)) == (void *) -1)  {
                perror("shmat");
                exit(1);
        }
        if((emptySemid = semInit(EMPTY_SEM_KEY)) < 0)  {
                perror("semInit");
                exit(1);
        }
        if((fullSemid = semInit(FULL_SEM_KEY)) < 0)  {
                perror("semInit");
                exit(1);
        }
        if((mutexSemid = semInit(MUTEX_SEM_KEY)) < 0)  {
                perror("semInit");
                exit(1);
        }

        if(semInitValue(emptySemid, 1) < 0)  {
                perror("semInitValue");
                exit(1);
        }

        if(semInitValue(fullSemid, 0) < 0)  {
                perror("semInitValue");
                exit(1);
        }
        if(semInitValue(mutexSemid, 1) < 0)  {
                perror("semInitValue");
                exit(1);
        }

        while(1){
            if(semWait(fullSemid) < 0)  {
                    perror("semWait");
                    exit(1);
            }

            if(semWait(mutexSemid) < 0)  {
                    perror("semWait");
                    exit(1);
            }

            pInt = (int *)ptr;
            pData = ptr + sizeof(int);
            printf("Received request: %s.....", pData);

            int sum = 0;
            for(int i =0; i <= atoi(pData); i++){
                sum = sum + i;
                printf("%d ", i);
            }

            sprintf(pData, "%d", sum);
            printf("%d\n", sum);

            *pInt = 0;
            printf("Replied.\n");

            if(semPost(mutexSemid) < 0)  {
                    perror("semPost");
                    exit(1);
            }

            if(semPost(emptySemid) < 0)  {
                    perror("semPost");
                    exit(1);
            }

            sleep(1);
        }

}
```

## 기출 fifos.c

```c
#include <stdio.h>
#include <stdlib.h>
#include <signal.h>
#include <sys/types.h>
#include <unistd.h>
#include <pthread.h>
#include <sys/ipc.h>
#include <sys/shm.h>
#include <sys/mman.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <sys/uio.h>
#include <sys/stat.h>
#include <sys/msg.h>
#include <netdb.h>
#include "header.h"
#include <fcntl.h>
#include <errno.h>
#include <string.h>
#include <sys/wait.h>
#include <sys/un.h>

void
SigIntHandler(int signo)
{
        if (remove(SERV_FIFO) < 0)  {
                perror("remove");
                exit(1);
        }

        exit(0);
}

main()
{
        int                     fd, n;
    FILE *cfd;
        FifoMsgType             msg;

        if (signal(SIGINT, SigIntHandler) == SIG_ERR)  {
                perror("signal");
                exit(1);
        }

        if (mkfifo(SERV_FIFO, 0600) < 0)  {
                if (errno != EEXIST)  {
                        perror("mkfifo");
                        exit(1);
                }
        }

        if ((fd = open(SERV_FIFO, O_RDWR)) < 0)  {
                perror("open");
                exit(1);
        }

        while (1)  {
                if ((n = read(fd, (char *)&msg, sizeof(msg))) < 0)  {
                        if (errno == EINTR)  {
                                continue;
                        }
                        else  {
                                perror("read");
                                exit(1);
                        }
                }
                printf("Received request: %s.....", msg.data);

                // ./.fifo123 열기
		        char file_name[20];
		        sprintf(file_name, "./%s", msg.name);
                if ((cfd = fopen(msg.name, "at")) < 0)  {
                        perror("open");
                        exit(1);
                }
                fprintf(cfd, "This is a reply from %d.", getpid());
                fclose(cfd);
                printf("Replied.\n");
        }
}
```

## 기출: fifoc.c

#include <stdio.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <unistd.h>
#include <errno.h>
#include "header.h"
#include <stdlib.h>
#include <string.h>
#include <sys/wait.h>
#include <signal.h>
#include <sys/ipc.h>
#include <sys/msg.h>
#include <sys/shm.h>

main(int argc, char *argv[])
{
        char            fname[MAX_FIFO_NAME];
        int                     fd, sfd, n;
        FifoMsgType             msg;

    if(argc == 2){
        char command[100];
        sprintf(command, "cat %s", argv[1]);
        if(system(command) < 0){
            perror("system");
            exit(1);
        }
    }

        if ((sfd = open(SERV_FIFO, O_RDWR)) < 0)  {
                perror("open");
                exit(1);
        }

        sprintf(msg.name, "%s", argv[1]);
        sprintf(msg.data, "This is a request from %d.", getpid());
        write(sfd, (char *)&msg, sizeof(msg));
        printf("Sent a request.....");

        close(sfd);
}
#strtok

strtok 함수는 C 언어에서 문자열을 특정 구분자(delimiter)를 기준으로 토큰(token)으로 분리하는 함수입니다. 이 함수는 문자열에서 첫 번째 토큰을 찾고, 그 다음 호출부터는 이전에 찾은 토큰 이후의 부분에서 다음 토큰을 찾습니다. 다음은 strtok 함수의 사용법과 간단한 예제입니다.

strtok 함수의 사용법:
char *strtok(char *str, const char *delimiters);

str: 분리할 대상 문자열입니다. 첫 번째 호출 시에만 사용하며, 이후 호출에서는 NULL로 설정합니다.
delimiters: 토큰을 나눌 구분자 문자열입니다.

예제:
#include <stdio.h>
#include <string.h>

int main() {
    char str[] = "Hello,World,How,Are,You";
    const char delimiters[] = ",";

    // 첫 번째 호출
    char *token = strtok(str, delimiters);

    // 두 번째 이후 호출
    while (token != NULL) {
        printf("Token: %s\n", token);

        // 다음 토큰 찾기
        token = strtok(NULL, delimiters);
    }

    return 0;
}
위 예제에서는 "Hello,World,How,Are,You"라는 문자열을 콤마(,)로 구분하여 토큰으로 분리하고 출력하는 프로그램입니다. strtok 함수를 이용하여 문자열을 특정 구분자로 나눌 수 있습니다.

주의: strtok 함수는 내부적으로 정적 변수를 사용하므로, 멀티스레드 환경에서 주의가 필요합니다. 멀티스레드 환경에서는 strtok_r 함수를 사용하면 됩니다.

/end

# semaphore.h

주요 함수:

sem_init: 세마포어를 초기화합니다.
int sem_init(sem_t *sem, int pshared, unsigned int value);

인자:
	sem: 초기화할 세마포어의 포인터입니다. 이 함수를 통해 초기화된 세마포어에는 세마포어의 상태와 조작을 나타내는 정보가 저장됩니다.
	pshared: 세마포어를 프로세스 간에 공유할지 여부를 나타냅니다. 0이면 현재 프로세스 내에서만 공유되며, 그 외의 값이면 프로세스 간에 공유됩니다.
	value: 세마포어의 초기 값으로, 보통 세마포어가 허용하는 동시 접근 가능한 리소스의 수를 나타냅니다.


sem_destroy: 세마포어를 제거합니다.
int sem_destroy(sem_t *sem);

sem_wait: 세마포어를 기다립니다. 값이 0보다 크면 감소시키고, 0 이하이면 대기합니다.
int sem_wait(sem_t *sem);

sem_post: 세마포어 값을 증가시킵니다.

int sem_post(sem_t *sem);

예제 코드:
다음은 간단한 세마포어 사용 예제입니다. 이 예제는 두 개의 스레드 간에 공유 변수를 안전하게 업데이트하는 예제입니다.

#include <stdio.h>
#include <pthread.h>
#include <semaphore.h>

#define NUM_THREADS 2

int shared_variable = 0;
sem_t semaphore;

void *thread_function(void *arg) {
    int thread_id = *(int *)arg;

    // Critical Section
    sem_wait(&semaphore);
    shared_variable++;
    printf("Thread %d: Shared Variable = %d\n", thread_id, shared_variable);
    sem_post(&semaphore);

    pthread_exit(NULL);
}

int main() {
    pthread_t threads[NUM_THREADS];
    int thread_ids[NUM_THREADS];

    // Initialize semaphore
    sem_init(&semaphore, 0, 1);

    // Create threads
    for (int i = 0; i < NUM_THREADS; i++) {
        thread_ids[i] = i;
        pthread_create(&threads[i], NULL, thread_function, (void *)&thread_ids[i]);
    }

    // Join threads
    for (int i = 0; i < NUM_THREADS; i++) {
        pthread_join(threads[i], NULL);
    }

    // Destroy semaphore
    sem_destroy(&semaphore);

    return 0;
}
이 예제에서는 세마포어를 사용하여 두 개의 스레드가 공유 변수를 안전하게 업데이트하도록 보장합니다. 세마포어는 공유 자원에 대한 동시 액세스를 통제하기 위해 사용됩니다.

/end

# 조건변수예제

#include <stdio.h>
#include <stdlib.h>
#include <pthread.h>
#include <unistd.h>

#define MAX 10
#define NLOOP 10

pthread_cond_t NotEmpty = PTHREAD_COND_INITIALIZER;  // 비어 있지 않음을 나타내는 조건 변수
pthread_cond_t NotFull = PTHREAD_COND_INITIALIZER;   // 가득 차지 않음을 나타내는 조건 변수
pthread_mutex_t Mutex = PTHREAD_MUTEX_INITIALIZER;  // 뮤텍스 초기화

int buffer[MAX], count = 0;

// 생산자 스레드 함수
void Producer(void *dummy) {
    for (int i = 0; i < NLOOP; i++) {
        pthread_mutex_lock(&Mutex);

        // 버퍼가 가득 찼을 경우 대기
        while (count == MAX) {
            printf("Producer: Buffer is Full! Waiting...\n");
            pthread_cond_wait(&NotFull, &Mutex);
        }

        // 버퍼에 아이템 추가
        buffer[count] = 1;
        count++;
        printf("Producer: count is %d\n", count);

        // 소비자에게 알림
        pthread_cond_signal(&NotEmpty);
        pthread_mutex_unlock(&Mutex);

        usleep(500000);  // 생산자 스레드를 잠시 대기
    }
}

// 소비자 스레드 함수
void Consumer(void *dummy) {
    for (int i = 0; i < NLOOP; i++) {
        pthread_mutex_lock(&Mutex);

        // 버퍼가 비어 있을 경우 대기
        while (count == 0) {
            printf("Consumer: Buffer is Empty! Waiting...\n");
            pthread_cond_wait(&NotEmpty, &Mutex);
        }

        // 버퍼에서 아이템 소비
        buffer[count] = 0;
        count--;
        printf("Consumer: count is %d\n", count);

        // 생산자에게 알림
        pthread_cond_signal(&NotFull);
        pthread_mutex_unlock(&Mutex);

        usleep(300000);  // 소비자 스레드를 잠시 대기
    }
}

int main(int argc, char **argv) {
    pthread_t prod, cons;

    // 생산자 및 소비자 스레드 생성
    pthread_create(&prod, NULL, (void *)Producer, (void *)NULL);
    pthread_create(&cons, NULL, (void *)Consumer, (void *)NULL);

    // 스레드가 종료될 때까지 대기
    if (pthread_join(prod, NULL) < 0) {
        perror("pthread_join");
        exit(1);
    }
    if (pthread_join(cons, NULL) < 0) {
        perror("pthread_join");
        exit(1);
    }

    printf("Threads terminated\n");
    return 0;
}
/end


# 메시지 큐
# 메시지큐
# 메세지 큐
# 메세지큐
# msgget - 메시지 큐 생성 또는 열기


#include <sys/types.h>
#include <sys/ipc.h>
#include <sys/msg.h>

int msgget(key_t key, int msgflg);

	key: 메시지 큐 식별을 위한 키
	msgflg: 플래그 (예: IPC_CREAT, IPC_EXCL 등)

# msgsnd - 메시지 보내기

#include <sys/types.h>
#include <sys/msg.h>

int msgsnd(int msqid, const void *msgp, size_t msgsz, int msgflg);

	msqid: 메시지 큐 식별자
	msgp: 메시지 데이터 구조체의 포인터
	msgsz: 메시지의 크기
	msgflg: 플래그 (예: IPC_NOWAIT 등)

# msgrcv - 메시지 받기


#include <sys/types.h>
#include <sys/msg.h>

ssize_t msgrcv(int msqid, void *msgp, size_t msgsz, long msgtyp, int msgflg);

	msqid: 메시지 큐 식별자
	msgp: 메시지 데이터를 받을 구조체의 포인터
	msgsz: 받을 메시지의 최대 크기
	msgtyp: 받을 메시지의 타입 (0 또는 양의 정수)
	msgflg: 플래그 (예: IPC_NOWAIT 등)

# msgctl - 메시지 큐 제어

#include <sys/types.h>
#include <sys/ipc.h>
#include <sys/msg.h>

int msgctl(int msqid, int cmd, struct msqid_ds *buf);
msqid: 메시지 큐 식별자
cmd: 제어 명령 (예: IPC_RMID, IPC_STAT 등)
buf: 메시지 큐 정보를 담을 구조체의 포인터

/end

# dup